
F746_Cougar_main.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000001c8  00200000  00200000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000072e4  002001c8  002001c8  000101c8  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000c00  002074ac  002074ac  000174ac  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .init_array   00000004  002080ac  002080ac  000180ac  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .fini_array   00000004  002080b0  002080b0  000180b0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .data         00000018  20000000  002080b4  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          00000608  20000018  002080cc  00020018  2**2
                  ALLOC
  7 ._user_heap_stack 00000c00  20000620  002080cc  00020620  2**0
                  ALLOC
  8 .ARM.attributes 0000002e  00000000  00000000  00020018  2**0
                  CONTENTS, READONLY
  9 .debug_info   0002f81d  00000000  00000000  00020046  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00005281  00000000  00000000  0004f863  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000c077  00000000  00000000  00054ae4  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_aranges 00000fd8  00000000  00000000  00060b60  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 000015c0  00000000  00000000  00061b38  2**3
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   0000b1e0  00000000  00000000  000630f8  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    00005b17  00000000  00000000  0006e2d8  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .comment      000000ec  00000000  00000000  00073def  2**0
                  CONTENTS, READONLY
 17 .debug_frame  00002fd4  00000000  00000000  00073edc  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

002001c8 <__do_global_dtors_aux>:
  2001c8:	b510      	push	{r4, lr}
  2001ca:	4c05      	ldr	r4, [pc, #20]	; (2001e0 <__do_global_dtors_aux+0x18>)
  2001cc:	7823      	ldrb	r3, [r4, #0]
  2001ce:	b933      	cbnz	r3, 2001de <__do_global_dtors_aux+0x16>
  2001d0:	4b04      	ldr	r3, [pc, #16]	; (2001e4 <__do_global_dtors_aux+0x1c>)
  2001d2:	b113      	cbz	r3, 2001da <__do_global_dtors_aux+0x12>
  2001d4:	4804      	ldr	r0, [pc, #16]	; (2001e8 <__do_global_dtors_aux+0x20>)
  2001d6:	f3af 8000 	nop.w
  2001da:	2301      	movs	r3, #1
  2001dc:	7023      	strb	r3, [r4, #0]
  2001de:	bd10      	pop	{r4, pc}
  2001e0:	20000018 	.word	0x20000018
  2001e4:	00000000 	.word	0x00000000
  2001e8:	00207494 	.word	0x00207494

002001ec <frame_dummy>:
  2001ec:	b508      	push	{r3, lr}
  2001ee:	4b03      	ldr	r3, [pc, #12]	; (2001fc <frame_dummy+0x10>)
  2001f0:	b11b      	cbz	r3, 2001fa <frame_dummy+0xe>
  2001f2:	4903      	ldr	r1, [pc, #12]	; (200200 <frame_dummy+0x14>)
  2001f4:	4803      	ldr	r0, [pc, #12]	; (200204 <frame_dummy+0x18>)
  2001f6:	f3af 8000 	nop.w
  2001fa:	bd08      	pop	{r3, pc}
  2001fc:	00000000 	.word	0x00000000
  200200:	2000001c 	.word	0x2000001c
  200204:	00207494 	.word	0x00207494

00200208 <__aeabi_drsub>:
  200208:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
  20020c:	e002      	b.n	200214 <__adddf3>
  20020e:	bf00      	nop

00200210 <__aeabi_dsub>:
  200210:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

00200214 <__adddf3>:
  200214:	b530      	push	{r4, r5, lr}
  200216:	ea4f 0441 	mov.w	r4, r1, lsl #1
  20021a:	ea4f 0543 	mov.w	r5, r3, lsl #1
  20021e:	ea94 0f05 	teq	r4, r5
  200222:	bf08      	it	eq
  200224:	ea90 0f02 	teqeq	r0, r2
  200228:	bf1f      	itttt	ne
  20022a:	ea54 0c00 	orrsne.w	ip, r4, r0
  20022e:	ea55 0c02 	orrsne.w	ip, r5, r2
  200232:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
  200236:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
  20023a:	f000 80e2 	beq.w	200402 <__adddf3+0x1ee>
  20023e:	ea4f 5454 	mov.w	r4, r4, lsr #21
  200242:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
  200246:	bfb8      	it	lt
  200248:	426d      	neglt	r5, r5
  20024a:	dd0c      	ble.n	200266 <__adddf3+0x52>
  20024c:	442c      	add	r4, r5
  20024e:	ea80 0202 	eor.w	r2, r0, r2
  200252:	ea81 0303 	eor.w	r3, r1, r3
  200256:	ea82 0000 	eor.w	r0, r2, r0
  20025a:	ea83 0101 	eor.w	r1, r3, r1
  20025e:	ea80 0202 	eor.w	r2, r0, r2
  200262:	ea81 0303 	eor.w	r3, r1, r3
  200266:	2d36      	cmp	r5, #54	; 0x36
  200268:	bf88      	it	hi
  20026a:	bd30      	pophi	{r4, r5, pc}
  20026c:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
  200270:	ea4f 3101 	mov.w	r1, r1, lsl #12
  200274:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
  200278:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
  20027c:	d002      	beq.n	200284 <__adddf3+0x70>
  20027e:	4240      	negs	r0, r0
  200280:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
  200284:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
  200288:	ea4f 3303 	mov.w	r3, r3, lsl #12
  20028c:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
  200290:	d002      	beq.n	200298 <__adddf3+0x84>
  200292:	4252      	negs	r2, r2
  200294:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
  200298:	ea94 0f05 	teq	r4, r5
  20029c:	f000 80a7 	beq.w	2003ee <__adddf3+0x1da>
  2002a0:	f1a4 0401 	sub.w	r4, r4, #1
  2002a4:	f1d5 0e20 	rsbs	lr, r5, #32
  2002a8:	db0d      	blt.n	2002c6 <__adddf3+0xb2>
  2002aa:	fa02 fc0e 	lsl.w	ip, r2, lr
  2002ae:	fa22 f205 	lsr.w	r2, r2, r5
  2002b2:	1880      	adds	r0, r0, r2
  2002b4:	f141 0100 	adc.w	r1, r1, #0
  2002b8:	fa03 f20e 	lsl.w	r2, r3, lr
  2002bc:	1880      	adds	r0, r0, r2
  2002be:	fa43 f305 	asr.w	r3, r3, r5
  2002c2:	4159      	adcs	r1, r3
  2002c4:	e00e      	b.n	2002e4 <__adddf3+0xd0>
  2002c6:	f1a5 0520 	sub.w	r5, r5, #32
  2002ca:	f10e 0e20 	add.w	lr, lr, #32
  2002ce:	2a01      	cmp	r2, #1
  2002d0:	fa03 fc0e 	lsl.w	ip, r3, lr
  2002d4:	bf28      	it	cs
  2002d6:	f04c 0c02 	orrcs.w	ip, ip, #2
  2002da:	fa43 f305 	asr.w	r3, r3, r5
  2002de:	18c0      	adds	r0, r0, r3
  2002e0:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
  2002e4:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
  2002e8:	d507      	bpl.n	2002fa <__adddf3+0xe6>
  2002ea:	f04f 0e00 	mov.w	lr, #0
  2002ee:	f1dc 0c00 	rsbs	ip, ip, #0
  2002f2:	eb7e 0000 	sbcs.w	r0, lr, r0
  2002f6:	eb6e 0101 	sbc.w	r1, lr, r1
  2002fa:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
  2002fe:	d31b      	bcc.n	200338 <__adddf3+0x124>
  200300:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
  200304:	d30c      	bcc.n	200320 <__adddf3+0x10c>
  200306:	0849      	lsrs	r1, r1, #1
  200308:	ea5f 0030 	movs.w	r0, r0, rrx
  20030c:	ea4f 0c3c 	mov.w	ip, ip, rrx
  200310:	f104 0401 	add.w	r4, r4, #1
  200314:	ea4f 5244 	mov.w	r2, r4, lsl #21
  200318:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
  20031c:	f080 809a 	bcs.w	200454 <__adddf3+0x240>
  200320:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
  200324:	bf08      	it	eq
  200326:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
  20032a:	f150 0000 	adcs.w	r0, r0, #0
  20032e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
  200332:	ea41 0105 	orr.w	r1, r1, r5
  200336:	bd30      	pop	{r4, r5, pc}
  200338:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
  20033c:	4140      	adcs	r0, r0
  20033e:	eb41 0101 	adc.w	r1, r1, r1
  200342:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
  200346:	f1a4 0401 	sub.w	r4, r4, #1
  20034a:	d1e9      	bne.n	200320 <__adddf3+0x10c>
  20034c:	f091 0f00 	teq	r1, #0
  200350:	bf04      	itt	eq
  200352:	4601      	moveq	r1, r0
  200354:	2000      	moveq	r0, #0
  200356:	fab1 f381 	clz	r3, r1
  20035a:	bf08      	it	eq
  20035c:	3320      	addeq	r3, #32
  20035e:	f1a3 030b 	sub.w	r3, r3, #11
  200362:	f1b3 0220 	subs.w	r2, r3, #32
  200366:	da0c      	bge.n	200382 <__adddf3+0x16e>
  200368:	320c      	adds	r2, #12
  20036a:	dd08      	ble.n	20037e <__adddf3+0x16a>
  20036c:	f102 0c14 	add.w	ip, r2, #20
  200370:	f1c2 020c 	rsb	r2, r2, #12
  200374:	fa01 f00c 	lsl.w	r0, r1, ip
  200378:	fa21 f102 	lsr.w	r1, r1, r2
  20037c:	e00c      	b.n	200398 <__adddf3+0x184>
  20037e:	f102 0214 	add.w	r2, r2, #20
  200382:	bfd8      	it	le
  200384:	f1c2 0c20 	rsble	ip, r2, #32
  200388:	fa01 f102 	lsl.w	r1, r1, r2
  20038c:	fa20 fc0c 	lsr.w	ip, r0, ip
  200390:	bfdc      	itt	le
  200392:	ea41 010c 	orrle.w	r1, r1, ip
  200396:	4090      	lslle	r0, r2
  200398:	1ae4      	subs	r4, r4, r3
  20039a:	bfa2      	ittt	ge
  20039c:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
  2003a0:	4329      	orrge	r1, r5
  2003a2:	bd30      	popge	{r4, r5, pc}
  2003a4:	ea6f 0404 	mvn.w	r4, r4
  2003a8:	3c1f      	subs	r4, #31
  2003aa:	da1c      	bge.n	2003e6 <__adddf3+0x1d2>
  2003ac:	340c      	adds	r4, #12
  2003ae:	dc0e      	bgt.n	2003ce <__adddf3+0x1ba>
  2003b0:	f104 0414 	add.w	r4, r4, #20
  2003b4:	f1c4 0220 	rsb	r2, r4, #32
  2003b8:	fa20 f004 	lsr.w	r0, r0, r4
  2003bc:	fa01 f302 	lsl.w	r3, r1, r2
  2003c0:	ea40 0003 	orr.w	r0, r0, r3
  2003c4:	fa21 f304 	lsr.w	r3, r1, r4
  2003c8:	ea45 0103 	orr.w	r1, r5, r3
  2003cc:	bd30      	pop	{r4, r5, pc}
  2003ce:	f1c4 040c 	rsb	r4, r4, #12
  2003d2:	f1c4 0220 	rsb	r2, r4, #32
  2003d6:	fa20 f002 	lsr.w	r0, r0, r2
  2003da:	fa01 f304 	lsl.w	r3, r1, r4
  2003de:	ea40 0003 	orr.w	r0, r0, r3
  2003e2:	4629      	mov	r1, r5
  2003e4:	bd30      	pop	{r4, r5, pc}
  2003e6:	fa21 f004 	lsr.w	r0, r1, r4
  2003ea:	4629      	mov	r1, r5
  2003ec:	bd30      	pop	{r4, r5, pc}
  2003ee:	f094 0f00 	teq	r4, #0
  2003f2:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
  2003f6:	bf06      	itte	eq
  2003f8:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
  2003fc:	3401      	addeq	r4, #1
  2003fe:	3d01      	subne	r5, #1
  200400:	e74e      	b.n	2002a0 <__adddf3+0x8c>
  200402:	ea7f 5c64 	mvns.w	ip, r4, asr #21
  200406:	bf18      	it	ne
  200408:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
  20040c:	d029      	beq.n	200462 <__adddf3+0x24e>
  20040e:	ea94 0f05 	teq	r4, r5
  200412:	bf08      	it	eq
  200414:	ea90 0f02 	teqeq	r0, r2
  200418:	d005      	beq.n	200426 <__adddf3+0x212>
  20041a:	ea54 0c00 	orrs.w	ip, r4, r0
  20041e:	bf04      	itt	eq
  200420:	4619      	moveq	r1, r3
  200422:	4610      	moveq	r0, r2
  200424:	bd30      	pop	{r4, r5, pc}
  200426:	ea91 0f03 	teq	r1, r3
  20042a:	bf1e      	ittt	ne
  20042c:	2100      	movne	r1, #0
  20042e:	2000      	movne	r0, #0
  200430:	bd30      	popne	{r4, r5, pc}
  200432:	ea5f 5c54 	movs.w	ip, r4, lsr #21
  200436:	d105      	bne.n	200444 <__adddf3+0x230>
  200438:	0040      	lsls	r0, r0, #1
  20043a:	4149      	adcs	r1, r1
  20043c:	bf28      	it	cs
  20043e:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
  200442:	bd30      	pop	{r4, r5, pc}
  200444:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
  200448:	bf3c      	itt	cc
  20044a:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
  20044e:	bd30      	popcc	{r4, r5, pc}
  200450:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
  200454:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
  200458:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
  20045c:	f04f 0000 	mov.w	r0, #0
  200460:	bd30      	pop	{r4, r5, pc}
  200462:	ea7f 5c64 	mvns.w	ip, r4, asr #21
  200466:	bf1a      	itte	ne
  200468:	4619      	movne	r1, r3
  20046a:	4610      	movne	r0, r2
  20046c:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
  200470:	bf1c      	itt	ne
  200472:	460b      	movne	r3, r1
  200474:	4602      	movne	r2, r0
  200476:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
  20047a:	bf06      	itte	eq
  20047c:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
  200480:	ea91 0f03 	teqeq	r1, r3
  200484:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
  200488:	bd30      	pop	{r4, r5, pc}
  20048a:	bf00      	nop

0020048c <__aeabi_ui2d>:
  20048c:	f090 0f00 	teq	r0, #0
  200490:	bf04      	itt	eq
  200492:	2100      	moveq	r1, #0
  200494:	4770      	bxeq	lr
  200496:	b530      	push	{r4, r5, lr}
  200498:	f44f 6480 	mov.w	r4, #1024	; 0x400
  20049c:	f104 0432 	add.w	r4, r4, #50	; 0x32
  2004a0:	f04f 0500 	mov.w	r5, #0
  2004a4:	f04f 0100 	mov.w	r1, #0
  2004a8:	e750      	b.n	20034c <__adddf3+0x138>
  2004aa:	bf00      	nop

002004ac <__aeabi_i2d>:
  2004ac:	f090 0f00 	teq	r0, #0
  2004b0:	bf04      	itt	eq
  2004b2:	2100      	moveq	r1, #0
  2004b4:	4770      	bxeq	lr
  2004b6:	b530      	push	{r4, r5, lr}
  2004b8:	f44f 6480 	mov.w	r4, #1024	; 0x400
  2004bc:	f104 0432 	add.w	r4, r4, #50	; 0x32
  2004c0:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
  2004c4:	bf48      	it	mi
  2004c6:	4240      	negmi	r0, r0
  2004c8:	f04f 0100 	mov.w	r1, #0
  2004cc:	e73e      	b.n	20034c <__adddf3+0x138>
  2004ce:	bf00      	nop

002004d0 <__aeabi_f2d>:
  2004d0:	0042      	lsls	r2, r0, #1
  2004d2:	ea4f 01e2 	mov.w	r1, r2, asr #3
  2004d6:	ea4f 0131 	mov.w	r1, r1, rrx
  2004da:	ea4f 7002 	mov.w	r0, r2, lsl #28
  2004de:	bf1f      	itttt	ne
  2004e0:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
  2004e4:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
  2004e8:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
  2004ec:	4770      	bxne	lr
  2004ee:	f092 0f00 	teq	r2, #0
  2004f2:	bf14      	ite	ne
  2004f4:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
  2004f8:	4770      	bxeq	lr
  2004fa:	b530      	push	{r4, r5, lr}
  2004fc:	f44f 7460 	mov.w	r4, #896	; 0x380
  200500:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
  200504:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
  200508:	e720      	b.n	20034c <__adddf3+0x138>
  20050a:	bf00      	nop

0020050c <__aeabi_ul2d>:
  20050c:	ea50 0201 	orrs.w	r2, r0, r1
  200510:	bf08      	it	eq
  200512:	4770      	bxeq	lr
  200514:	b530      	push	{r4, r5, lr}
  200516:	f04f 0500 	mov.w	r5, #0
  20051a:	e00a      	b.n	200532 <__aeabi_l2d+0x16>

0020051c <__aeabi_l2d>:
  20051c:	ea50 0201 	orrs.w	r2, r0, r1
  200520:	bf08      	it	eq
  200522:	4770      	bxeq	lr
  200524:	b530      	push	{r4, r5, lr}
  200526:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
  20052a:	d502      	bpl.n	200532 <__aeabi_l2d+0x16>
  20052c:	4240      	negs	r0, r0
  20052e:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
  200532:	f44f 6480 	mov.w	r4, #1024	; 0x400
  200536:	f104 0432 	add.w	r4, r4, #50	; 0x32
  20053a:	ea5f 5c91 	movs.w	ip, r1, lsr #22
  20053e:	f43f aedc 	beq.w	2002fa <__adddf3+0xe6>
  200542:	f04f 0203 	mov.w	r2, #3
  200546:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
  20054a:	bf18      	it	ne
  20054c:	3203      	addne	r2, #3
  20054e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
  200552:	bf18      	it	ne
  200554:	3203      	addne	r2, #3
  200556:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
  20055a:	f1c2 0320 	rsb	r3, r2, #32
  20055e:	fa00 fc03 	lsl.w	ip, r0, r3
  200562:	fa20 f002 	lsr.w	r0, r0, r2
  200566:	fa01 fe03 	lsl.w	lr, r1, r3
  20056a:	ea40 000e 	orr.w	r0, r0, lr
  20056e:	fa21 f102 	lsr.w	r1, r1, r2
  200572:	4414      	add	r4, r2
  200574:	e6c1      	b.n	2002fa <__adddf3+0xe6>
  200576:	bf00      	nop

00200578 <__aeabi_dmul>:
  200578:	b570      	push	{r4, r5, r6, lr}
  20057a:	f04f 0cff 	mov.w	ip, #255	; 0xff
  20057e:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
  200582:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
  200586:	bf1d      	ittte	ne
  200588:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
  20058c:	ea94 0f0c 	teqne	r4, ip
  200590:	ea95 0f0c 	teqne	r5, ip
  200594:	f000 f8de 	bleq	200754 <__aeabi_dmul+0x1dc>
  200598:	442c      	add	r4, r5
  20059a:	ea81 0603 	eor.w	r6, r1, r3
  20059e:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
  2005a2:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
  2005a6:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
  2005aa:	bf18      	it	ne
  2005ac:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
  2005b0:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
  2005b4:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
  2005b8:	d038      	beq.n	20062c <__aeabi_dmul+0xb4>
  2005ba:	fba0 ce02 	umull	ip, lr, r0, r2
  2005be:	f04f 0500 	mov.w	r5, #0
  2005c2:	fbe1 e502 	umlal	lr, r5, r1, r2
  2005c6:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
  2005ca:	fbe0 e503 	umlal	lr, r5, r0, r3
  2005ce:	f04f 0600 	mov.w	r6, #0
  2005d2:	fbe1 5603 	umlal	r5, r6, r1, r3
  2005d6:	f09c 0f00 	teq	ip, #0
  2005da:	bf18      	it	ne
  2005dc:	f04e 0e01 	orrne.w	lr, lr, #1
  2005e0:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
  2005e4:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
  2005e8:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
  2005ec:	d204      	bcs.n	2005f8 <__aeabi_dmul+0x80>
  2005ee:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
  2005f2:	416d      	adcs	r5, r5
  2005f4:	eb46 0606 	adc.w	r6, r6, r6
  2005f8:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
  2005fc:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
  200600:	ea4f 20c5 	mov.w	r0, r5, lsl #11
  200604:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
  200608:	ea4f 2ece 	mov.w	lr, lr, lsl #11
  20060c:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
  200610:	bf88      	it	hi
  200612:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
  200616:	d81e      	bhi.n	200656 <__aeabi_dmul+0xde>
  200618:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
  20061c:	bf08      	it	eq
  20061e:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
  200622:	f150 0000 	adcs.w	r0, r0, #0
  200626:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
  20062a:	bd70      	pop	{r4, r5, r6, pc}
  20062c:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
  200630:	ea46 0101 	orr.w	r1, r6, r1
  200634:	ea40 0002 	orr.w	r0, r0, r2
  200638:	ea81 0103 	eor.w	r1, r1, r3
  20063c:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
  200640:	bfc2      	ittt	gt
  200642:	ebd4 050c 	rsbsgt	r5, r4, ip
  200646:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
  20064a:	bd70      	popgt	{r4, r5, r6, pc}
  20064c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
  200650:	f04f 0e00 	mov.w	lr, #0
  200654:	3c01      	subs	r4, #1
  200656:	f300 80ab 	bgt.w	2007b0 <__aeabi_dmul+0x238>
  20065a:	f114 0f36 	cmn.w	r4, #54	; 0x36
  20065e:	bfde      	ittt	le
  200660:	2000      	movle	r0, #0
  200662:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
  200666:	bd70      	pople	{r4, r5, r6, pc}
  200668:	f1c4 0400 	rsb	r4, r4, #0
  20066c:	3c20      	subs	r4, #32
  20066e:	da35      	bge.n	2006dc <__aeabi_dmul+0x164>
  200670:	340c      	adds	r4, #12
  200672:	dc1b      	bgt.n	2006ac <__aeabi_dmul+0x134>
  200674:	f104 0414 	add.w	r4, r4, #20
  200678:	f1c4 0520 	rsb	r5, r4, #32
  20067c:	fa00 f305 	lsl.w	r3, r0, r5
  200680:	fa20 f004 	lsr.w	r0, r0, r4
  200684:	fa01 f205 	lsl.w	r2, r1, r5
  200688:	ea40 0002 	orr.w	r0, r0, r2
  20068c:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
  200690:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
  200694:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
  200698:	fa21 f604 	lsr.w	r6, r1, r4
  20069c:	eb42 0106 	adc.w	r1, r2, r6
  2006a0:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
  2006a4:	bf08      	it	eq
  2006a6:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
  2006aa:	bd70      	pop	{r4, r5, r6, pc}
  2006ac:	f1c4 040c 	rsb	r4, r4, #12
  2006b0:	f1c4 0520 	rsb	r5, r4, #32
  2006b4:	fa00 f304 	lsl.w	r3, r0, r4
  2006b8:	fa20 f005 	lsr.w	r0, r0, r5
  2006bc:	fa01 f204 	lsl.w	r2, r1, r4
  2006c0:	ea40 0002 	orr.w	r0, r0, r2
  2006c4:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
  2006c8:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
  2006cc:	f141 0100 	adc.w	r1, r1, #0
  2006d0:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
  2006d4:	bf08      	it	eq
  2006d6:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
  2006da:	bd70      	pop	{r4, r5, r6, pc}
  2006dc:	f1c4 0520 	rsb	r5, r4, #32
  2006e0:	fa00 f205 	lsl.w	r2, r0, r5
  2006e4:	ea4e 0e02 	orr.w	lr, lr, r2
  2006e8:	fa20 f304 	lsr.w	r3, r0, r4
  2006ec:	fa01 f205 	lsl.w	r2, r1, r5
  2006f0:	ea43 0302 	orr.w	r3, r3, r2
  2006f4:	fa21 f004 	lsr.w	r0, r1, r4
  2006f8:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
  2006fc:	fa21 f204 	lsr.w	r2, r1, r4
  200700:	ea20 0002 	bic.w	r0, r0, r2
  200704:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
  200708:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
  20070c:	bf08      	it	eq
  20070e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
  200712:	bd70      	pop	{r4, r5, r6, pc}
  200714:	f094 0f00 	teq	r4, #0
  200718:	d10f      	bne.n	20073a <__aeabi_dmul+0x1c2>
  20071a:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
  20071e:	0040      	lsls	r0, r0, #1
  200720:	eb41 0101 	adc.w	r1, r1, r1
  200724:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
  200728:	bf08      	it	eq
  20072a:	3c01      	subeq	r4, #1
  20072c:	d0f7      	beq.n	20071e <__aeabi_dmul+0x1a6>
  20072e:	ea41 0106 	orr.w	r1, r1, r6
  200732:	f095 0f00 	teq	r5, #0
  200736:	bf18      	it	ne
  200738:	4770      	bxne	lr
  20073a:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
  20073e:	0052      	lsls	r2, r2, #1
  200740:	eb43 0303 	adc.w	r3, r3, r3
  200744:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
  200748:	bf08      	it	eq
  20074a:	3d01      	subeq	r5, #1
  20074c:	d0f7      	beq.n	20073e <__aeabi_dmul+0x1c6>
  20074e:	ea43 0306 	orr.w	r3, r3, r6
  200752:	4770      	bx	lr
  200754:	ea94 0f0c 	teq	r4, ip
  200758:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
  20075c:	bf18      	it	ne
  20075e:	ea95 0f0c 	teqne	r5, ip
  200762:	d00c      	beq.n	20077e <__aeabi_dmul+0x206>
  200764:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
  200768:	bf18      	it	ne
  20076a:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
  20076e:	d1d1      	bne.n	200714 <__aeabi_dmul+0x19c>
  200770:	ea81 0103 	eor.w	r1, r1, r3
  200774:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
  200778:	f04f 0000 	mov.w	r0, #0
  20077c:	bd70      	pop	{r4, r5, r6, pc}
  20077e:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
  200782:	bf06      	itte	eq
  200784:	4610      	moveq	r0, r2
  200786:	4619      	moveq	r1, r3
  200788:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
  20078c:	d019      	beq.n	2007c2 <__aeabi_dmul+0x24a>
  20078e:	ea94 0f0c 	teq	r4, ip
  200792:	d102      	bne.n	20079a <__aeabi_dmul+0x222>
  200794:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
  200798:	d113      	bne.n	2007c2 <__aeabi_dmul+0x24a>
  20079a:	ea95 0f0c 	teq	r5, ip
  20079e:	d105      	bne.n	2007ac <__aeabi_dmul+0x234>
  2007a0:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
  2007a4:	bf1c      	itt	ne
  2007a6:	4610      	movne	r0, r2
  2007a8:	4619      	movne	r1, r3
  2007aa:	d10a      	bne.n	2007c2 <__aeabi_dmul+0x24a>
  2007ac:	ea81 0103 	eor.w	r1, r1, r3
  2007b0:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
  2007b4:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
  2007b8:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
  2007bc:	f04f 0000 	mov.w	r0, #0
  2007c0:	bd70      	pop	{r4, r5, r6, pc}
  2007c2:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
  2007c6:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
  2007ca:	bd70      	pop	{r4, r5, r6, pc}

002007cc <__aeabi_ddiv>:
  2007cc:	b570      	push	{r4, r5, r6, lr}
  2007ce:	f04f 0cff 	mov.w	ip, #255	; 0xff
  2007d2:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
  2007d6:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
  2007da:	bf1d      	ittte	ne
  2007dc:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
  2007e0:	ea94 0f0c 	teqne	r4, ip
  2007e4:	ea95 0f0c 	teqne	r5, ip
  2007e8:	f000 f8a7 	bleq	20093a <__aeabi_ddiv+0x16e>
  2007ec:	eba4 0405 	sub.w	r4, r4, r5
  2007f0:	ea81 0e03 	eor.w	lr, r1, r3
  2007f4:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
  2007f8:	ea4f 3101 	mov.w	r1, r1, lsl #12
  2007fc:	f000 8088 	beq.w	200910 <__aeabi_ddiv+0x144>
  200800:	ea4f 3303 	mov.w	r3, r3, lsl #12
  200804:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
  200808:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
  20080c:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
  200810:	ea4f 2202 	mov.w	r2, r2, lsl #8
  200814:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
  200818:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
  20081c:	ea4f 2600 	mov.w	r6, r0, lsl #8
  200820:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
  200824:	429d      	cmp	r5, r3
  200826:	bf08      	it	eq
  200828:	4296      	cmpeq	r6, r2
  20082a:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
  20082e:	f504 7440 	add.w	r4, r4, #768	; 0x300
  200832:	d202      	bcs.n	20083a <__aeabi_ddiv+0x6e>
  200834:	085b      	lsrs	r3, r3, #1
  200836:	ea4f 0232 	mov.w	r2, r2, rrx
  20083a:	1ab6      	subs	r6, r6, r2
  20083c:	eb65 0503 	sbc.w	r5, r5, r3
  200840:	085b      	lsrs	r3, r3, #1
  200842:	ea4f 0232 	mov.w	r2, r2, rrx
  200846:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
  20084a:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
  20084e:	ebb6 0e02 	subs.w	lr, r6, r2
  200852:	eb75 0e03 	sbcs.w	lr, r5, r3
  200856:	bf22      	ittt	cs
  200858:	1ab6      	subcs	r6, r6, r2
  20085a:	4675      	movcs	r5, lr
  20085c:	ea40 000c 	orrcs.w	r0, r0, ip
  200860:	085b      	lsrs	r3, r3, #1
  200862:	ea4f 0232 	mov.w	r2, r2, rrx
  200866:	ebb6 0e02 	subs.w	lr, r6, r2
  20086a:	eb75 0e03 	sbcs.w	lr, r5, r3
  20086e:	bf22      	ittt	cs
  200870:	1ab6      	subcs	r6, r6, r2
  200872:	4675      	movcs	r5, lr
  200874:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
  200878:	085b      	lsrs	r3, r3, #1
  20087a:	ea4f 0232 	mov.w	r2, r2, rrx
  20087e:	ebb6 0e02 	subs.w	lr, r6, r2
  200882:	eb75 0e03 	sbcs.w	lr, r5, r3
  200886:	bf22      	ittt	cs
  200888:	1ab6      	subcs	r6, r6, r2
  20088a:	4675      	movcs	r5, lr
  20088c:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
  200890:	085b      	lsrs	r3, r3, #1
  200892:	ea4f 0232 	mov.w	r2, r2, rrx
  200896:	ebb6 0e02 	subs.w	lr, r6, r2
  20089a:	eb75 0e03 	sbcs.w	lr, r5, r3
  20089e:	bf22      	ittt	cs
  2008a0:	1ab6      	subcs	r6, r6, r2
  2008a2:	4675      	movcs	r5, lr
  2008a4:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
  2008a8:	ea55 0e06 	orrs.w	lr, r5, r6
  2008ac:	d018      	beq.n	2008e0 <__aeabi_ddiv+0x114>
  2008ae:	ea4f 1505 	mov.w	r5, r5, lsl #4
  2008b2:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
  2008b6:	ea4f 1606 	mov.w	r6, r6, lsl #4
  2008ba:	ea4f 03c3 	mov.w	r3, r3, lsl #3
  2008be:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
  2008c2:	ea4f 02c2 	mov.w	r2, r2, lsl #3
  2008c6:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
  2008ca:	d1c0      	bne.n	20084e <__aeabi_ddiv+0x82>
  2008cc:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
  2008d0:	d10b      	bne.n	2008ea <__aeabi_ddiv+0x11e>
  2008d2:	ea41 0100 	orr.w	r1, r1, r0
  2008d6:	f04f 0000 	mov.w	r0, #0
  2008da:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
  2008de:	e7b6      	b.n	20084e <__aeabi_ddiv+0x82>
  2008e0:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
  2008e4:	bf04      	itt	eq
  2008e6:	4301      	orreq	r1, r0
  2008e8:	2000      	moveq	r0, #0
  2008ea:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
  2008ee:	bf88      	it	hi
  2008f0:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
  2008f4:	f63f aeaf 	bhi.w	200656 <__aeabi_dmul+0xde>
  2008f8:	ebb5 0c03 	subs.w	ip, r5, r3
  2008fc:	bf04      	itt	eq
  2008fe:	ebb6 0c02 	subseq.w	ip, r6, r2
  200902:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
  200906:	f150 0000 	adcs.w	r0, r0, #0
  20090a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
  20090e:	bd70      	pop	{r4, r5, r6, pc}
  200910:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
  200914:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
  200918:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
  20091c:	bfc2      	ittt	gt
  20091e:	ebd4 050c 	rsbsgt	r5, r4, ip
  200922:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
  200926:	bd70      	popgt	{r4, r5, r6, pc}
  200928:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
  20092c:	f04f 0e00 	mov.w	lr, #0
  200930:	3c01      	subs	r4, #1
  200932:	e690      	b.n	200656 <__aeabi_dmul+0xde>
  200934:	ea45 0e06 	orr.w	lr, r5, r6
  200938:	e68d      	b.n	200656 <__aeabi_dmul+0xde>
  20093a:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
  20093e:	ea94 0f0c 	teq	r4, ip
  200942:	bf08      	it	eq
  200944:	ea95 0f0c 	teqeq	r5, ip
  200948:	f43f af3b 	beq.w	2007c2 <__aeabi_dmul+0x24a>
  20094c:	ea94 0f0c 	teq	r4, ip
  200950:	d10a      	bne.n	200968 <__aeabi_ddiv+0x19c>
  200952:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
  200956:	f47f af34 	bne.w	2007c2 <__aeabi_dmul+0x24a>
  20095a:	ea95 0f0c 	teq	r5, ip
  20095e:	f47f af25 	bne.w	2007ac <__aeabi_dmul+0x234>
  200962:	4610      	mov	r0, r2
  200964:	4619      	mov	r1, r3
  200966:	e72c      	b.n	2007c2 <__aeabi_dmul+0x24a>
  200968:	ea95 0f0c 	teq	r5, ip
  20096c:	d106      	bne.n	20097c <__aeabi_ddiv+0x1b0>
  20096e:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
  200972:	f43f aefd 	beq.w	200770 <__aeabi_dmul+0x1f8>
  200976:	4610      	mov	r0, r2
  200978:	4619      	mov	r1, r3
  20097a:	e722      	b.n	2007c2 <__aeabi_dmul+0x24a>
  20097c:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
  200980:	bf18      	it	ne
  200982:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
  200986:	f47f aec5 	bne.w	200714 <__aeabi_dmul+0x19c>
  20098a:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
  20098e:	f47f af0d 	bne.w	2007ac <__aeabi_dmul+0x234>
  200992:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
  200996:	f47f aeeb 	bne.w	200770 <__aeabi_dmul+0x1f8>
  20099a:	e712      	b.n	2007c2 <__aeabi_dmul+0x24a>

0020099c <__aeabi_d2f>:
  20099c:	ea4f 0241 	mov.w	r2, r1, lsl #1
  2009a0:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
  2009a4:	bf24      	itt	cs
  2009a6:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
  2009aa:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
  2009ae:	d90d      	bls.n	2009cc <__aeabi_d2f+0x30>
  2009b0:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
  2009b4:	ea4f 02c0 	mov.w	r2, r0, lsl #3
  2009b8:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
  2009bc:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
  2009c0:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
  2009c4:	bf08      	it	eq
  2009c6:	f020 0001 	biceq.w	r0, r0, #1
  2009ca:	4770      	bx	lr
  2009cc:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
  2009d0:	d121      	bne.n	200a16 <__aeabi_d2f+0x7a>
  2009d2:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
  2009d6:	bfbc      	itt	lt
  2009d8:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
  2009dc:	4770      	bxlt	lr
  2009de:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
  2009e2:	ea4f 5252 	mov.w	r2, r2, lsr #21
  2009e6:	f1c2 0218 	rsb	r2, r2, #24
  2009ea:	f1c2 0c20 	rsb	ip, r2, #32
  2009ee:	fa10 f30c 	lsls.w	r3, r0, ip
  2009f2:	fa20 f002 	lsr.w	r0, r0, r2
  2009f6:	bf18      	it	ne
  2009f8:	f040 0001 	orrne.w	r0, r0, #1
  2009fc:	ea4f 23c1 	mov.w	r3, r1, lsl #11
  200a00:	ea4f 23d3 	mov.w	r3, r3, lsr #11
  200a04:	fa03 fc0c 	lsl.w	ip, r3, ip
  200a08:	ea40 000c 	orr.w	r0, r0, ip
  200a0c:	fa23 f302 	lsr.w	r3, r3, r2
  200a10:	ea4f 0343 	mov.w	r3, r3, lsl #1
  200a14:	e7cc      	b.n	2009b0 <__aeabi_d2f+0x14>
  200a16:	ea7f 5362 	mvns.w	r3, r2, asr #21
  200a1a:	d107      	bne.n	200a2c <__aeabi_d2f+0x90>
  200a1c:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
  200a20:	bf1e      	ittt	ne
  200a22:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
  200a26:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
  200a2a:	4770      	bxne	lr
  200a2c:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
  200a30:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
  200a34:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
  200a38:	4770      	bx	lr
  200a3a:	bf00      	nop

00200a3c <HAL_InitTick>:
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
  /*Configure the SysTick to have interrupt in 1ms time basis*/
  HAL_SYSTICK_Config(SystemCoreClock/1000);
  200a3c:	4b08      	ldr	r3, [pc, #32]	; (200a60 <HAL_InitTick+0x24>)
{
  200a3e:	b510      	push	{r4, lr}
  200a40:	4604      	mov	r4, r0
  HAL_SYSTICK_Config(SystemCoreClock/1000);
  200a42:	6818      	ldr	r0, [r3, #0]
  200a44:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
  200a48:	fbb0 f0f3 	udiv	r0, r0, r3
  200a4c:	f000 f88e 	bl	200b6c <HAL_SYSTICK_Config>

  /*Configure the SysTick IRQ priority */
  HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority ,0);
  200a50:	2200      	movs	r2, #0
  200a52:	4621      	mov	r1, r4
  200a54:	f04f 30ff 	mov.w	r0, #4294967295
  200a58:	f000 f844 	bl	200ae4 <HAL_NVIC_SetPriority>

  /* Return function status */
  return HAL_OK;
}
  200a5c:	2000      	movs	r0, #0
  200a5e:	bd10      	pop	{r4, pc}
  200a60:	20000014 	.word	0x20000014

00200a64 <HAL_Init>:
   __HAL_FLASH_ART_ENABLE();
  200a64:	4a07      	ldr	r2, [pc, #28]	; (200a84 <HAL_Init+0x20>)
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
  200a66:	2003      	movs	r0, #3
{
  200a68:	b508      	push	{r3, lr}
   __HAL_FLASH_ART_ENABLE();
  200a6a:	6813      	ldr	r3, [r2, #0]
  200a6c:	f443 7300 	orr.w	r3, r3, #512	; 0x200
  200a70:	6013      	str	r3, [r2, #0]
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
  200a72:	f000 f825 	bl	200ac0 <HAL_NVIC_SetPriorityGrouping>
  HAL_InitTick(TICK_INT_PRIORITY);
  200a76:	2000      	movs	r0, #0
  200a78:	f7ff ffe0 	bl	200a3c <HAL_InitTick>
  HAL_MspInit();
  200a7c:	f005 fd72 	bl	206564 <HAL_MspInit>
}
  200a80:	2000      	movs	r0, #0
  200a82:	bd08      	pop	{r3, pc}
  200a84:	40023c00 	.word	0x40023c00

00200a88 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick++;
  200a88:	4a02      	ldr	r2, [pc, #8]	; (200a94 <HAL_IncTick+0xc>)
  200a8a:	6813      	ldr	r3, [r2, #0]
  200a8c:	3301      	adds	r3, #1
  200a8e:	6013      	str	r3, [r2, #0]
  200a90:	4770      	bx	lr
  200a92:	bf00      	nop
  200a94:	2000004c 	.word	0x2000004c

00200a98 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
  200a98:	4b01      	ldr	r3, [pc, #4]	; (200aa0 <HAL_GetTick+0x8>)
  200a9a:	6818      	ldr	r0, [r3, #0]
}
  200a9c:	4770      	bx	lr
  200a9e:	bf00      	nop
  200aa0:	2000004c 	.word	0x2000004c

00200aa4 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay: specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(__IO uint32_t Delay)
{
  200aa4:	b513      	push	{r0, r1, r4, lr}
  200aa6:	9001      	str	r0, [sp, #4]
  uint32_t tickstart = 0;
  tickstart = HAL_GetTick();
  200aa8:	f7ff fff6 	bl	200a98 <HAL_GetTick>
  200aac:	4604      	mov	r4, r0
  while((HAL_GetTick() - tickstart) < Delay)
  200aae:	f7ff fff3 	bl	200a98 <HAL_GetTick>
  200ab2:	9b01      	ldr	r3, [sp, #4]
  200ab4:	1b00      	subs	r0, r0, r4
  200ab6:	4298      	cmp	r0, r3
  200ab8:	d3f9      	bcc.n	200aae <HAL_Delay+0xa>
  {
  }
}
  200aba:	b002      	add	sp, #8
  200abc:	bd10      	pop	{r4, pc}
	...

00200ac0 <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  200ac0:	4a07      	ldr	r2, [pc, #28]	; (200ae0 <HAL_NVIC_SetPriorityGrouping+0x20>)
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
  200ac2:	0200      	lsls	r0, r0, #8
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  200ac4:	68d3      	ldr	r3, [r2, #12]
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
  200ac6:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  200aca:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
  200ace:	041b      	lsls	r3, r3, #16
  200ad0:	0c1b      	lsrs	r3, r3, #16
  200ad2:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
  200ad6:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  reg_value  =  (reg_value                                   |
  200ada:	4303      	orrs	r3, r0
  SCB->AIRCR =  reg_value;
  200adc:	60d3      	str	r3, [r2, #12]
  200ade:	4770      	bx	lr
  200ae0:	e000ed00 	.word	0xe000ed00

00200ae4 <HAL_NVIC_SetPriority>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
  200ae4:	4b19      	ldr	r3, [pc, #100]	; (200b4c <HAL_NVIC_SetPriority+0x68>)
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
  200ae6:	b530      	push	{r4, r5, lr}
  200ae8:	68dc      	ldr	r4, [r3, #12]
  200aea:	f3c4 2402 	ubfx	r4, r4, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  200aee:	f1c4 0307 	rsb	r3, r4, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
  200af2:	1d25      	adds	r5, r4, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  200af4:	2b04      	cmp	r3, #4
  200af6:	bf28      	it	cs
  200af8:	2304      	movcs	r3, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
  200afa:	2d06      	cmp	r5, #6

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
  200afc:	f04f 0501 	mov.w	r5, #1
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
  200b00:	bf8c      	ite	hi
  200b02:	3c03      	subhi	r4, #3
  200b04:	2400      	movls	r4, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
  200b06:	fa05 f303 	lsl.w	r3, r5, r3
  if ((int32_t)(IRQn) < 0)
  200b0a:	2800      	cmp	r0, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
  200b0c:	f103 33ff 	add.w	r3, r3, #4294967295
  200b10:	ea01 0103 	and.w	r1, r1, r3
  200b14:	fa01 f104 	lsl.w	r1, r1, r4
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
  200b18:	fa05 f404 	lsl.w	r4, r5, r4
  200b1c:	f104 34ff 	add.w	r4, r4, #4294967295
  200b20:	ea02 0204 	and.w	r2, r2, r4
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
  200b24:	ea42 0201 	orr.w	r2, r2, r1
  200b28:	ea4f 1202 	mov.w	r2, r2, lsl #4
  if ((int32_t)(IRQn) < 0)
  200b2c:	da05      	bge.n	200b3a <HAL_NVIC_SetPriority+0x56>
    SCB->SHPR[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  200b2e:	f000 000f 	and.w	r0, r0, #15
  200b32:	b2d2      	uxtb	r2, r2
  200b34:	4b06      	ldr	r3, [pc, #24]	; (200b50 <HAL_NVIC_SetPriority+0x6c>)
  200b36:	541a      	strb	r2, [r3, r0]
  200b38:	bd30      	pop	{r4, r5, pc}
    NVIC->IP[((uint32_t)(int32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  200b3a:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
  200b3e:	b2d2      	uxtb	r2, r2
  200b40:	f500 4061 	add.w	r0, r0, #57600	; 0xe100
  200b44:	f880 2300 	strb.w	r2, [r0, #768]	; 0x300
  200b48:	bd30      	pop	{r4, r5, pc}
  200b4a:	bf00      	nop
  200b4c:	e000ed00 	.word	0xe000ed00
  200b50:	e000ed14 	.word	0xe000ed14

00200b54 <HAL_NVIC_EnableIRQ>:
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
  200b54:	0942      	lsrs	r2, r0, #5
  200b56:	2301      	movs	r3, #1
  200b58:	f000 001f 	and.w	r0, r0, #31
  200b5c:	fa03 f000 	lsl.w	r0, r3, r0
  200b60:	4b01      	ldr	r3, [pc, #4]	; (200b68 <HAL_NVIC_EnableIRQ+0x14>)
  200b62:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
  200b66:	4770      	bx	lr
  200b68:	e000e100 	.word	0xe000e100

00200b6c <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
  200b6c:	3801      	subs	r0, #1
  200b6e:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
  200b72:	d20a      	bcs.n	200b8a <HAL_SYSTICK_Config+0x1e>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  200b74:	4b06      	ldr	r3, [pc, #24]	; (200b90 <HAL_SYSTICK_Config+0x24>)
    SCB->SHPR[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  200b76:	21f0      	movs	r1, #240	; 0xf0
  200b78:	4a06      	ldr	r2, [pc, #24]	; (200b94 <HAL_SYSTICK_Config+0x28>)
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  200b7a:	6058      	str	r0, [r3, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
  200b7c:	2000      	movs	r0, #0
    SCB->SHPR[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  200b7e:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
  200b82:	2207      	movs	r2, #7
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
  200b84:	6098      	str	r0, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
  200b86:	601a      	str	r2, [r3, #0]
  200b88:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
  200b8a:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
  200b8c:	4770      	bx	lr
  200b8e:	bf00      	nop
  200b90:	e000e010 	.word	0xe000e010
  200b94:	e000ed00 	.word	0xe000ed00

00200b98 <HAL_SYSTICK_CLKSourceConfig>:
  *             @arg SYSTICK_CLKSOURCE_HCLK_DIV8: AHB clock divided by 8 selected as SysTick clock source.
  *             @arg SYSTICK_CLKSOURCE_HCLK: AHB clock selected as SysTick clock source.
  * @retval None
  */
void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
{
  200b98:	4b04      	ldr	r3, [pc, #16]	; (200bac <HAL_SYSTICK_CLKSourceConfig+0x14>)
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
  200b9a:	2804      	cmp	r0, #4
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
  200b9c:	681a      	ldr	r2, [r3, #0]
  200b9e:	bf0c      	ite	eq
  200ba0:	f042 0204 	orreq.w	r2, r2, #4
  }
  else
  {
    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
  200ba4:	f022 0204 	bicne.w	r2, r2, #4
  200ba8:	601a      	str	r2, [r3, #0]
  200baa:	4770      	bx	lr
  200bac:	e000e010 	.word	0xe000e010

00200bb0 <HAL_SYSTICK_Callback>:
/**
  * @brief  SYSTICK callback.
  * @retval None
  */
__weak void HAL_SYSTICK_Callback(void)
{
  200bb0:	4770      	bx	lr

00200bb2 <HAL_SYSTICK_IRQHandler>:
{
  200bb2:	b508      	push	{r3, lr}
  HAL_SYSTICK_Callback();
  200bb4:	f7ff fffc 	bl	200bb0 <HAL_SYSTICK_Callback>
  200bb8:	bd08      	pop	{r3, pc}
	...

00200bbc <DMA_CalcBaseAndBitshift>:
  *                     the configuration information for the specified DMA Stream. 
  * @retval Stream base address
  */
static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
{
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
  200bbc:	6803      	ldr	r3, [r0, #0]
  200bbe:	2118      	movs	r1, #24
  200bc0:	b2da      	uxtb	r2, r3
  200bc2:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
  200bc6:	3a10      	subs	r2, #16
  200bc8:	f023 0303 	bic.w	r3, r3, #3
  200bcc:	fbb2 f2f1 	udiv	r2, r2, r1
  
  /* lookup table for necessary bitshift of flags within status registers */
  static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
  200bd0:	4904      	ldr	r1, [pc, #16]	; (200be4 <DMA_CalcBaseAndBitshift+0x28>)
  
  if (stream_number > 3U)
  200bd2:	2a03      	cmp	r2, #3
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
  200bd4:	5c89      	ldrb	r1, [r1, r2]
  {
    /* return pointer to HISR and HIFCR */
    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
  200bd6:	bf88      	it	hi
  200bd8:	3304      	addhi	r3, #4
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
  200bda:	65c1      	str	r1, [r0, #92]	; 0x5c
  }
  else
  {
    /* return pointer to LISR and LIFCR */
    hdma->StreamBaseAddress = ((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU));
  200bdc:	6583      	str	r3, [r0, #88]	; 0x58
  }
  
  return hdma->StreamBaseAddress;
}
  200bde:	6d80      	ldr	r0, [r0, #88]	; 0x58
  200be0:	4770      	bx	lr
  200be2:	bf00      	nop
  200be4:	002074ac 	.word	0x002074ac

00200be8 <HAL_DMA_Init>:
{
  200be8:	b570      	push	{r4, r5, r6, lr}
  200bea:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
  200bec:	f7ff ff54 	bl	200a98 <HAL_GetTick>
  200bf0:	4605      	mov	r5, r0
  if(hdma == NULL)
  200bf2:	2c00      	cmp	r4, #0
  200bf4:	d071      	beq.n	200cda <HAL_DMA_Init+0xf2>
  __HAL_UNLOCK(hdma);
  200bf6:	2300      	movs	r3, #0
  __HAL_DMA_DISABLE(hdma);
  200bf8:	6822      	ldr	r2, [r4, #0]
  __HAL_UNLOCK(hdma);
  200bfa:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
  hdma->State = HAL_DMA_STATE_BUSY;
  200bfe:	2302      	movs	r3, #2
  200c00:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
  __HAL_DMA_DISABLE(hdma);
  200c04:	6813      	ldr	r3, [r2, #0]
  200c06:	f023 0301 	bic.w	r3, r3, #1
  200c0a:	6013      	str	r3, [r2, #0]
  while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
  200c0c:	6821      	ldr	r1, [r4, #0]
  200c0e:	680b      	ldr	r3, [r1, #0]
  200c10:	07d8      	lsls	r0, r3, #31
  200c12:	d43c      	bmi.n	200c8e <HAL_DMA_Init+0xa6>
  tmp = hdma->Instance->CR;
  200c14:	680b      	ldr	r3, [r1, #0]
  tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
  200c16:	4d32      	ldr	r5, [pc, #200]	; (200ce0 <HAL_DMA_Init+0xf8>)
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
  200c18:	6862      	ldr	r2, [r4, #4]
  tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
  200c1a:	401d      	ands	r5, r3
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
  200c1c:	68a3      	ldr	r3, [r4, #8]
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
  200c1e:	69a0      	ldr	r0, [r4, #24]
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
  200c20:	4313      	orrs	r3, r2
  200c22:	68e2      	ldr	r2, [r4, #12]
  200c24:	4313      	orrs	r3, r2
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
  200c26:	6922      	ldr	r2, [r4, #16]
  200c28:	4313      	orrs	r3, r2
  200c2a:	6962      	ldr	r2, [r4, #20]
  200c2c:	4313      	orrs	r3, r2
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
  200c2e:	69e2      	ldr	r2, [r4, #28]
  200c30:	4303      	orrs	r3, r0
  200c32:	4313      	orrs	r3, r2
          hdma->Init.Mode                | hdma->Init.Priority;
  200c34:	6a22      	ldr	r2, [r4, #32]
  200c36:	4313      	orrs	r3, r2
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
  200c38:	6a62      	ldr	r2, [r4, #36]	; 0x24
  200c3a:	2a04      	cmp	r2, #4
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
  200c3c:	ea43 0305 	orr.w	r3, r3, r5
    tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
  200c40:	bf01      	itttt	eq
  200c42:	6b26      	ldreq	r6, [r4, #48]	; 0x30
  200c44:	6ae5      	ldreq	r5, [r4, #44]	; 0x2c
  200c46:	4335      	orreq	r5, r6
  200c48:	432b      	orreq	r3, r5
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
  200c4a:	2a04      	cmp	r2, #4
  hdma->Instance->CR = tmp;  
  200c4c:	600b      	str	r3, [r1, #0]
  tmp = hdma->Instance->FCR;
  200c4e:	694b      	ldr	r3, [r1, #20]
  tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
  200c50:	f023 0307 	bic.w	r3, r3, #7
  tmp |= hdma->Init.FIFOMode;
  200c54:	ea43 0302 	orr.w	r3, r3, r2
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
  200c58:	d10b      	bne.n	200c72 <HAL_DMA_Init+0x8a>
    tmp |= hdma->Init.FIFOThreshold;
  200c5a:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    if (hdma->Init.MemBurst != DMA_MBURST_SINGLE)
  200c5c:	6ae5      	ldr	r5, [r4, #44]	; 0x2c
    tmp |= hdma->Init.FIFOThreshold;
  200c5e:	4313      	orrs	r3, r2
    if (hdma->Init.MemBurst != DMA_MBURST_SINGLE)
  200c60:	b13d      	cbz	r5, 200c72 <HAL_DMA_Init+0x8a>
{
  HAL_StatusTypeDef status = HAL_OK;
  uint32_t tmp = hdma->Init.FIFOThreshold;
  
  /* Memory Data size equal to Byte */
  if(hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)
  200c62:	b9f8      	cbnz	r0, 200ca4 <HAL_DMA_Init+0xbc>
  {
    switch (tmp)
  200c64:	2a01      	cmp	r2, #1
  200c66:	d02d      	beq.n	200cc4 <HAL_DMA_Init+0xdc>
  200c68:	d301      	bcc.n	200c6e <HAL_DMA_Init+0x86>
  200c6a:	2a02      	cmp	r2, #2
  }
  
  /* Memory Data size equal to Word */
  else
  {
    switch (tmp)
  200c6c:	d101      	bne.n	200c72 <HAL_DMA_Init+0x8a>
    case DMA_FIFO_THRESHOLD_HALFFULL:
    case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
      status = HAL_ERROR;
      break;
    case DMA_FIFO_THRESHOLD_FULL:
      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
  200c6e:	01ea      	lsls	r2, r5, #7
  200c70:	d42b      	bmi.n	200cca <HAL_DMA_Init+0xe2>
  hdma->Instance->FCR = tmp;
  200c72:	614b      	str	r3, [r1, #20]
  regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
  200c74:	4620      	mov	r0, r4
  200c76:	f7ff ffa1 	bl	200bbc <DMA_CalcBaseAndBitshift>
  regs->IFCR = 0x3FU << hdma->StreamIndex;
  200c7a:	6de2      	ldr	r2, [r4, #92]	; 0x5c
  200c7c:	233f      	movs	r3, #63	; 0x3f
  200c7e:	4093      	lsls	r3, r2
  200c80:	6083      	str	r3, [r0, #8]
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
  200c82:	2000      	movs	r0, #0
  hdma->State = HAL_DMA_STATE_READY;
  200c84:	2301      	movs	r3, #1
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
  200c86:	6560      	str	r0, [r4, #84]	; 0x54
  hdma->State = HAL_DMA_STATE_READY;
  200c88:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
  return HAL_OK;
  200c8c:	bd70      	pop	{r4, r5, r6, pc}
    if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
  200c8e:	f7ff ff03 	bl	200a98 <HAL_GetTick>
  200c92:	1b40      	subs	r0, r0, r5
  200c94:	2805      	cmp	r0, #5
  200c96:	d9b9      	bls.n	200c0c <HAL_DMA_Init+0x24>
      hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
  200c98:	2320      	movs	r3, #32
      hdma->State = HAL_DMA_STATE_TIMEOUT;
  200c9a:	2003      	movs	r0, #3
      hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
  200c9c:	6563      	str	r3, [r4, #84]	; 0x54
        hdma->State = HAL_DMA_STATE_READY;
  200c9e:	f884 0035 	strb.w	r0, [r4, #53]	; 0x35
}
  200ca2:	bd70      	pop	{r4, r5, r6, pc}
  else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
  200ca4:	f5b0 5f00 	cmp.w	r0, #8192	; 0x2000
  200ca8:	d113      	bne.n	200cd2 <HAL_DMA_Init+0xea>
    switch (tmp)
  200caa:	2a03      	cmp	r2, #3
  200cac:	d8e1      	bhi.n	200c72 <HAL_DMA_Init+0x8a>
  200cae:	a001      	add	r0, pc, #4	; (adr r0, 200cb4 <HAL_DMA_Init+0xcc>)
  200cb0:	f850 f022 	ldr.w	pc, [r0, r2, lsl #2]
  200cb4:	00200ccb 	.word	0x00200ccb
  200cb8:	00200c6f 	.word	0x00200c6f
  200cbc:	00200ccb 	.word	0x00200ccb
  200cc0:	00200cc5 	.word	0x00200cc5
      if (hdma->Init.MemBurst == DMA_MBURST_INC16)
  200cc4:	f1b5 7fc0 	cmp.w	r5, #25165824	; 0x1800000
  200cc8:	d1d3      	bne.n	200c72 <HAL_DMA_Init+0x8a>
        hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
  200cca:	2340      	movs	r3, #64	; 0x40
        hdma->State = HAL_DMA_STATE_READY;
  200ccc:	2001      	movs	r0, #1
        hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
  200cce:	6563      	str	r3, [r4, #84]	; 0x54
  200cd0:	e7e5      	b.n	200c9e <HAL_DMA_Init+0xb6>
    switch (tmp)
  200cd2:	2a02      	cmp	r2, #2
  200cd4:	d9f9      	bls.n	200cca <HAL_DMA_Init+0xe2>
  200cd6:	2a03      	cmp	r2, #3
  200cd8:	e7c8      	b.n	200c6c <HAL_DMA_Init+0x84>
    return HAL_ERROR;
  200cda:	2001      	movs	r0, #1
  200cdc:	bd70      	pop	{r4, r5, r6, pc}
  200cde:	bf00      	nop
  200ce0:	f010803f 	.word	0xf010803f

00200ce4 <HAL_DMA_Start_IT>:
{
  200ce4:	b570      	push	{r4, r5, r6, lr}
  __HAL_LOCK(hdma);
  200ce6:	f890 4034 	ldrb.w	r4, [r0, #52]	; 0x34
  200cea:	2c01      	cmp	r4, #1
  200cec:	d035      	beq.n	200d5a <HAL_DMA_Start_IT+0x76>
  200cee:	2401      	movs	r4, #1
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
  200cf0:	6d86      	ldr	r6, [r0, #88]	; 0x58
  200cf2:	2500      	movs	r5, #0
  __HAL_LOCK(hdma);
  200cf4:	f880 4034 	strb.w	r4, [r0, #52]	; 0x34
  if(HAL_DMA_STATE_READY == hdma->State)
  200cf8:	f890 4035 	ldrb.w	r4, [r0, #53]	; 0x35
  200cfc:	2c01      	cmp	r4, #1
  200cfe:	f04f 0402 	mov.w	r4, #2
  200d02:	d128      	bne.n	200d56 <HAL_DMA_Start_IT+0x72>
    hdma->State = HAL_DMA_STATE_BUSY;
  200d04:	f880 4035 	strb.w	r4, [r0, #53]	; 0x35
  hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);
  200d08:	6804      	ldr	r4, [r0, #0]
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
  200d0a:	6545      	str	r5, [r0, #84]	; 0x54
  hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);
  200d0c:	6825      	ldr	r5, [r4, #0]
  200d0e:	f425 2580 	bic.w	r5, r5, #262144	; 0x40000
  200d12:	6025      	str	r5, [r4, #0]
  hdma->Instance->NDTR = DataLength;
  200d14:	6063      	str	r3, [r4, #4]
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
  200d16:	6883      	ldr	r3, [r0, #8]
  200d18:	2b40      	cmp	r3, #64	; 0x40
  200d1a:	d119      	bne.n	200d50 <HAL_DMA_Start_IT+0x6c>
    hdma->Instance->PAR = DstAddress;
  200d1c:	60a2      	str	r2, [r4, #8]
    hdma->Instance->M0AR = SrcAddress;
  200d1e:	60e1      	str	r1, [r4, #12]
    regs->IFCR = 0x3FU << hdma->StreamIndex;
  200d20:	6dc2      	ldr	r2, [r0, #92]	; 0x5c
  200d22:	233f      	movs	r3, #63	; 0x3f
  200d24:	4093      	lsls	r3, r2
  200d26:	60b3      	str	r3, [r6, #8]
    hdma->Instance->CR  |= DMA_IT_TC | DMA_IT_TE | DMA_IT_DME;
  200d28:	6823      	ldr	r3, [r4, #0]
  200d2a:	f043 0316 	orr.w	r3, r3, #22
  200d2e:	6023      	str	r3, [r4, #0]
    hdma->Instance->FCR |= DMA_IT_FE;
  200d30:	6963      	ldr	r3, [r4, #20]
  200d32:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  200d36:	6163      	str	r3, [r4, #20]
    if(hdma->XferHalfCpltCallback != NULL)
  200d38:	6c03      	ldr	r3, [r0, #64]	; 0x40
  200d3a:	b11b      	cbz	r3, 200d44 <HAL_DMA_Start_IT+0x60>
      hdma->Instance->CR  |= DMA_IT_HT;
  200d3c:	6823      	ldr	r3, [r4, #0]
  200d3e:	f043 0308 	orr.w	r3, r3, #8
  200d42:	6023      	str	r3, [r4, #0]
    __HAL_DMA_ENABLE(hdma);
  200d44:	6823      	ldr	r3, [r4, #0]
  HAL_StatusTypeDef status = HAL_OK;
  200d46:	2000      	movs	r0, #0
    __HAL_DMA_ENABLE(hdma);
  200d48:	f043 0301 	orr.w	r3, r3, #1
  200d4c:	6023      	str	r3, [r4, #0]
  200d4e:	bd70      	pop	{r4, r5, r6, pc}
    hdma->Instance->PAR = SrcAddress;
  200d50:	60a1      	str	r1, [r4, #8]
    hdma->Instance->M0AR = DstAddress;
  200d52:	60e2      	str	r2, [r4, #12]
  200d54:	e7e4      	b.n	200d20 <HAL_DMA_Start_IT+0x3c>
    __HAL_UNLOCK(hdma);	  
  200d56:	f880 5034 	strb.w	r5, [r0, #52]	; 0x34
  __HAL_LOCK(hdma);
  200d5a:	2002      	movs	r0, #2
}
  200d5c:	bd70      	pop	{r4, r5, r6, pc}

00200d5e <HAL_DMA_Abort_IT>:
  if(hdma->State != HAL_DMA_STATE_BUSY)
  200d5e:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
  200d62:	2b02      	cmp	r3, #2
  200d64:	d003      	beq.n	200d6e <HAL_DMA_Abort_IT+0x10>
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
  200d66:	2380      	movs	r3, #128	; 0x80
  200d68:	6543      	str	r3, [r0, #84]	; 0x54
    return HAL_ERROR;
  200d6a:	2001      	movs	r0, #1
  200d6c:	4770      	bx	lr
    __HAL_DMA_DISABLE(hdma);
  200d6e:	6802      	ldr	r2, [r0, #0]
    hdma->State = HAL_DMA_STATE_ABORT;
  200d70:	2305      	movs	r3, #5
  200d72:	f880 3035 	strb.w	r3, [r0, #53]	; 0x35
  return HAL_OK;
  200d76:	2000      	movs	r0, #0
    __HAL_DMA_DISABLE(hdma);
  200d78:	6813      	ldr	r3, [r2, #0]
  200d7a:	f023 0301 	bic.w	r3, r3, #1
  200d7e:	6013      	str	r3, [r2, #0]
}
  200d80:	4770      	bx	lr
	...

00200d84 <HAL_DMA_IRQHandler>:
  __IO uint32_t count = 0;
  200d84:	2300      	movs	r3, #0
{
  200d86:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  __IO uint32_t count = 0;
  200d88:	9301      	str	r3, [sp, #4]
  if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
  200d8a:	2208      	movs	r2, #8
  uint32_t timeout = SystemCoreClock / 9600;
  200d8c:	4b59      	ldr	r3, [pc, #356]	; (200ef4 <HAL_DMA_IRQHandler+0x170>)
{
  200d8e:	4604      	mov	r4, r0
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
  200d90:	6d85      	ldr	r5, [r0, #88]	; 0x58
  uint32_t timeout = SystemCoreClock / 9600;
  200d92:	681f      	ldr	r7, [r3, #0]
  if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
  200d94:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
  tmpisr = regs->ISR;
  200d96:	682e      	ldr	r6, [r5, #0]
  if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
  200d98:	409a      	lsls	r2, r3
  200d9a:	4216      	tst	r6, r2
  200d9c:	d00c      	beq.n	200db8 <HAL_DMA_IRQHandler+0x34>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
  200d9e:	6801      	ldr	r1, [r0, #0]
  200da0:	6808      	ldr	r0, [r1, #0]
  200da2:	0740      	lsls	r0, r0, #29
  200da4:	d508      	bpl.n	200db8 <HAL_DMA_IRQHandler+0x34>
      hdma->Instance->CR  &= ~(DMA_IT_TE);
  200da6:	6808      	ldr	r0, [r1, #0]
  200da8:	f020 0004 	bic.w	r0, r0, #4
  200dac:	6008      	str	r0, [r1, #0]
      regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;
  200dae:	60aa      	str	r2, [r5, #8]
      hdma->ErrorCode |= HAL_DMA_ERROR_TE;
  200db0:	6d62      	ldr	r2, [r4, #84]	; 0x54
  200db2:	f042 0201 	orr.w	r2, r2, #1
  200db6:	6562      	str	r2, [r4, #84]	; 0x54
  if ((tmpisr & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex)) != RESET)
  200db8:	4a4f      	ldr	r2, [pc, #316]	; (200ef8 <HAL_DMA_IRQHandler+0x174>)
  200dba:	409a      	lsls	r2, r3
  200dbc:	4216      	tst	r6, r2
  200dbe:	d008      	beq.n	200dd2 <HAL_DMA_IRQHandler+0x4e>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != RESET)
  200dc0:	6821      	ldr	r1, [r4, #0]
  200dc2:	6949      	ldr	r1, [r1, #20]
  200dc4:	0609      	lsls	r1, r1, #24
  200dc6:	d504      	bpl.n	200dd2 <HAL_DMA_IRQHandler+0x4e>
      regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;
  200dc8:	60aa      	str	r2, [r5, #8]
      hdma->ErrorCode |= HAL_DMA_ERROR_FE;
  200dca:	6d62      	ldr	r2, [r4, #84]	; 0x54
  200dcc:	f042 0202 	orr.w	r2, r2, #2
  200dd0:	6562      	str	r2, [r4, #84]	; 0x54
  if ((tmpisr & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex)) != RESET)
  200dd2:	4a4a      	ldr	r2, [pc, #296]	; (200efc <HAL_DMA_IRQHandler+0x178>)
  200dd4:	409a      	lsls	r2, r3
  200dd6:	4216      	tst	r6, r2
  200dd8:	d008      	beq.n	200dec <HAL_DMA_IRQHandler+0x68>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != RESET)
  200dda:	6821      	ldr	r1, [r4, #0]
  200ddc:	6809      	ldr	r1, [r1, #0]
  200dde:	0788      	lsls	r0, r1, #30
  200de0:	d504      	bpl.n	200dec <HAL_DMA_IRQHandler+0x68>
      regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;
  200de2:	60aa      	str	r2, [r5, #8]
      hdma->ErrorCode |= HAL_DMA_ERROR_DME;
  200de4:	6d62      	ldr	r2, [r4, #84]	; 0x54
  200de6:	f042 0204 	orr.w	r2, r2, #4
  200dea:	6562      	str	r2, [r4, #84]	; 0x54
  if ((tmpisr & (DMA_FLAG_HTIF0_4 << hdma->StreamIndex)) != RESET)
  200dec:	2210      	movs	r2, #16
  200dee:	409a      	lsls	r2, r3
  200df0:	4216      	tst	r6, r2
  200df2:	d010      	beq.n	200e16 <HAL_DMA_IRQHandler+0x92>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET)
  200df4:	6823      	ldr	r3, [r4, #0]
  200df6:	6819      	ldr	r1, [r3, #0]
  200df8:	0709      	lsls	r1, r1, #28
  200dfa:	d50c      	bpl.n	200e16 <HAL_DMA_IRQHandler+0x92>
      regs->IFCR = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
  200dfc:	60aa      	str	r2, [r5, #8]
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
  200dfe:	681a      	ldr	r2, [r3, #0]
  200e00:	0350      	lsls	r0, r2, #13
  200e02:	d535      	bpl.n	200e70 <HAL_DMA_IRQHandler+0xec>
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
  200e04:	681b      	ldr	r3, [r3, #0]
  200e06:	0319      	lsls	r1, r3, #12
  200e08:	d401      	bmi.n	200e0e <HAL_DMA_IRQHandler+0x8a>
        if(hdma->XferHalfCpltCallback != NULL)
  200e0a:	6c23      	ldr	r3, [r4, #64]	; 0x40
  200e0c:	e000      	b.n	200e10 <HAL_DMA_IRQHandler+0x8c>
          if(hdma->XferM1HalfCpltCallback != NULL)
  200e0e:	6ca3      	ldr	r3, [r4, #72]	; 0x48
        if(hdma->XferHalfCpltCallback != NULL)
  200e10:	b10b      	cbz	r3, 200e16 <HAL_DMA_IRQHandler+0x92>
          hdma->XferHalfCpltCallback(hdma);
  200e12:	4620      	mov	r0, r4
  200e14:	4798      	blx	r3
  if ((tmpisr & (DMA_FLAG_TCIF0_4 << hdma->StreamIndex)) != RESET)
  200e16:	6de1      	ldr	r1, [r4, #92]	; 0x5c
  200e18:	2220      	movs	r2, #32
  200e1a:	408a      	lsls	r2, r1
  200e1c:	4216      	tst	r6, r2
  200e1e:	d038      	beq.n	200e92 <HAL_DMA_IRQHandler+0x10e>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != RESET)
  200e20:	6823      	ldr	r3, [r4, #0]
  200e22:	6818      	ldr	r0, [r3, #0]
  200e24:	06c6      	lsls	r6, r0, #27
  200e26:	d534      	bpl.n	200e92 <HAL_DMA_IRQHandler+0x10e>
      regs->IFCR = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
  200e28:	60aa      	str	r2, [r5, #8]
      if(HAL_DMA_STATE_ABORT == hdma->State)
  200e2a:	f894 2035 	ldrb.w	r2, [r4, #53]	; 0x35
  200e2e:	2a05      	cmp	r2, #5
        hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
  200e30:	681a      	ldr	r2, [r3, #0]
      if(HAL_DMA_STATE_ABORT == hdma->State)
  200e32:	d125      	bne.n	200e80 <HAL_DMA_IRQHandler+0xfc>
        hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
  200e34:	f022 0216 	bic.w	r2, r2, #22
  200e38:	601a      	str	r2, [r3, #0]
        hdma->Instance->FCR &= ~(DMA_IT_FE);
  200e3a:	695a      	ldr	r2, [r3, #20]
  200e3c:	f022 0280 	bic.w	r2, r2, #128	; 0x80
  200e40:	615a      	str	r2, [r3, #20]
        if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
  200e42:	6c22      	ldr	r2, [r4, #64]	; 0x40
  200e44:	b90a      	cbnz	r2, 200e4a <HAL_DMA_IRQHandler+0xc6>
  200e46:	6ca2      	ldr	r2, [r4, #72]	; 0x48
  200e48:	b11a      	cbz	r2, 200e52 <HAL_DMA_IRQHandler+0xce>
          hdma->Instance->CR  &= ~(DMA_IT_HT);
  200e4a:	681a      	ldr	r2, [r3, #0]
  200e4c:	f022 0208 	bic.w	r2, r2, #8
  200e50:	601a      	str	r2, [r3, #0]
        regs->IFCR = 0x3FU << hdma->StreamIndex;
  200e52:	233f      	movs	r3, #63	; 0x3f
  200e54:	408b      	lsls	r3, r1
  200e56:	60ab      	str	r3, [r5, #8]
        __HAL_UNLOCK(hdma);
  200e58:	2300      	movs	r3, #0
  200e5a:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
        hdma->State = HAL_DMA_STATE_READY;
  200e5e:	2301      	movs	r3, #1
  200e60:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
        if(hdma->XferAbortCallback != NULL)
  200e64:	6d23      	ldr	r3, [r4, #80]	; 0x50
    if(hdma->XferErrorCallback != NULL)
  200e66:	b10b      	cbz	r3, 200e6c <HAL_DMA_IRQHandler+0xe8>
      hdma->XferErrorCallback(hdma);
  200e68:	4620      	mov	r0, r4
  200e6a:	4798      	blx	r3
}
  200e6c:	b003      	add	sp, #12
  200e6e:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
  200e70:	681a      	ldr	r2, [r3, #0]
  200e72:	05d2      	lsls	r2, r2, #23
  200e74:	d4c9      	bmi.n	200e0a <HAL_DMA_IRQHandler+0x86>
          hdma->Instance->CR  &= ~(DMA_IT_HT);
  200e76:	681a      	ldr	r2, [r3, #0]
  200e78:	f022 0208 	bic.w	r2, r2, #8
  200e7c:	601a      	str	r2, [r3, #0]
  200e7e:	e7c4      	b.n	200e0a <HAL_DMA_IRQHandler+0x86>
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
  200e80:	0350      	lsls	r0, r2, #13
  200e82:	d528      	bpl.n	200ed6 <HAL_DMA_IRQHandler+0x152>
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
  200e84:	681b      	ldr	r3, [r3, #0]
  200e86:	0319      	lsls	r1, r3, #12
  200e88:	d432      	bmi.n	200ef0 <HAL_DMA_IRQHandler+0x16c>
          if(hdma->XferM1CpltCallback != NULL)
  200e8a:	6c63      	ldr	r3, [r4, #68]	; 0x44
        if(hdma->XferCpltCallback != NULL)
  200e8c:	b10b      	cbz	r3, 200e92 <HAL_DMA_IRQHandler+0x10e>
          hdma->XferCpltCallback(hdma);
  200e8e:	4620      	mov	r0, r4
  200e90:	4798      	blx	r3
  if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
  200e92:	6d63      	ldr	r3, [r4, #84]	; 0x54
  200e94:	2b00      	cmp	r3, #0
  200e96:	d0e9      	beq.n	200e6c <HAL_DMA_IRQHandler+0xe8>
    if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != RESET)
  200e98:	6d63      	ldr	r3, [r4, #84]	; 0x54
  200e9a:	07da      	lsls	r2, r3, #31
  200e9c:	d519      	bpl.n	200ed2 <HAL_DMA_IRQHandler+0x14e>
      hdma->State = HAL_DMA_STATE_ABORT;
  200e9e:	2305      	movs	r3, #5
      __HAL_DMA_DISABLE(hdma);
  200ea0:	6822      	ldr	r2, [r4, #0]
      hdma->State = HAL_DMA_STATE_ABORT;
  200ea2:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
      __HAL_DMA_DISABLE(hdma);
  200ea6:	6813      	ldr	r3, [r2, #0]
  200ea8:	f023 0301 	bic.w	r3, r3, #1
  200eac:	6013      	str	r3, [r2, #0]
  uint32_t timeout = SystemCoreClock / 9600;
  200eae:	f44f 5316 	mov.w	r3, #9600	; 0x2580
  200eb2:	fbb7 f7f3 	udiv	r7, r7, r3
        if (++count > timeout)
  200eb6:	9b01      	ldr	r3, [sp, #4]
  200eb8:	3301      	adds	r3, #1
  200eba:	429f      	cmp	r7, r3
  200ebc:	9301      	str	r3, [sp, #4]
  200ebe:	d302      	bcc.n	200ec6 <HAL_DMA_IRQHandler+0x142>
      while((hdma->Instance->CR & DMA_SxCR_EN) != RESET);
  200ec0:	6813      	ldr	r3, [r2, #0]
  200ec2:	07db      	lsls	r3, r3, #31
  200ec4:	d4f7      	bmi.n	200eb6 <HAL_DMA_IRQHandler+0x132>
      __HAL_UNLOCK(hdma);
  200ec6:	2300      	movs	r3, #0
  200ec8:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
      hdma->State = HAL_DMA_STATE_READY;
  200ecc:	2301      	movs	r3, #1
  200ece:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
    if(hdma->XferErrorCallback != NULL)
  200ed2:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
  200ed4:	e7c7      	b.n	200e66 <HAL_DMA_IRQHandler+0xe2>
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
  200ed6:	681a      	ldr	r2, [r3, #0]
  200ed8:	f412 7280 	ands.w	r2, r2, #256	; 0x100
  200edc:	d108      	bne.n	200ef0 <HAL_DMA_IRQHandler+0x16c>
          hdma->Instance->CR  &= ~(DMA_IT_TC);
  200ede:	6819      	ldr	r1, [r3, #0]
  200ee0:	f021 0110 	bic.w	r1, r1, #16
  200ee4:	6019      	str	r1, [r3, #0]
          hdma->State = HAL_DMA_STATE_READY;
  200ee6:	2301      	movs	r3, #1
          __HAL_UNLOCK(hdma);
  200ee8:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
          hdma->State = HAL_DMA_STATE_READY;
  200eec:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
        if(hdma->XferCpltCallback != NULL)
  200ef0:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  200ef2:	e7cb      	b.n	200e8c <HAL_DMA_IRQHandler+0x108>
  200ef4:	20000014 	.word	0x20000014
  200ef8:	00800001 	.word	0x00800001
  200efc:	00800004 	.word	0x00800004

00200f00 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
  200f00:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  for(position = 0; position < GPIO_NUMBER; position++)
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01) << position;
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
  200f04:	680b      	ldr	r3, [r1, #0]
{
  200f06:	b085      	sub	sp, #20
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
  200f08:	f8df 81c0 	ldr.w	r8, [pc, #448]	; 2010cc <HAL_GPIO_Init+0x1cc>
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
  200f0c:	9301      	str	r3, [sp, #4]
  for(position = 0; position < GPIO_NUMBER; position++)
  200f0e:	2300      	movs	r3, #0
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
        SYSCFG->EXTICR[position >> 2] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
  200f10:	4a6c      	ldr	r2, [pc, #432]	; (2010c4 <HAL_GPIO_Init+0x1c4>)
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
  200f12:	f8df 91bc 	ldr.w	r9, [pc, #444]	; 2010d0 <HAL_GPIO_Init+0x1d0>
    ioposition = ((uint32_t)0x01) << position;
  200f16:	f04f 0e01 	mov.w	lr, #1
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
  200f1a:	9c01      	ldr	r4, [sp, #4]
    ioposition = ((uint32_t)0x01) << position;
  200f1c:	fa0e fe03 	lsl.w	lr, lr, r3
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
  200f20:	ea0e 0604 	and.w	r6, lr, r4
    if(iocurrent == ioposition)
  200f24:	45b6      	cmp	lr, r6
  200f26:	f040 80b3 	bne.w	201090 <HAL_GPIO_Init+0x190>
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
  200f2a:	684c      	ldr	r4, [r1, #4]
  200f2c:	f024 0710 	bic.w	r7, r4, #16
  200f30:	2f02      	cmp	r7, #2
  200f32:	d116      	bne.n	200f62 <HAL_GPIO_Init+0x62>
        temp = GPIOx->AFR[position >> 3];
  200f34:	ea4f 0ad3 	mov.w	sl, r3, lsr #3
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
  200f38:	f003 0b07 	and.w	fp, r3, #7
  200f3c:	f04f 0c0f 	mov.w	ip, #15
  200f40:	eb00 0a8a 	add.w	sl, r0, sl, lsl #2
  200f44:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
        temp = GPIOx->AFR[position >> 3];
  200f48:	f8da 5020 	ldr.w	r5, [sl, #32]
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
  200f4c:	fa0c fc0b 	lsl.w	ip, ip, fp
  200f50:	ea25 0c0c 	bic.w	ip, r5, ip
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
  200f54:	690d      	ldr	r5, [r1, #16]
  200f56:	fa05 f50b 	lsl.w	r5, r5, fp
  200f5a:	ea45 050c 	orr.w	r5, r5, ip
        GPIOx->AFR[position >> 3] = temp;
  200f5e:	f8ca 5020 	str.w	r5, [sl, #32]
  200f62:	ea4f 0a43 	mov.w	sl, r3, lsl #1
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
  200f66:	2503      	movs	r5, #3
      temp = GPIOx->MODER;
  200f68:	f8d0 b000 	ldr.w	fp, [r0]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
  200f6c:	f004 0c03 	and.w	ip, r4, #3
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
  200f70:	fa05 f50a 	lsl.w	r5, r5, sl
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
  200f74:	3f01      	subs	r7, #1
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
  200f76:	fa0c fc0a 	lsl.w	ip, ip, sl
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
  200f7a:	43ed      	mvns	r5, r5
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
  200f7c:	2f01      	cmp	r7, #1
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
  200f7e:	ea0b 0b05 	and.w	fp, fp, r5
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
  200f82:	ea4c 0c0b 	orr.w	ip, ip, fp
      GPIOx->MODER = temp;
  200f86:	f8c0 c000 	str.w	ip, [r0]
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
  200f8a:	d811      	bhi.n	200fb0 <HAL_GPIO_Init+0xb0>
        temp = GPIOx->OSPEEDR; 
  200f8c:	6887      	ldr	r7, [r0, #8]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
  200f8e:	ea07 0b05 	and.w	fp, r7, r5
        temp |= (GPIO_Init->Speed << (position * 2));
  200f92:	68cf      	ldr	r7, [r1, #12]
  200f94:	fa07 fc0a 	lsl.w	ip, r7, sl
  200f98:	ea4c 070b 	orr.w	r7, ip, fp
        GPIOx->OSPEEDR = temp;
  200f9c:	6087      	str	r7, [r0, #8]
        temp = GPIOx->OTYPER;
  200f9e:	6847      	ldr	r7, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
  200fa0:	ea27 0e0e 	bic.w	lr, r7, lr
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
  200fa4:	f3c4 1700 	ubfx	r7, r4, #4, #1
  200fa8:	409f      	lsls	r7, r3
  200faa:	ea47 070e 	orr.w	r7, r7, lr
        GPIOx->OTYPER = temp;
  200fae:	6047      	str	r7, [r0, #4]
      temp = GPIOx->PUPDR;
  200fb0:	68c7      	ldr	r7, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
  200fb2:	403d      	ands	r5, r7
      temp |= ((GPIO_Init->Pull) << (position * 2));
  200fb4:	688f      	ldr	r7, [r1, #8]
  200fb6:	fa07 f70a 	lsl.w	r7, r7, sl
  200fba:	433d      	orrs	r5, r7
      GPIOx->PUPDR = temp;
  200fbc:	60c5      	str	r5, [r0, #12]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
  200fbe:	00e5      	lsls	r5, r4, #3
  200fc0:	d566      	bpl.n	201090 <HAL_GPIO_Init+0x190>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
  200fc2:	f8d8 5044 	ldr.w	r5, [r8, #68]	; 0x44
  200fc6:	f023 0703 	bic.w	r7, r3, #3
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
  200fca:	f003 0e03 	and.w	lr, r3, #3
  200fce:	f04f 0c0f 	mov.w	ip, #15
        __HAL_RCC_SYSCFG_CLK_ENABLE();
  200fd2:	f445 4580 	orr.w	r5, r5, #16384	; 0x4000
  200fd6:	f107 4780 	add.w	r7, r7, #1073741824	; 0x40000000
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
  200fda:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
        __HAL_RCC_SYSCFG_CLK_ENABLE();
  200fde:	f8c8 5044 	str.w	r5, [r8, #68]	; 0x44
  200fe2:	f507 379c 	add.w	r7, r7, #79872	; 0x13800
  200fe6:	f8d8 5044 	ldr.w	r5, [r8, #68]	; 0x44
  200fea:	f405 4580 	and.w	r5, r5, #16384	; 0x4000
  200fee:	9503      	str	r5, [sp, #12]
  200ff0:	9d03      	ldr	r5, [sp, #12]
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
  200ff2:	fa0c f50e 	lsl.w	r5, ip, lr
        temp = SYSCFG->EXTICR[position >> 2];
  200ff6:	f8d7 a008 	ldr.w	sl, [r7, #8]
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
  200ffa:	ea2a 0c05 	bic.w	ip, sl, r5
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
  200ffe:	4d32      	ldr	r5, [pc, #200]	; (2010c8 <HAL_GPIO_Init+0x1c8>)
  201000:	42a8      	cmp	r0, r5
  201002:	d04c      	beq.n	20109e <HAL_GPIO_Init+0x19e>
  201004:	f505 6580 	add.w	r5, r5, #1024	; 0x400
  201008:	42a8      	cmp	r0, r5
  20100a:	d04a      	beq.n	2010a2 <HAL_GPIO_Init+0x1a2>
  20100c:	f505 6580 	add.w	r5, r5, #1024	; 0x400
  201010:	42a8      	cmp	r0, r5
  201012:	d048      	beq.n	2010a6 <HAL_GPIO_Init+0x1a6>
  201014:	f505 6580 	add.w	r5, r5, #1024	; 0x400
  201018:	42a8      	cmp	r0, r5
  20101a:	d046      	beq.n	2010aa <HAL_GPIO_Init+0x1aa>
  20101c:	f505 6580 	add.w	r5, r5, #1024	; 0x400
  201020:	42a8      	cmp	r0, r5
  201022:	d044      	beq.n	2010ae <HAL_GPIO_Init+0x1ae>
  201024:	4548      	cmp	r0, r9
  201026:	d044      	beq.n	2010b2 <HAL_GPIO_Init+0x1b2>
  201028:	f505 6500 	add.w	r5, r5, #2048	; 0x800
  20102c:	42a8      	cmp	r0, r5
  20102e:	d042      	beq.n	2010b6 <HAL_GPIO_Init+0x1b6>
  201030:	f505 6580 	add.w	r5, r5, #1024	; 0x400
  201034:	42a8      	cmp	r0, r5
  201036:	d040      	beq.n	2010ba <HAL_GPIO_Init+0x1ba>
  201038:	f505 6580 	add.w	r5, r5, #1024	; 0x400
  20103c:	42a8      	cmp	r0, r5
  20103e:	d03e      	beq.n	2010be <HAL_GPIO_Init+0x1be>
  201040:	f505 6580 	add.w	r5, r5, #1024	; 0x400
  201044:	42a8      	cmp	r0, r5
  201046:	bf14      	ite	ne
  201048:	250a      	movne	r5, #10
  20104a:	2509      	moveq	r5, #9
  20104c:	fa05 f50e 	lsl.w	r5, r5, lr
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
  201050:	f414 3f80 	tst.w	r4, #65536	; 0x10000
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
  201054:	ea45 050c 	orr.w	r5, r5, ip
        SYSCFG->EXTICR[position >> 2] = temp;
  201058:	60bd      	str	r5, [r7, #8]
        temp &= ~((uint32_t)iocurrent);
  20105a:	ea6f 0706 	mvn.w	r7, r6
        temp = EXTI->IMR;
  20105e:	6815      	ldr	r5, [r2, #0]
        temp &= ~((uint32_t)iocurrent);
  201060:	bf0c      	ite	eq
  201062:	403d      	andeq	r5, r7
        {
          temp |= iocurrent;
  201064:	4335      	orrne	r5, r6
        }
        EXTI->IMR = temp;

        temp = EXTI->EMR;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
  201066:	f414 3f00 	tst.w	r4, #131072	; 0x20000
        EXTI->IMR = temp;
  20106a:	6015      	str	r5, [r2, #0]
        temp = EXTI->EMR;
  20106c:	6855      	ldr	r5, [r2, #4]
        temp &= ~((uint32_t)iocurrent);
  20106e:	bf0c      	ite	eq
  201070:	403d      	andeq	r5, r7
        {
          temp |= iocurrent;
  201072:	4335      	orrne	r5, r6
        EXTI->EMR = temp;

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
  201074:	f414 1f80 	tst.w	r4, #1048576	; 0x100000
        EXTI->EMR = temp;
  201078:	6055      	str	r5, [r2, #4]
        temp = EXTI->RTSR;
  20107a:	6895      	ldr	r5, [r2, #8]
        temp &= ~((uint32_t)iocurrent);
  20107c:	bf0c      	ite	eq
  20107e:	403d      	andeq	r5, r7
        {
          temp |= iocurrent;
  201080:	4335      	orrne	r5, r6
        }
        EXTI->RTSR = temp;

        temp = EXTI->FTSR;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
  201082:	02a4      	lsls	r4, r4, #10
        EXTI->RTSR = temp;
  201084:	6095      	str	r5, [r2, #8]
        temp = EXTI->FTSR;
  201086:	68d5      	ldr	r5, [r2, #12]
        temp &= ~((uint32_t)iocurrent);
  201088:	bf54      	ite	pl
  20108a:	403d      	andpl	r5, r7
        {
          temp |= iocurrent;
  20108c:	4335      	orrmi	r5, r6
        }
        EXTI->FTSR = temp;
  20108e:	60d5      	str	r5, [r2, #12]
  for(position = 0; position < GPIO_NUMBER; position++)
  201090:	3301      	adds	r3, #1
  201092:	2b10      	cmp	r3, #16
  201094:	f47f af3f 	bne.w	200f16 <HAL_GPIO_Init+0x16>
      }
    }
  }
}
  201098:	b005      	add	sp, #20
  20109a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
  20109e:	2500      	movs	r5, #0
  2010a0:	e7d4      	b.n	20104c <HAL_GPIO_Init+0x14c>
  2010a2:	2501      	movs	r5, #1
  2010a4:	e7d2      	b.n	20104c <HAL_GPIO_Init+0x14c>
  2010a6:	2502      	movs	r5, #2
  2010a8:	e7d0      	b.n	20104c <HAL_GPIO_Init+0x14c>
  2010aa:	2503      	movs	r5, #3
  2010ac:	e7ce      	b.n	20104c <HAL_GPIO_Init+0x14c>
  2010ae:	2504      	movs	r5, #4
  2010b0:	e7cc      	b.n	20104c <HAL_GPIO_Init+0x14c>
  2010b2:	2505      	movs	r5, #5
  2010b4:	e7ca      	b.n	20104c <HAL_GPIO_Init+0x14c>
  2010b6:	2506      	movs	r5, #6
  2010b8:	e7c8      	b.n	20104c <HAL_GPIO_Init+0x14c>
  2010ba:	2507      	movs	r5, #7
  2010bc:	e7c6      	b.n	20104c <HAL_GPIO_Init+0x14c>
  2010be:	2508      	movs	r5, #8
  2010c0:	e7c4      	b.n	20104c <HAL_GPIO_Init+0x14c>
  2010c2:	bf00      	nop
  2010c4:	40013c00 	.word	0x40013c00
  2010c8:	40020000 	.word	0x40020000
  2010cc:	40023800 	.word	0x40023800
  2010d0:	40021400 	.word	0x40021400

002010d4 <HAL_GPIO_ReadPin>:
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)
  2010d4:	6903      	ldr	r3, [r0, #16]
  2010d6:	4219      	tst	r1, r3
  else
  {
    bitstatus = GPIO_PIN_RESET;
  }
  return bitstatus;
}
  2010d8:	bf14      	ite	ne
  2010da:	2001      	movne	r0, #1
  2010dc:	2000      	moveq	r0, #0
  2010de:	4770      	bx	lr

002010e0 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
  2010e0:	b10a      	cbz	r2, 2010e6 <HAL_GPIO_WritePin+0x6>
  {
    GPIOx->BSRR = GPIO_Pin;
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16;
  2010e2:	6181      	str	r1, [r0, #24]
  2010e4:	4770      	bx	lr
  2010e6:	0409      	lsls	r1, r1, #16
  2010e8:	e7fb      	b.n	2010e2 <HAL_GPIO_WritePin+0x2>

002010ea <HAL_GPIO_TogglePin>:
void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->ODR ^= GPIO_Pin;
  2010ea:	6943      	ldr	r3, [r0, #20]
  2010ec:	4059      	eors	r1, r3
  2010ee:	6141      	str	r1, [r0, #20]
  2010f0:	4770      	bx	lr

002010f2 <I2C_Flush_TXDR>:
  */
static void I2C_Flush_TXDR(I2C_HandleTypeDef *hi2c)
{
  /* If a pending TXIS flag is set */
  /* Write a dummy data in TXDR to clear it */
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
  2010f2:	6803      	ldr	r3, [r0, #0]
  2010f4:	699a      	ldr	r2, [r3, #24]
  2010f6:	0791      	lsls	r1, r2, #30
  2010f8:	d501      	bpl.n	2010fe <I2C_Flush_TXDR+0xc>
  {
     hi2c->Instance->TXDR = 0x00U;
  2010fa:	2200      	movs	r2, #0
  2010fc:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Flush TX register if not empty */
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
  2010fe:	699a      	ldr	r2, [r3, #24]
  201100:	07d2      	lsls	r2, r2, #31
  201102:	d403      	bmi.n	20110c <I2C_Flush_TXDR+0x1a>
  {
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
  201104:	699a      	ldr	r2, [r3, #24]
  201106:	f042 0201 	orr.w	r2, r2, #1
  20110a:	619a      	str	r2, [r3, #24]
  20110c:	4770      	bx	lr

0020110e <I2C_TransferConfig>:
  *     @arg @ref I2C_GENERATE_START_READ Generate Restart for read request.
  *     @arg @ref I2C_GENERATE_START_WRITE Generate Restart for write request.
  * @retval None
  */
static void I2C_TransferConfig(I2C_HandleTypeDef *hi2c,  uint16_t DevAddress, uint8_t Size, uint32_t Mode, uint32_t Request)
{
  20110e:	b530      	push	{r4, r5, lr}
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));

  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
  201110:	6805      	ldr	r5, [r0, #0]

  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));

  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
  201112:	f3c1 0109 	ubfx	r1, r1, #0, #10
  201116:	9c03      	ldr	r4, [sp, #12]
  tmpreg = hi2c->Instance->CR2;
  201118:	6868      	ldr	r0, [r5, #4]
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
  20111a:	4323      	orrs	r3, r4
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
  20111c:	f020 707f 	bic.w	r0, r0, #66846720	; 0x3fc0000
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
  201120:	4319      	orrs	r1, r3
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
  201122:	f420 3059 	bic.w	r0, r0, #222208	; 0x36400
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
  201126:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
  20112a:	f420 707f 	bic.w	r0, r0, #1020	; 0x3fc
  20112e:	f020 0003 	bic.w	r0, r0, #3
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
  201132:	4301      	orrs	r1, r0
            (uint32_t)Mode | (uint32_t)Request);

  /* update CR2 register */
  hi2c->Instance->CR2 = tmpreg;
  201134:	6069      	str	r1, [r5, #4]
  201136:	bd30      	pop	{r4, r5, pc}

00201138 <I2C_WaitOnFlagUntilTimeout>:
{
  201138:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  20113c:	9f06      	ldr	r7, [sp, #24]
  20113e:	4604      	mov	r4, r0
  201140:	4688      	mov	r8, r1
  201142:	4616      	mov	r6, r2
  201144:	461d      	mov	r5, r3
  while(__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
  201146:	6822      	ldr	r2, [r4, #0]
  201148:	6993      	ldr	r3, [r2, #24]
  20114a:	ea38 0303 	bics.w	r3, r8, r3
  20114e:	bf0c      	ite	eq
  201150:	2301      	moveq	r3, #1
  201152:	2300      	movne	r3, #0
  201154:	42b3      	cmp	r3, r6
  201156:	d002      	beq.n	20115e <I2C_WaitOnFlagUntilTimeout+0x26>
  return HAL_OK;
  201158:	2000      	movs	r0, #0
}
  20115a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if(Timeout != HAL_MAX_DELAY)
  20115e:	1c6b      	adds	r3, r5, #1
  201160:	d0f2      	beq.n	201148 <I2C_WaitOnFlagUntilTimeout+0x10>
      if((Timeout == 0U)||((HAL_GetTick() - Tickstart ) > Timeout))
  201162:	b955      	cbnz	r5, 20117a <I2C_WaitOnFlagUntilTimeout+0x42>
        hi2c->State= HAL_I2C_STATE_READY;
  201164:	2320      	movs	r3, #32
        return HAL_TIMEOUT;
  201166:	2003      	movs	r0, #3
        hi2c->State= HAL_I2C_STATE_READY;
  201168:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
  20116c:	2300      	movs	r3, #0
  20116e:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
        __HAL_UNLOCK(hi2c);
  201172:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
        return HAL_TIMEOUT;
  201176:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if((Timeout == 0U)||((HAL_GetTick() - Tickstart ) > Timeout))
  20117a:	f7ff fc8d 	bl	200a98 <HAL_GetTick>
  20117e:	1bc0      	subs	r0, r0, r7
  201180:	4285      	cmp	r5, r0
  201182:	d2e0      	bcs.n	201146 <I2C_WaitOnFlagUntilTimeout+0xe>
  201184:	e7ee      	b.n	201164 <I2C_WaitOnFlagUntilTimeout+0x2c>

00201186 <I2C_IsAcknowledgeFailed>:
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
  201186:	6803      	ldr	r3, [r0, #0]
{
  201188:	b570      	push	{r4, r5, r6, lr}
  20118a:	4604      	mov	r4, r0
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
  20118c:	6998      	ldr	r0, [r3, #24]
{
  20118e:	460d      	mov	r5, r1
  201190:	4616      	mov	r6, r2
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
  201192:	f010 0010 	ands.w	r0, r0, #16
  201196:	d112      	bne.n	2011be <I2C_IsAcknowledgeFailed+0x38>
  201198:	bd70      	pop	{r4, r5, r6, pc}
      if(Timeout != HAL_MAX_DELAY)
  20119a:	1c69      	adds	r1, r5, #1
  20119c:	d010      	beq.n	2011c0 <I2C_IsAcknowledgeFailed+0x3a>
      if((Timeout == 0U)||((HAL_GetTick() - Tickstart) > Timeout))
  20119e:	b94d      	cbnz	r5, 2011b4 <I2C_IsAcknowledgeFailed+0x2e>
          hi2c->State= HAL_I2C_STATE_READY;
  2011a0:	2320      	movs	r3, #32
          return HAL_TIMEOUT;
  2011a2:	2003      	movs	r0, #3
          hi2c->State= HAL_I2C_STATE_READY;
  2011a4:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
          hi2c->Mode = HAL_I2C_MODE_NONE;
  2011a8:	2300      	movs	r3, #0
  2011aa:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
          __HAL_UNLOCK(hi2c);
  2011ae:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
  2011b2:	bd70      	pop	{r4, r5, r6, pc}
      if((Timeout == 0U)||((HAL_GetTick() - Tickstart) > Timeout))
  2011b4:	f7ff fc70 	bl	200a98 <HAL_GetTick>
  2011b8:	1b80      	subs	r0, r0, r6
  2011ba:	4285      	cmp	r5, r0
  2011bc:	d3f0      	bcc.n	2011a0 <I2C_IsAcknowledgeFailed+0x1a>
    while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
  2011be:	6823      	ldr	r3, [r4, #0]
  2011c0:	6999      	ldr	r1, [r3, #24]
  2011c2:	068a      	lsls	r2, r1, #26
  2011c4:	d5e9      	bpl.n	20119a <I2C_IsAcknowledgeFailed+0x14>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
  2011c6:	2210      	movs	r2, #16
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
  2011c8:	2520      	movs	r5, #32
    I2C_Flush_TXDR(hi2c);
  2011ca:	4620      	mov	r0, r4
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
  2011cc:	61da      	str	r2, [r3, #28]
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
  2011ce:	61dd      	str	r5, [r3, #28]
    I2C_Flush_TXDR(hi2c);
  2011d0:	f7ff ff8f 	bl	2010f2 <I2C_Flush_TXDR>
    I2C_RESET_CR2(hi2c);
  2011d4:	6822      	ldr	r2, [r4, #0]
    return HAL_ERROR;
  2011d6:	2001      	movs	r0, #1
    I2C_RESET_CR2(hi2c);
  2011d8:	6853      	ldr	r3, [r2, #4]
  2011da:	f023 73ff 	bic.w	r3, r3, #33423360	; 0x1fe0000
  2011de:	f423 338b 	bic.w	r3, r3, #71168	; 0x11600
  2011e2:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
  2011e6:	f023 0301 	bic.w	r3, r3, #1
  2011ea:	6053      	str	r3, [r2, #4]
    hi2c->ErrorCode = HAL_I2C_ERROR_AF;
  2011ec:	2304      	movs	r3, #4
  2011ee:	6463      	str	r3, [r4, #68]	; 0x44
    hi2c->Mode = HAL_I2C_MODE_NONE;
  2011f0:	2300      	movs	r3, #0
    hi2c->State= HAL_I2C_STATE_READY;
  2011f2:	f884 5041 	strb.w	r5, [r4, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
  2011f6:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    hi2c->Mode = HAL_I2C_MODE_NONE;
  2011fa:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
}
  2011fe:	bd70      	pop	{r4, r5, r6, pc}

00201200 <I2C_WaitOnTXISFlagUntilTimeout>:
{
  201200:	b570      	push	{r4, r5, r6, lr}
  201202:	4604      	mov	r4, r0
  201204:	460d      	mov	r5, r1
  201206:	4616      	mov	r6, r2
  while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
  201208:	6823      	ldr	r3, [r4, #0]
  20120a:	699b      	ldr	r3, [r3, #24]
  20120c:	079b      	lsls	r3, r3, #30
  20120e:	d501      	bpl.n	201214 <I2C_WaitOnTXISFlagUntilTimeout+0x14>
  return HAL_OK;
  201210:	2000      	movs	r0, #0
  201212:	bd70      	pop	{r4, r5, r6, pc}
    if(I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
  201214:	4632      	mov	r2, r6
  201216:	4629      	mov	r1, r5
  201218:	4620      	mov	r0, r4
  20121a:	f7ff ffb4 	bl	201186 <I2C_IsAcknowledgeFailed>
  20121e:	b9b0      	cbnz	r0, 20124e <I2C_WaitOnTXISFlagUntilTimeout+0x4e>
    if(Timeout != HAL_MAX_DELAY)
  201220:	1c6a      	adds	r2, r5, #1
  201222:	d0f1      	beq.n	201208 <I2C_WaitOnTXISFlagUntilTimeout+0x8>
      if((Timeout == 0U)||((HAL_GetTick() - Tickstart) > Timeout))
  201224:	b96d      	cbnz	r5, 201242 <I2C_WaitOnTXISFlagUntilTimeout+0x42>
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
  201226:	6c63      	ldr	r3, [r4, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
  201228:	2003      	movs	r0, #3
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
  20122a:	f043 0320 	orr.w	r3, r3, #32
  20122e:	6463      	str	r3, [r4, #68]	; 0x44
      hi2c->State= HAL_I2C_STATE_READY;
  201230:	2320      	movs	r3, #32
  201232:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
      hi2c->Mode = HAL_I2C_MODE_NONE;
  201236:	2300      	movs	r3, #0
  201238:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
      __HAL_UNLOCK(hi2c);
  20123c:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
  201240:	bd70      	pop	{r4, r5, r6, pc}
      if((Timeout == 0U)||((HAL_GetTick() - Tickstart) > Timeout))
  201242:	f7ff fc29 	bl	200a98 <HAL_GetTick>
  201246:	1b80      	subs	r0, r0, r6
  201248:	4285      	cmp	r5, r0
  20124a:	d2dd      	bcs.n	201208 <I2C_WaitOnTXISFlagUntilTimeout+0x8>
  20124c:	e7eb      	b.n	201226 <I2C_WaitOnTXISFlagUntilTimeout+0x26>
      return HAL_ERROR;
  20124e:	2001      	movs	r0, #1
}
  201250:	bd70      	pop	{r4, r5, r6, pc}

00201252 <I2C_RequestMemoryRead>:
{
  201252:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  201254:	461f      	mov	r7, r3
  I2C_TransferConfig(hi2c,DevAddress,MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
  201256:	f44f 5300 	mov.w	r3, #8192	; 0x2000
{
  20125a:	4604      	mov	r4, r0
  20125c:	9e09      	ldr	r6, [sp, #36]	; 0x24
  I2C_TransferConfig(hi2c,DevAddress,MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
  20125e:	9300      	str	r3, [sp, #0]
{
  201260:	4615      	mov	r5, r2
  I2C_TransferConfig(hi2c,DevAddress,MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
  201262:	2300      	movs	r3, #0
  201264:	b2fa      	uxtb	r2, r7
  201266:	f7ff ff52 	bl	20110e <I2C_TransferConfig>
  if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
  20126a:	4632      	mov	r2, r6
  20126c:	9908      	ldr	r1, [sp, #32]
  20126e:	4620      	mov	r0, r4
  201270:	f7ff ffc6 	bl	201200 <I2C_WaitOnTXISFlagUntilTimeout>
  201274:	b128      	cbz	r0, 201282 <I2C_RequestMemoryRead+0x30>
    if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
  201276:	6c63      	ldr	r3, [r4, #68]	; 0x44
  201278:	2b04      	cmp	r3, #4
  20127a:	d110      	bne.n	20129e <I2C_RequestMemoryRead+0x4c>
      return HAL_ERROR;
  20127c:	2001      	movs	r0, #1
}
  20127e:	b003      	add	sp, #12
  201280:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if(MemAddSize == I2C_MEMADD_SIZE_8BIT)
  201282:	2f01      	cmp	r7, #1
  201284:	6823      	ldr	r3, [r4, #0]
  201286:	d10c      	bne.n	2012a2 <I2C_RequestMemoryRead+0x50>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
  201288:	b2ed      	uxtb	r5, r5
  if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TC, RESET, Timeout, Tickstart) != HAL_OK)
  20128a:	2200      	movs	r2, #0
  20128c:	2140      	movs	r1, #64	; 0x40
  20128e:	4620      	mov	r0, r4
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
  201290:	629d      	str	r5, [r3, #40]	; 0x28
  if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TC, RESET, Timeout, Tickstart) != HAL_OK)
  201292:	9b08      	ldr	r3, [sp, #32]
  201294:	9600      	str	r6, [sp, #0]
  201296:	f7ff ff4f 	bl	201138 <I2C_WaitOnFlagUntilTimeout>
  20129a:	2800      	cmp	r0, #0
  20129c:	d0ef      	beq.n	20127e <I2C_RequestMemoryRead+0x2c>
      return HAL_TIMEOUT;
  20129e:	2003      	movs	r0, #3
  2012a0:	e7ed      	b.n	20127e <I2C_RequestMemoryRead+0x2c>
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
  2012a2:	0a2a      	lsrs	r2, r5, #8
    if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
  2012a4:	9908      	ldr	r1, [sp, #32]
  2012a6:	4620      	mov	r0, r4
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
  2012a8:	629a      	str	r2, [r3, #40]	; 0x28
    if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
  2012aa:	4632      	mov	r2, r6
  2012ac:	f7ff ffa8 	bl	201200 <I2C_WaitOnTXISFlagUntilTimeout>
  2012b0:	2800      	cmp	r0, #0
  2012b2:	d1e0      	bne.n	201276 <I2C_RequestMemoryRead+0x24>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
  2012b4:	6823      	ldr	r3, [r4, #0]
  2012b6:	e7e7      	b.n	201288 <I2C_RequestMemoryRead+0x36>

002012b8 <I2C_WaitOnSTOPFlagUntilTimeout>:
{
  2012b8:	b570      	push	{r4, r5, r6, lr}
  2012ba:	4604      	mov	r4, r0
  2012bc:	460d      	mov	r5, r1
  2012be:	4616      	mov	r6, r2
  while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
  2012c0:	6823      	ldr	r3, [r4, #0]
  2012c2:	699b      	ldr	r3, [r3, #24]
  2012c4:	069b      	lsls	r3, r3, #26
  2012c6:	d501      	bpl.n	2012cc <I2C_WaitOnSTOPFlagUntilTimeout+0x14>
  return HAL_OK;
  2012c8:	2000      	movs	r0, #0
  2012ca:	bd70      	pop	{r4, r5, r6, pc}
    if(I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
  2012cc:	4632      	mov	r2, r6
  2012ce:	4629      	mov	r1, r5
  2012d0:	4620      	mov	r0, r4
  2012d2:	f7ff ff58 	bl	201186 <I2C_IsAcknowledgeFailed>
  2012d6:	b9a0      	cbnz	r0, 201302 <I2C_WaitOnSTOPFlagUntilTimeout+0x4a>
    if((Timeout == 0U)||((HAL_GetTick() - Tickstart) > Timeout))
  2012d8:	b96d      	cbnz	r5, 2012f6 <I2C_WaitOnSTOPFlagUntilTimeout+0x3e>
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
  2012da:	6c63      	ldr	r3, [r4, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
  2012dc:	2003      	movs	r0, #3
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
  2012de:	f043 0320 	orr.w	r3, r3, #32
  2012e2:	6463      	str	r3, [r4, #68]	; 0x44
      hi2c->State= HAL_I2C_STATE_READY;
  2012e4:	2320      	movs	r3, #32
  2012e6:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
      hi2c->Mode = HAL_I2C_MODE_NONE;
  2012ea:	2300      	movs	r3, #0
  2012ec:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
      __HAL_UNLOCK(hi2c);
  2012f0:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
  2012f4:	bd70      	pop	{r4, r5, r6, pc}
    if((Timeout == 0U)||((HAL_GetTick() - Tickstart) > Timeout))
  2012f6:	f7ff fbcf 	bl	200a98 <HAL_GetTick>
  2012fa:	1b80      	subs	r0, r0, r6
  2012fc:	4285      	cmp	r5, r0
  2012fe:	d2df      	bcs.n	2012c0 <I2C_WaitOnSTOPFlagUntilTimeout+0x8>
  201300:	e7eb      	b.n	2012da <I2C_WaitOnSTOPFlagUntilTimeout+0x22>
      return HAL_ERROR;
  201302:	2001      	movs	r0, #1
}
  201304:	bd70      	pop	{r4, r5, r6, pc}

00201306 <HAL_I2C_Init>:
{
  201306:	b510      	push	{r4, lr}
  if(hi2c == NULL)
  201308:	4604      	mov	r4, r0
  20130a:	2800      	cmp	r0, #0
  20130c:	d04a      	beq.n	2013a4 <HAL_I2C_Init+0x9e>
  if(hi2c->State == HAL_I2C_STATE_RESET)
  20130e:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
  201312:	f003 02ff 	and.w	r2, r3, #255	; 0xff
  201316:	b91b      	cbnz	r3, 201320 <HAL_I2C_Init+0x1a>
    hi2c->Lock = HAL_UNLOCKED;
  201318:	f880 2040 	strb.w	r2, [r0, #64]	; 0x40
    HAL_I2C_MspInit(hi2c);
  20131c:	f002 fbe2 	bl	203ae4 <HAL_I2C_MspInit>
  hi2c->State = HAL_I2C_STATE_BUSY;
  201320:	2324      	movs	r3, #36	; 0x24
  if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
  201322:	68e1      	ldr	r1, [r4, #12]
  hi2c->State = HAL_I2C_STATE_BUSY;
  201324:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
  if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
  201328:	2901      	cmp	r1, #1
  __HAL_I2C_DISABLE(hi2c);
  20132a:	6823      	ldr	r3, [r4, #0]
  20132c:	681a      	ldr	r2, [r3, #0]
  20132e:	f022 0201 	bic.w	r2, r2, #1
  201332:	601a      	str	r2, [r3, #0]
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
  201334:	6862      	ldr	r2, [r4, #4]
  201336:	f022 6270 	bic.w	r2, r2, #251658240	; 0xf000000
  20133a:	611a      	str	r2, [r3, #16]
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
  20133c:	689a      	ldr	r2, [r3, #8]
  20133e:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
  201342:	609a      	str	r2, [r3, #8]
  201344:	68a2      	ldr	r2, [r4, #8]
  if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
  201346:	d124      	bne.n	201392 <HAL_I2C_Init+0x8c>
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
  201348:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
  20134c:	609a      	str	r2, [r3, #8]
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
  20134e:	685a      	ldr	r2, [r3, #4]
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
  201350:	2000      	movs	r0, #0
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
  201352:	6961      	ldr	r1, [r4, #20]
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
  201354:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
  201358:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
  20135c:	605a      	str	r2, [r3, #4]
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
  20135e:	68da      	ldr	r2, [r3, #12]
  201360:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
  201364:	60da      	str	r2, [r3, #12]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
  201366:	6922      	ldr	r2, [r4, #16]
  201368:	430a      	orrs	r2, r1
  20136a:	69a1      	ldr	r1, [r4, #24]
  20136c:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
  201370:	6a21      	ldr	r1, [r4, #32]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
  201372:	60da      	str	r2, [r3, #12]
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
  201374:	69e2      	ldr	r2, [r4, #28]
  201376:	430a      	orrs	r2, r1
  201378:	601a      	str	r2, [r3, #0]
  __HAL_I2C_ENABLE(hi2c);
  20137a:	681a      	ldr	r2, [r3, #0]
  20137c:	f042 0201 	orr.w	r2, r2, #1
  201380:	601a      	str	r2, [r3, #0]
  hi2c->State = HAL_I2C_STATE_READY;
  201382:	2320      	movs	r3, #32
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
  201384:	6460      	str	r0, [r4, #68]	; 0x44
  hi2c->State = HAL_I2C_STATE_READY;
  201386:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
  20138a:	6320      	str	r0, [r4, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
  20138c:	f884 0042 	strb.w	r0, [r4, #66]	; 0x42
  return HAL_OK;
  201390:	bd10      	pop	{r4, pc}
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
  201392:	f442 4204 	orr.w	r2, r2, #33792	; 0x8400
  if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
  201396:	2902      	cmp	r1, #2
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
  201398:	609a      	str	r2, [r3, #8]
  if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
  20139a:	d1d8      	bne.n	20134e <HAL_I2C_Init+0x48>
    hi2c->Instance->CR2 = (I2C_CR2_ADD10);
  20139c:	f44f 6200 	mov.w	r2, #2048	; 0x800
  2013a0:	605a      	str	r2, [r3, #4]
  2013a2:	e7d4      	b.n	20134e <HAL_I2C_Init+0x48>
    return HAL_ERROR;
  2013a4:	2001      	movs	r0, #1
}
  2013a6:	bd10      	pop	{r4, pc}

002013a8 <HAL_I2C_Master_Transmit>:
{
  2013a8:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
  2013ac:	4698      	mov	r8, r3
  if(hi2c->State == HAL_I2C_STATE_READY)
  2013ae:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
{
  2013b2:	4604      	mov	r4, r0
  2013b4:	460e      	mov	r6, r1
  if(hi2c->State == HAL_I2C_STATE_READY)
  2013b6:	2b20      	cmp	r3, #32
{
  2013b8:	4691      	mov	r9, r2
  if(hi2c->State == HAL_I2C_STATE_READY)
  2013ba:	f040 808c 	bne.w	2014d6 <HAL_I2C_Master_Transmit+0x12e>
    __HAL_LOCK(hi2c);
  2013be:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
  2013c2:	2b01      	cmp	r3, #1
  2013c4:	f000 8087 	beq.w	2014d6 <HAL_I2C_Master_Transmit+0x12e>
  2013c8:	2701      	movs	r7, #1
  2013ca:	f880 7040 	strb.w	r7, [r0, #64]	; 0x40
    tickstart = HAL_GetTick();
  2013ce:	f7ff fb63 	bl	200a98 <HAL_GetTick>
    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
  2013d2:	2319      	movs	r3, #25
    tickstart = HAL_GetTick();
  2013d4:	4605      	mov	r5, r0
    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
  2013d6:	9000      	str	r0, [sp, #0]
  2013d8:	463a      	mov	r2, r7
  2013da:	f44f 4100 	mov.w	r1, #32768	; 0x8000
  2013de:	4620      	mov	r0, r4
  2013e0:	f7ff feaa 	bl	201138 <I2C_WaitOnFlagUntilTimeout>
  2013e4:	2800      	cmp	r0, #0
  2013e6:	d14b      	bne.n	201480 <HAL_I2C_Master_Transmit+0xd8>
    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
  2013e8:	2321      	movs	r3, #33	; 0x21
    hi2c->pBuffPtr  = pData;
  2013ea:	f8c4 9024 	str.w	r9, [r4, #36]	; 0x24
    hi2c->XferISR   = NULL;
  2013ee:	6360      	str	r0, [r4, #52]	; 0x34
    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
  2013f0:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
  2013f4:	2310      	movs	r3, #16
  2013f6:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
  2013fa:	6460      	str	r0, [r4, #68]	; 0x44
    hi2c->XferCount = Size;
  2013fc:	f8a4 802a 	strh.w	r8, [r4, #42]	; 0x2a
    if(hi2c->XferCount > MAX_NBYTE_SIZE)
  201400:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
  201402:	b29b      	uxth	r3, r3
  201404:	2bff      	cmp	r3, #255	; 0xff
  201406:	d927      	bls.n	201458 <HAL_I2C_Master_Transmit+0xb0>
      hi2c->XferSize = MAX_NBYTE_SIZE;
  201408:	22ff      	movs	r2, #255	; 0xff
      I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
  20140a:	f44f 5300 	mov.w	r3, #8192	; 0x2000
      hi2c->XferSize = MAX_NBYTE_SIZE;
  20140e:	8522      	strh	r2, [r4, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
  201410:	9300      	str	r3, [sp, #0]
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
  201412:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
  201416:	4631      	mov	r1, r6
  201418:	4620      	mov	r0, r4
  20141a:	f7ff fe78 	bl	20110e <I2C_TransferConfig>
    while(hi2c->XferCount > 0U)
  20141e:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
  201420:	462a      	mov	r2, r5
  201422:	990a      	ldr	r1, [sp, #40]	; 0x28
  201424:	4620      	mov	r0, r4
    while(hi2c->XferCount > 0U)
  201426:	b29b      	uxth	r3, r3
  201428:	bb03      	cbnz	r3, 20146c <HAL_I2C_Master_Transmit+0xc4>
    if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
  20142a:	f7ff ff45 	bl	2012b8 <I2C_WaitOnSTOPFlagUntilTimeout>
  20142e:	bb00      	cbnz	r0, 201472 <HAL_I2C_Master_Transmit+0xca>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
  201430:	6823      	ldr	r3, [r4, #0]
  201432:	2120      	movs	r1, #32
  201434:	61d9      	str	r1, [r3, #28]
    I2C_RESET_CR2(hi2c);
  201436:	685a      	ldr	r2, [r3, #4]
  201438:	f022 72ff 	bic.w	r2, r2, #33423360	; 0x1fe0000
  20143c:	f422 328b 	bic.w	r2, r2, #71168	; 0x11600
  201440:	f422 72ff 	bic.w	r2, r2, #510	; 0x1fe
  201444:	f022 0201 	bic.w	r2, r2, #1
  201448:	605a      	str	r2, [r3, #4]
    hi2c->State = HAL_I2C_STATE_READY;
  20144a:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
  20144e:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
    hi2c->Mode  = HAL_I2C_MODE_NONE;
  201452:	f884 0042 	strb.w	r0, [r4, #66]	; 0x42
    return HAL_OK;
  201456:	e010      	b.n	20147a <HAL_I2C_Master_Transmit+0xd2>
      hi2c->XferSize = hi2c->XferCount;
  201458:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
      I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_WRITE);
  20145a:	f44f 5300 	mov.w	r3, #8192	; 0x2000
      hi2c->XferSize = hi2c->XferCount;
  20145e:	b292      	uxth	r2, r2
      I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_WRITE);
  201460:	9300      	str	r3, [sp, #0]
      hi2c->XferSize = hi2c->XferCount;
  201462:	8522      	strh	r2, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
  201464:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
  201468:	b2d2      	uxtb	r2, r2
  20146a:	e7d4      	b.n	201416 <HAL_I2C_Master_Transmit+0x6e>
      if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
  20146c:	f7ff fec8 	bl	201200 <I2C_WaitOnTXISFlagUntilTimeout>
  201470:	b140      	cbz	r0, 201484 <HAL_I2C_Master_Transmit+0xdc>
        if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
  201472:	6c63      	ldr	r3, [r4, #68]	; 0x44
  201474:	2b04      	cmp	r3, #4
  201476:	d103      	bne.n	201480 <HAL_I2C_Master_Transmit+0xd8>
          return HAL_ERROR;
  201478:	2001      	movs	r0, #1
}
  20147a:	b003      	add	sp, #12
  20147c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
          return HAL_TIMEOUT;
  201480:	2003      	movs	r0, #3
  201482:	e7fa      	b.n	20147a <HAL_I2C_Master_Transmit+0xd2>
      hi2c->Instance->TXDR = (*hi2c->pBuffPtr++);
  201484:	6a63      	ldr	r3, [r4, #36]	; 0x24
  201486:	6822      	ldr	r2, [r4, #0]
  201488:	1c59      	adds	r1, r3, #1
  20148a:	6261      	str	r1, [r4, #36]	; 0x24
  20148c:	781b      	ldrb	r3, [r3, #0]
  20148e:	6293      	str	r3, [r2, #40]	; 0x28
      hi2c->XferSize--;
  201490:	8d22      	ldrh	r2, [r4, #40]	; 0x28
      hi2c->XferCount--;
  201492:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
  201494:	3a01      	subs	r2, #1
      hi2c->XferCount--;
  201496:	3b01      	subs	r3, #1
      hi2c->XferSize--;
  201498:	b292      	uxth	r2, r2
      hi2c->XferCount--;
  20149a:	b29b      	uxth	r3, r3
      hi2c->XferSize--;
  20149c:	8522      	strh	r2, [r4, #40]	; 0x28
      hi2c->XferCount--;
  20149e:	8563      	strh	r3, [r4, #42]	; 0x2a
      if((hi2c->XferSize == 0U) && (hi2c->XferCount!=0U))
  2014a0:	2a00      	cmp	r2, #0
  2014a2:	d1bc      	bne.n	20141e <HAL_I2C_Master_Transmit+0x76>
  2014a4:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
  2014a6:	b29b      	uxth	r3, r3
  2014a8:	2b00      	cmp	r3, #0
  2014aa:	d0b8      	beq.n	20141e <HAL_I2C_Master_Transmit+0x76>
        if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
  2014ac:	9500      	str	r5, [sp, #0]
  2014ae:	2180      	movs	r1, #128	; 0x80
  2014b0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  2014b2:	4620      	mov	r0, r4
  2014b4:	f7ff fe40 	bl	201138 <I2C_WaitOnFlagUntilTimeout>
  2014b8:	2800      	cmp	r0, #0
  2014ba:	d1e1      	bne.n	201480 <HAL_I2C_Master_Transmit+0xd8>
        if(hi2c->XferCount > MAX_NBYTE_SIZE)
  2014bc:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
  2014be:	b29b      	uxth	r3, r3
  2014c0:	2bff      	cmp	r3, #255	; 0xff
  2014c2:	d903      	bls.n	2014cc <HAL_I2C_Master_Transmit+0x124>
          hi2c->XferSize = MAX_NBYTE_SIZE;
  2014c4:	22ff      	movs	r2, #255	; 0xff
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
  2014c6:	9000      	str	r0, [sp, #0]
          hi2c->XferSize = MAX_NBYTE_SIZE;
  2014c8:	8522      	strh	r2, [r4, #40]	; 0x28
  2014ca:	e7a2      	b.n	201412 <HAL_I2C_Master_Transmit+0x6a>
          hi2c->XferSize = hi2c->XferCount;
  2014cc:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
  2014ce:	9000      	str	r0, [sp, #0]
          hi2c->XferSize = hi2c->XferCount;
  2014d0:	b292      	uxth	r2, r2
  2014d2:	8522      	strh	r2, [r4, #40]	; 0x28
  2014d4:	e7c6      	b.n	201464 <HAL_I2C_Master_Transmit+0xbc>
    return HAL_BUSY;
  2014d6:	2002      	movs	r0, #2
  2014d8:	e7cf      	b.n	20147a <HAL_I2C_Master_Transmit+0xd2>

002014da <HAL_I2C_Mem_Read>:
{
  2014da:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  2014de:	469b      	mov	fp, r3
  if(hi2c->State == HAL_I2C_STATE_READY)
  2014e0:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
{
  2014e4:	b085      	sub	sp, #20
  2014e6:	4604      	mov	r4, r0
  if(hi2c->State == HAL_I2C_STATE_READY)
  2014e8:	2b20      	cmp	r3, #32
{
  2014ea:	460f      	mov	r7, r1
  2014ec:	9203      	str	r2, [sp, #12]
  2014ee:	f8bd a03c 	ldrh.w	sl, [sp, #60]	; 0x3c
  2014f2:	f8dd 9040 	ldr.w	r9, [sp, #64]	; 0x40
  if(hi2c->State == HAL_I2C_STATE_READY)
  2014f6:	f040 80ac 	bne.w	201652 <HAL_I2C_Mem_Read+0x178>
    if((pData == NULL) || (Size == 0U))
  2014fa:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  2014fc:	b91b      	cbnz	r3, 201506 <HAL_I2C_Mem_Read+0x2c>
      return  HAL_ERROR;
  2014fe:	2001      	movs	r0, #1
}
  201500:	b005      	add	sp, #20
  201502:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if((pData == NULL) || (Size == 0U))
  201506:	f1ba 0f00 	cmp.w	sl, #0
  20150a:	d0f8      	beq.n	2014fe <HAL_I2C_Mem_Read+0x24>
    __HAL_LOCK(hi2c);
  20150c:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
  201510:	2b01      	cmp	r3, #1
  201512:	f000 809e 	beq.w	201652 <HAL_I2C_Mem_Read+0x178>
  201516:	2501      	movs	r5, #1
  201518:	f880 5040 	strb.w	r5, [r0, #64]	; 0x40
    tickstart = HAL_GetTick();
  20151c:	f7ff fabc 	bl	200a98 <HAL_GetTick>
    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
  201520:	2319      	movs	r3, #25
  201522:	9000      	str	r0, [sp, #0]
    tickstart = HAL_GetTick();
  201524:	4606      	mov	r6, r0
    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
  201526:	462a      	mov	r2, r5
  201528:	f44f 4100 	mov.w	r1, #32768	; 0x8000
  20152c:	4620      	mov	r0, r4
  20152e:	f7ff fe03 	bl	201138 <I2C_WaitOnFlagUntilTimeout>
  201532:	4680      	mov	r8, r0
  201534:	b9d0      	cbnz	r0, 20156c <HAL_I2C_Mem_Read+0x92>
    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
  201536:	2322      	movs	r3, #34	; 0x22
    hi2c->XferISR   = NULL;
  201538:	6360      	str	r0, [r4, #52]	; 0x34
    if(I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
  20153a:	9601      	str	r6, [sp, #4]
  20153c:	4639      	mov	r1, r7
    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
  20153e:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
  201542:	2340      	movs	r3, #64	; 0x40
    if(I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
  201544:	f8cd 9000 	str.w	r9, [sp]
    hi2c->Mode      = HAL_I2C_MODE_MEM;
  201548:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    hi2c->pBuffPtr  = pData;
  20154c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
  20154e:	6460      	str	r0, [r4, #68]	; 0x44
    if(I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
  201550:	4620      	mov	r0, r4
    hi2c->pBuffPtr  = pData;
  201552:	6263      	str	r3, [r4, #36]	; 0x24
    if(I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
  201554:	465b      	mov	r3, fp
    hi2c->XferCount = Size;
  201556:	f8a4 a02a 	strh.w	sl, [r4, #42]	; 0x2a
    if(I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
  20155a:	9a03      	ldr	r2, [sp, #12]
  20155c:	f7ff fe79 	bl	201252 <I2C_RequestMemoryRead>
  201560:	b130      	cbz	r0, 201570 <HAL_I2C_Mem_Read+0x96>
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
  201562:	6c63      	ldr	r3, [r4, #68]	; 0x44
        __HAL_UNLOCK(hi2c);
  201564:	f884 8040 	strb.w	r8, [r4, #64]	; 0x40
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
  201568:	2b04      	cmp	r3, #4
  20156a:	d0c8      	beq.n	2014fe <HAL_I2C_Mem_Read+0x24>
        return HAL_TIMEOUT;
  20156c:	2003      	movs	r0, #3
  20156e:	e7c7      	b.n	201500 <HAL_I2C_Mem_Read+0x26>
    if(hi2c->XferCount > MAX_NBYTE_SIZE)
  201570:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
  201572:	b29b      	uxth	r3, r3
  201574:	2bff      	cmp	r3, #255	; 0xff
  201576:	d946      	bls.n	201606 <HAL_I2C_Mem_Read+0x12c>
      I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
  201578:	f44f 5310 	mov.w	r3, #9216	; 0x2400
      hi2c->XferSize = MAX_NBYTE_SIZE;
  20157c:	22ff      	movs	r2, #255	; 0xff
      I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
  20157e:	9300      	str	r3, [sp, #0]
  201580:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
      hi2c->XferSize = MAX_NBYTE_SIZE;
  201584:	8522      	strh	r2, [r4, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
  201586:	4639      	mov	r1, r7
  201588:	4620      	mov	r0, r4
  20158a:	f7ff fdc0 	bl	20110e <I2C_TransferConfig>
      if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, Timeout, tickstart) != HAL_OK)
  20158e:	9600      	str	r6, [sp, #0]
  201590:	464b      	mov	r3, r9
  201592:	2200      	movs	r2, #0
  201594:	2104      	movs	r1, #4
  201596:	4620      	mov	r0, r4
  201598:	f7ff fdce 	bl	201138 <I2C_WaitOnFlagUntilTimeout>
  20159c:	2800      	cmp	r0, #0
  20159e:	d1e5      	bne.n	20156c <HAL_I2C_Mem_Read+0x92>
      (*hi2c->pBuffPtr++) = hi2c->Instance->RXDR;
  2015a0:	6a63      	ldr	r3, [r4, #36]	; 0x24
  2015a2:	1c5a      	adds	r2, r3, #1
  2015a4:	6262      	str	r2, [r4, #36]	; 0x24
  2015a6:	6822      	ldr	r2, [r4, #0]
  2015a8:	6a52      	ldr	r2, [r2, #36]	; 0x24
  2015aa:	701a      	strb	r2, [r3, #0]
      hi2c->XferSize--;
  2015ac:	8d22      	ldrh	r2, [r4, #40]	; 0x28
      hi2c->XferCount--;
  2015ae:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
  2015b0:	3a01      	subs	r2, #1
      hi2c->XferCount--;
  2015b2:	3b01      	subs	r3, #1
      hi2c->XferSize--;
  2015b4:	b292      	uxth	r2, r2
      hi2c->XferCount--;
  2015b6:	b29b      	uxth	r3, r3
      hi2c->XferSize--;
  2015b8:	8522      	strh	r2, [r4, #40]	; 0x28
      hi2c->XferCount--;
  2015ba:	8563      	strh	r3, [r4, #42]	; 0x2a
      if((hi2c->XferSize == 0U) && (hi2c->XferCount != 0U))
  2015bc:	b9ba      	cbnz	r2, 2015ee <HAL_I2C_Mem_Read+0x114>
  2015be:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
  2015c0:	b29b      	uxth	r3, r3
  2015c2:	b1a3      	cbz	r3, 2015ee <HAL_I2C_Mem_Read+0x114>
        if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
  2015c4:	9600      	str	r6, [sp, #0]
  2015c6:	464b      	mov	r3, r9
  2015c8:	2180      	movs	r1, #128	; 0x80
  2015ca:	4620      	mov	r0, r4
  2015cc:	f7ff fdb4 	bl	201138 <I2C_WaitOnFlagUntilTimeout>
  2015d0:	2800      	cmp	r0, #0
  2015d2:	d1cb      	bne.n	20156c <HAL_I2C_Mem_Read+0x92>
        if(hi2c->XferCount > MAX_NBYTE_SIZE)
  2015d4:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
  2015d6:	b29b      	uxth	r3, r3
  2015d8:	2bff      	cmp	r3, #255	; 0xff
  2015da:	d91e      	bls.n	20161a <HAL_I2C_Mem_Read+0x140>
          hi2c->XferSize = MAX_NBYTE_SIZE;
  2015dc:	22ff      	movs	r2, #255	; 0xff
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
  2015de:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
  2015e2:	9000      	str	r0, [sp, #0]
          hi2c->XferSize = MAX_NBYTE_SIZE;
  2015e4:	8522      	strh	r2, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
  2015e6:	4639      	mov	r1, r7
  2015e8:	4620      	mov	r0, r4
  2015ea:	f7ff fd90 	bl	20110e <I2C_TransferConfig>
    }while(hi2c->XferCount > 0U);
  2015ee:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
  2015f0:	b29b      	uxth	r3, r3
  2015f2:	2b00      	cmp	r3, #0
  2015f4:	d1cb      	bne.n	20158e <HAL_I2C_Mem_Read+0xb4>
    if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
  2015f6:	4632      	mov	r2, r6
  2015f8:	4649      	mov	r1, r9
  2015fa:	4620      	mov	r0, r4
  2015fc:	f7ff fe5c 	bl	2012b8 <I2C_WaitOnSTOPFlagUntilTimeout>
  201600:	b198      	cbz	r0, 20162a <HAL_I2C_Mem_Read+0x150>
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
  201602:	6c63      	ldr	r3, [r4, #68]	; 0x44
  201604:	e7b0      	b.n	201568 <HAL_I2C_Mem_Read+0x8e>
      hi2c->XferSize = hi2c->XferCount;
  201606:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
      I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
  201608:	f44f 5310 	mov.w	r3, #9216	; 0x2400
      hi2c->XferSize = hi2c->XferCount;
  20160c:	b292      	uxth	r2, r2
      I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
  20160e:	9300      	str	r3, [sp, #0]
  201610:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
      hi2c->XferSize = hi2c->XferCount;
  201614:	8522      	strh	r2, [r4, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
  201616:	b2d2      	uxtb	r2, r2
  201618:	e7b5      	b.n	201586 <HAL_I2C_Mem_Read+0xac>
          hi2c->XferSize = hi2c->XferCount;
  20161a:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
  20161c:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
  201620:	9000      	str	r0, [sp, #0]
          hi2c->XferSize = hi2c->XferCount;
  201622:	b292      	uxth	r2, r2
  201624:	8522      	strh	r2, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
  201626:	b2d2      	uxtb	r2, r2
  201628:	e7dd      	b.n	2015e6 <HAL_I2C_Mem_Read+0x10c>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
  20162a:	6823      	ldr	r3, [r4, #0]
  20162c:	2120      	movs	r1, #32
  20162e:	61d9      	str	r1, [r3, #28]
    I2C_RESET_CR2(hi2c);
  201630:	685a      	ldr	r2, [r3, #4]
  201632:	f022 72ff 	bic.w	r2, r2, #33423360	; 0x1fe0000
  201636:	f422 328b 	bic.w	r2, r2, #71168	; 0x11600
  20163a:	f422 72ff 	bic.w	r2, r2, #510	; 0x1fe
  20163e:	f022 0201 	bic.w	r2, r2, #1
  201642:	605a      	str	r2, [r3, #4]
    hi2c->State = HAL_I2C_STATE_READY;
  201644:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
  201648:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
    hi2c->Mode  = HAL_I2C_MODE_NONE;
  20164c:	f884 0042 	strb.w	r0, [r4, #66]	; 0x42
    return HAL_OK;
  201650:	e756      	b.n	201500 <HAL_I2C_Mem_Read+0x26>
    return HAL_BUSY;
  201652:	2002      	movs	r0, #2
  201654:	e754      	b.n	201500 <HAL_I2C_Mem_Read+0x26>

00201656 <HAL_I2C_EV_IRQHandler>:
  uint32_t itflags   = READ_REG(hi2c->Instance->ISR);
  201656:	6802      	ldr	r2, [r0, #0]
  if(hi2c->XferISR != NULL)
  201658:	6b43      	ldr	r3, [r0, #52]	; 0x34
  uint32_t itflags   = READ_REG(hi2c->Instance->ISR);
  20165a:	6991      	ldr	r1, [r2, #24]
  uint32_t itsources = READ_REG(hi2c->Instance->CR1);
  20165c:	6812      	ldr	r2, [r2, #0]
  if(hi2c->XferISR != NULL)
  20165e:	b103      	cbz	r3, 201662 <HAL_I2C_EV_IRQHandler+0xc>
    hi2c->XferISR(hi2c, itflags, itsources);
  201660:	4718      	bx	r3
  201662:	4770      	bx	lr

00201664 <HAL_I2CEx_ConfigAnalogFilter>:
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));

  if(hi2c->State == HAL_I2C_STATE_READY)
  201664:	f890 2041 	ldrb.w	r2, [r0, #65]	; 0x41
  201668:	b2d2      	uxtb	r2, r2
  20166a:	2a20      	cmp	r2, #32
{
  20166c:	b510      	push	{r4, lr}
  if(hi2c->State == HAL_I2C_STATE_READY)
  20166e:	d11d      	bne.n	2016ac <HAL_I2CEx_ConfigAnalogFilter+0x48>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
  201670:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
  201674:	2b01      	cmp	r3, #1
  201676:	d019      	beq.n	2016ac <HAL_I2CEx_ConfigAnalogFilter+0x48>

    hi2c->State = HAL_I2C_STATE_BUSY;
  201678:	2324      	movs	r3, #36	; 0x24
  20167a:	f880 3041 	strb.w	r3, [r0, #65]	; 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
  20167e:	6803      	ldr	r3, [r0, #0]
  201680:	681c      	ldr	r4, [r3, #0]
  201682:	f024 0401 	bic.w	r4, r4, #1
  201686:	601c      	str	r4, [r3, #0]

    /* Reset I2Cx ANOFF bit */
    hi2c->Instance->CR1 &= ~(I2C_CR1_ANFOFF);
  201688:	681c      	ldr	r4, [r3, #0]
  20168a:	f424 5480 	bic.w	r4, r4, #4096	; 0x1000
  20168e:	601c      	str	r4, [r3, #0]

    /* Set analog filter bit*/
    hi2c->Instance->CR1 |= AnalogFilter;
  201690:	681c      	ldr	r4, [r3, #0]
  201692:	4321      	orrs	r1, r4
  201694:	6019      	str	r1, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
  201696:	6819      	ldr	r1, [r3, #0]
  201698:	f041 0101 	orr.w	r1, r1, #1
  20169c:	6019      	str	r1, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
  20169e:	2300      	movs	r3, #0
    hi2c->State = HAL_I2C_STATE_READY;
  2016a0:	f880 2041 	strb.w	r2, [r0, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
  2016a4:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40

    return HAL_OK;
  2016a8:	4618      	mov	r0, r3
  2016aa:	bd10      	pop	{r4, pc}
  }
  else
  {
    return HAL_BUSY;
  2016ac:	2002      	movs	r0, #2
  }
}
  2016ae:	bd10      	pop	{r4, pc}

002016b0 <HAL_I2CEx_ConfigDigitalFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  DigitalFilter Coefficient of digital noise filter between Min_Data=0x00 and Max_Data=0x0F.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigDigitalFilter(I2C_HandleTypeDef *hi2c, uint32_t DigitalFilter)
{
  2016b0:	b510      	push	{r4, lr}

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));

  if(hi2c->State == HAL_I2C_STATE_READY)
  2016b2:	f890 4041 	ldrb.w	r4, [r0, #65]	; 0x41
  2016b6:	b2e4      	uxtb	r4, r4
  2016b8:	2c20      	cmp	r4, #32
  2016ba:	d11c      	bne.n	2016f6 <HAL_I2CEx_ConfigDigitalFilter+0x46>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
  2016bc:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
  2016c0:	2b01      	cmp	r3, #1
  2016c2:	d018      	beq.n	2016f6 <HAL_I2CEx_ConfigDigitalFilter+0x46>

    hi2c->State = HAL_I2C_STATE_BUSY;
  2016c4:	2324      	movs	r3, #36	; 0x24
  2016c6:	f880 3041 	strb.w	r3, [r0, #65]	; 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
  2016ca:	6803      	ldr	r3, [r0, #0]
  2016cc:	681a      	ldr	r2, [r3, #0]
  2016ce:	f022 0201 	bic.w	r2, r2, #1
  2016d2:	601a      	str	r2, [r3, #0]

    /* Get the old register value */
    tmpreg = hi2c->Instance->CR1;
  2016d4:	681a      	ldr	r2, [r3, #0]

    /* Reset I2Cx DNF bits [11:8] */
    tmpreg &= ~(I2C_CR1_DNF);
  2016d6:	f422 6270 	bic.w	r2, r2, #3840	; 0xf00

    /* Set I2Cx DNF coefficient */
    tmpreg |= DigitalFilter << 8U;
  2016da:	ea42 2101 	orr.w	r1, r2, r1, lsl #8

    /* Store the new register value */
    hi2c->Instance->CR1 = tmpreg;
  2016de:	6019      	str	r1, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
  2016e0:	681a      	ldr	r2, [r3, #0]
  2016e2:	f042 0201 	orr.w	r2, r2, #1
  2016e6:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
  2016e8:	2300      	movs	r3, #0
    hi2c->State = HAL_I2C_STATE_READY;
  2016ea:	f880 4041 	strb.w	r4, [r0, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
  2016ee:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40

    return HAL_OK;
  2016f2:	4618      	mov	r0, r3
  2016f4:	bd10      	pop	{r4, pc}
  }
  else
  {
    return HAL_BUSY;
  2016f6:	2002      	movs	r0, #2
  }
}
  2016f8:	bd10      	pop	{r4, pc}

002016fa <HAL_IWDG_Init>:
  * @param  hiwdg  pointer to a IWDG_HandleTypeDef structure that contains
  *                the configuration information for the specified IWDG module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_IWDG_Init(IWDG_HandleTypeDef *hiwdg)
{
  2016fa:	b538      	push	{r3, r4, r5, lr}
  uint32_t tickstart;

  /* Check the IWDG handle allocation */
  if(hiwdg == NULL)
  2016fc:	4604      	mov	r4, r0
  2016fe:	b308      	cbz	r0, 201744 <HAL_IWDG_Init+0x4a>
  assert_param(IS_IWDG_PRESCALER(hiwdg->Init.Prescaler));
  assert_param(IS_IWDG_RELOAD(hiwdg->Init.Reload));
  assert_param(IS_IWDG_WINDOW(hiwdg->Init.Window));

  /* Enable IWDG. LSI is turned on automaticaly */
  __HAL_IWDG_START(hiwdg);
  201700:	6803      	ldr	r3, [r0, #0]
  201702:	f64c 42cc 	movw	r2, #52428	; 0xcccc
  201706:	601a      	str	r2, [r3, #0]

  /* Enable write access to IWDG_PR, IWDG_RLR and IWDG_WINR registers by writing
  0x5555 in KR */
  IWDG_ENABLE_WRITE_ACCESS(hiwdg);
  201708:	f245 5255 	movw	r2, #21845	; 0x5555
  20170c:	601a      	str	r2, [r3, #0]

  /* Write to IWDG registers the Prescaler & Reload values to work with */
  hiwdg->Instance->PR = hiwdg->Init.Prescaler;
  20170e:	6842      	ldr	r2, [r0, #4]
  201710:	605a      	str	r2, [r3, #4]
  hiwdg->Instance->RLR = hiwdg->Init.Reload;
  201712:	6882      	ldr	r2, [r0, #8]
  201714:	609a      	str	r2, [r3, #8]

  /* Check pending flag, if previous update not done, return timeout */
  tickstart = HAL_GetTick();
  201716:	f7ff f9bf 	bl	200a98 <HAL_GetTick>
  20171a:	4605      	mov	r5, r0

   /* Wait for register to be updated */
  while(hiwdg->Instance->SR != RESET)
  20171c:	6823      	ldr	r3, [r4, #0]
  20171e:	68d8      	ldr	r0, [r3, #12]
  201720:	b928      	cbnz	r0, 20172e <HAL_IWDG_Init+0x34>
    }
  }

  /* If window parameter is different than current value, modify window 
  register */
  if(hiwdg->Instance->WINR != hiwdg->Init.Window)
  201722:	6919      	ldr	r1, [r3, #16]
  201724:	68e2      	ldr	r2, [r4, #12]
  201726:	4291      	cmp	r1, r2
  201728:	d008      	beq.n	20173c <HAL_IWDG_Init+0x42>
  {
    /* Write to IWDG WINR the IWDG_Window value to compare with. In any case,
    even if window feature is disabled, Watchdog will be reloaded by writing 
    windows register */
    hiwdg->Instance->WINR = hiwdg->Init.Window;
  20172a:	611a      	str	r2, [r3, #16]
  20172c:	bd38      	pop	{r3, r4, r5, pc}
    if((HAL_GetTick() - tickstart ) > HAL_IWDG_DEFAULT_TIMEOUT)
  20172e:	f7ff f9b3 	bl	200a98 <HAL_GetTick>
  201732:	1b40      	subs	r0, r0, r5
  201734:	2830      	cmp	r0, #48	; 0x30
  201736:	d9f1      	bls.n	20171c <HAL_IWDG_Init+0x22>
      return HAL_TIMEOUT;
  201738:	2003      	movs	r0, #3
    __HAL_IWDG_RELOAD_COUNTER(hiwdg);
  }

  /* Return function status */
  return HAL_OK;
}
  20173a:	bd38      	pop	{r3, r4, r5, pc}
    __HAL_IWDG_RELOAD_COUNTER(hiwdg);
  20173c:	f64a 22aa 	movw	r2, #43690	; 0xaaaa
  201740:	601a      	str	r2, [r3, #0]
  201742:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
  201744:	2001      	movs	r0, #1
  201746:	bd38      	pop	{r3, r4, r5, pc}

00201748 <HAL_IWDG_Refresh>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_IWDG_Refresh(IWDG_HandleTypeDef *hiwdg)
{
  /* Reload IWDG counter with value defined in the reload register */
  __HAL_IWDG_RELOAD_COUNTER(hiwdg);
  201748:	6803      	ldr	r3, [r0, #0]
  20174a:	f64a 22aa 	movw	r2, #43690	; 0xaaaa

  /* Return function status */
  return HAL_OK;
}
  20174e:	2000      	movs	r0, #0
  __HAL_IWDG_RELOAD_COUNTER(hiwdg);
  201750:	601a      	str	r2, [r3, #0]
}
  201752:	4770      	bx	lr

00201754 <HAL_PWREx_EnableOverDrive>:
  */
HAL_StatusTypeDef HAL_PWREx_EnableOverDrive(void)
{
  uint32_t tickstart = 0;

  __HAL_RCC_PWR_CLK_ENABLE();
  201754:	4b19      	ldr	r3, [pc, #100]	; (2017bc <HAL_PWREx_EnableOverDrive+0x68>)
{
  201756:	b537      	push	{r0, r1, r2, r4, r5, lr}
  __HAL_RCC_PWR_CLK_ENABLE();
  201758:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  
  /* Enable the Over-drive to extend the clock frequency to 216 MHz */
  __HAL_PWR_OVERDRIVE_ENABLE();
  20175a:	4c19      	ldr	r4, [pc, #100]	; (2017c0 <HAL_PWREx_EnableOverDrive+0x6c>)
  __HAL_RCC_PWR_CLK_ENABLE();
  20175c:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
  201760:	641a      	str	r2, [r3, #64]	; 0x40
  201762:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  201764:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
  201768:	9301      	str	r3, [sp, #4]
  20176a:	9b01      	ldr	r3, [sp, #4]
  __HAL_PWR_OVERDRIVE_ENABLE();
  20176c:	6823      	ldr	r3, [r4, #0]
  20176e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
  201772:	6023      	str	r3, [r4, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
  201774:	f7ff f990 	bl	200a98 <HAL_GetTick>
  201778:	4605      	mov	r5, r0

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
  20177a:	6863      	ldr	r3, [r4, #4]
  20177c:	03da      	lsls	r2, r3, #15
  20177e:	d50c      	bpl.n	20179a <HAL_PWREx_EnableOverDrive+0x46>
      return HAL_TIMEOUT;
    }
  }
  
  /* Enable the Over-drive switch */
  __HAL_PWR_OVERDRIVESWITCHING_ENABLE();
  201780:	6823      	ldr	r3, [r4, #0]
  201782:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  201786:	6023      	str	r3, [r4, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
  201788:	f7ff f986 	bl	200a98 <HAL_GetTick>

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
  20178c:	4c0c      	ldr	r4, [pc, #48]	; (2017c0 <HAL_PWREx_EnableOverDrive+0x6c>)
  tickstart = HAL_GetTick();
  20178e:	4605      	mov	r5, r0
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
  201790:	6863      	ldr	r3, [r4, #4]
  201792:	039b      	lsls	r3, r3, #14
  201794:	d50a      	bpl.n	2017ac <HAL_PWREx_EnableOverDrive+0x58>
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
    {
      return HAL_TIMEOUT;
    }
  } 
  return HAL_OK;
  201796:	2000      	movs	r0, #0
  201798:	e006      	b.n	2017a8 <HAL_PWREx_EnableOverDrive+0x54>
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
  20179a:	f7ff f97d 	bl	200a98 <HAL_GetTick>
  20179e:	1b40      	subs	r0, r0, r5
  2017a0:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
  2017a4:	d9e9      	bls.n	20177a <HAL_PWREx_EnableOverDrive+0x26>
      return HAL_TIMEOUT;
  2017a6:	2003      	movs	r0, #3
}
  2017a8:	b003      	add	sp, #12
  2017aa:	bd30      	pop	{r4, r5, pc}
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
  2017ac:	f7ff f974 	bl	200a98 <HAL_GetTick>
  2017b0:	1b40      	subs	r0, r0, r5
  2017b2:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
  2017b6:	d9eb      	bls.n	201790 <HAL_PWREx_EnableOverDrive+0x3c>
  2017b8:	e7f5      	b.n	2017a6 <HAL_PWREx_EnableOverDrive+0x52>
  2017ba:	bf00      	nop
  2017bc:	40023800 	.word	0x40023800
  2017c0:	40007000 	.word	0x40007000

002017c4 <HAL_RCC_OscConfig>:
  *         supported by this function. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
  2017c4:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  uint32_t tickstart;
  FlagStatus pwrclkchanged = RESET;

  /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
  2017c8:	4604      	mov	r4, r0
  2017ca:	b918      	cbnz	r0, 2017d4 <HAL_RCC_OscConfig+0x10>
  {
    return HAL_ERROR;
  2017cc:	2001      	movs	r0, #1
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
}
  2017ce:	b002      	add	sp, #8
  2017d0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
  2017d4:	6803      	ldr	r3, [r0, #0]
  2017d6:	07d8      	lsls	r0, r3, #31
  2017d8:	d410      	bmi.n	2017fc <HAL_RCC_OscConfig+0x38>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
  2017da:	6823      	ldr	r3, [r4, #0]
  2017dc:	0799      	lsls	r1, r3, #30
  2017de:	d45e      	bmi.n	20189e <HAL_RCC_OscConfig+0xda>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
  2017e0:	6823      	ldr	r3, [r4, #0]
  2017e2:	0719      	lsls	r1, r3, #28
  2017e4:	f100 80a3 	bmi.w	20192e <HAL_RCC_OscConfig+0x16a>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
  2017e8:	6823      	ldr	r3, [r4, #0]
  2017ea:	075a      	lsls	r2, r3, #29
  2017ec:	f100 80c4 	bmi.w	201978 <HAL_RCC_OscConfig+0x1b4>
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
  2017f0:	69a2      	ldr	r2, [r4, #24]
  2017f2:	2a00      	cmp	r2, #0
  2017f4:	f040 812e 	bne.w	201a54 <HAL_RCC_OscConfig+0x290>
  return HAL_OK;
  2017f8:	2000      	movs	r0, #0
  2017fa:	e7e8      	b.n	2017ce <HAL_RCC_OscConfig+0xa>
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE)
  2017fc:	4b93      	ldr	r3, [pc, #588]	; (201a4c <HAL_RCC_OscConfig+0x288>)
  2017fe:	689a      	ldr	r2, [r3, #8]
  201800:	f002 020c 	and.w	r2, r2, #12
  201804:	2a04      	cmp	r2, #4
  201806:	d007      	beq.n	201818 <HAL_RCC_OscConfig+0x54>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
  201808:	689a      	ldr	r2, [r3, #8]
  20180a:	f002 020c 	and.w	r2, r2, #12
  20180e:	2a08      	cmp	r2, #8
  201810:	d10a      	bne.n	201828 <HAL_RCC_OscConfig+0x64>
  201812:	685b      	ldr	r3, [r3, #4]
  201814:	025a      	lsls	r2, r3, #9
  201816:	d507      	bpl.n	201828 <HAL_RCC_OscConfig+0x64>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
  201818:	4b8c      	ldr	r3, [pc, #560]	; (201a4c <HAL_RCC_OscConfig+0x288>)
  20181a:	681b      	ldr	r3, [r3, #0]
  20181c:	039b      	lsls	r3, r3, #14
  20181e:	d5dc      	bpl.n	2017da <HAL_RCC_OscConfig+0x16>
  201820:	6863      	ldr	r3, [r4, #4]
  201822:	2b00      	cmp	r3, #0
  201824:	d1d9      	bne.n	2017da <HAL_RCC_OscConfig+0x16>
  201826:	e7d1      	b.n	2017cc <HAL_RCC_OscConfig+0x8>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
  201828:	6863      	ldr	r3, [r4, #4]
  20182a:	4d88      	ldr	r5, [pc, #544]	; (201a4c <HAL_RCC_OscConfig+0x288>)
  20182c:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
  201830:	d111      	bne.n	201856 <HAL_RCC_OscConfig+0x92>
  201832:	682b      	ldr	r3, [r5, #0]
  201834:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
  201838:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
  20183a:	f7ff f92d 	bl	200a98 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
  20183e:	4d83      	ldr	r5, [pc, #524]	; (201a4c <HAL_RCC_OscConfig+0x288>)
        tickstart = HAL_GetTick();
  201840:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
  201842:	682b      	ldr	r3, [r5, #0]
  201844:	039f      	lsls	r7, r3, #14
  201846:	d4c8      	bmi.n	2017da <HAL_RCC_OscConfig+0x16>
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
  201848:	f7ff f926 	bl	200a98 <HAL_GetTick>
  20184c:	1b80      	subs	r0, r0, r6
  20184e:	2864      	cmp	r0, #100	; 0x64
  201850:	d9f7      	bls.n	201842 <HAL_RCC_OscConfig+0x7e>
            return HAL_TIMEOUT;
  201852:	2003      	movs	r0, #3
  201854:	e7bb      	b.n	2017ce <HAL_RCC_OscConfig+0xa>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
  201856:	b99b      	cbnz	r3, 201880 <HAL_RCC_OscConfig+0xbc>
  201858:	682b      	ldr	r3, [r5, #0]
  20185a:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
  20185e:	602b      	str	r3, [r5, #0]
  201860:	682b      	ldr	r3, [r5, #0]
  201862:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
  201866:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
  201868:	f7ff f916 	bl	200a98 <HAL_GetTick>
  20186c:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
  20186e:	682b      	ldr	r3, [r5, #0]
  201870:	0398      	lsls	r0, r3, #14
  201872:	d5b2      	bpl.n	2017da <HAL_RCC_OscConfig+0x16>
           if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
  201874:	f7ff f910 	bl	200a98 <HAL_GetTick>
  201878:	1b80      	subs	r0, r0, r6
  20187a:	2864      	cmp	r0, #100	; 0x64
  20187c:	d9f7      	bls.n	20186e <HAL_RCC_OscConfig+0xaa>
  20187e:	e7e8      	b.n	201852 <HAL_RCC_OscConfig+0x8e>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
  201880:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
  201884:	682b      	ldr	r3, [r5, #0]
  201886:	d103      	bne.n	201890 <HAL_RCC_OscConfig+0xcc>
  201888:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
  20188c:	602b      	str	r3, [r5, #0]
  20188e:	e7d0      	b.n	201832 <HAL_RCC_OscConfig+0x6e>
  201890:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
  201894:	602b      	str	r3, [r5, #0]
  201896:	682b      	ldr	r3, [r5, #0]
  201898:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
  20189c:	e7cc      	b.n	201838 <HAL_RCC_OscConfig+0x74>
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI)
  20189e:	4b6b      	ldr	r3, [pc, #428]	; (201a4c <HAL_RCC_OscConfig+0x288>)
  2018a0:	689a      	ldr	r2, [r3, #8]
  2018a2:	f012 0f0c 	tst.w	r2, #12
  2018a6:	d007      	beq.n	2018b8 <HAL_RCC_OscConfig+0xf4>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
  2018a8:	689a      	ldr	r2, [r3, #8]
  2018aa:	f002 020c 	and.w	r2, r2, #12
  2018ae:	2a08      	cmp	r2, #8
  2018b0:	d111      	bne.n	2018d6 <HAL_RCC_OscConfig+0x112>
  2018b2:	685b      	ldr	r3, [r3, #4]
  2018b4:	0259      	lsls	r1, r3, #9
  2018b6:	d40e      	bmi.n	2018d6 <HAL_RCC_OscConfig+0x112>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
  2018b8:	4b64      	ldr	r3, [pc, #400]	; (201a4c <HAL_RCC_OscConfig+0x288>)
  2018ba:	681a      	ldr	r2, [r3, #0]
  2018bc:	0792      	lsls	r2, r2, #30
  2018be:	d502      	bpl.n	2018c6 <HAL_RCC_OscConfig+0x102>
  2018c0:	68e2      	ldr	r2, [r4, #12]
  2018c2:	2a01      	cmp	r2, #1
  2018c4:	d182      	bne.n	2017cc <HAL_RCC_OscConfig+0x8>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
  2018c6:	681a      	ldr	r2, [r3, #0]
  2018c8:	6921      	ldr	r1, [r4, #16]
  2018ca:	f022 02f8 	bic.w	r2, r2, #248	; 0xf8
  2018ce:	ea42 02c1 	orr.w	r2, r2, r1, lsl #3
  2018d2:	601a      	str	r2, [r3, #0]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
  2018d4:	e784      	b.n	2017e0 <HAL_RCC_OscConfig+0x1c>
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
  2018d6:	68e3      	ldr	r3, [r4, #12]
  2018d8:	4d5c      	ldr	r5, [pc, #368]	; (201a4c <HAL_RCC_OscConfig+0x288>)
  2018da:	b1bb      	cbz	r3, 20190c <HAL_RCC_OscConfig+0x148>
        __HAL_RCC_HSI_ENABLE();
  2018dc:	682b      	ldr	r3, [r5, #0]
  2018de:	f043 0301 	orr.w	r3, r3, #1
  2018e2:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
  2018e4:	f7ff f8d8 	bl	200a98 <HAL_GetTick>
  2018e8:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
  2018ea:	682b      	ldr	r3, [r5, #0]
  2018ec:	079f      	lsls	r7, r3, #30
  2018ee:	d507      	bpl.n	201900 <HAL_RCC_OscConfig+0x13c>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
  2018f0:	682b      	ldr	r3, [r5, #0]
  2018f2:	6922      	ldr	r2, [r4, #16]
  2018f4:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
  2018f8:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
  2018fc:	602b      	str	r3, [r5, #0]
  2018fe:	e76f      	b.n	2017e0 <HAL_RCC_OscConfig+0x1c>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
  201900:	f7ff f8ca 	bl	200a98 <HAL_GetTick>
  201904:	1b80      	subs	r0, r0, r6
  201906:	2802      	cmp	r0, #2
  201908:	d9ef      	bls.n	2018ea <HAL_RCC_OscConfig+0x126>
  20190a:	e7a2      	b.n	201852 <HAL_RCC_OscConfig+0x8e>
        __HAL_RCC_HSI_DISABLE();
  20190c:	682b      	ldr	r3, [r5, #0]
  20190e:	f023 0301 	bic.w	r3, r3, #1
  201912:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
  201914:	f7ff f8c0 	bl	200a98 <HAL_GetTick>
  201918:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
  20191a:	682b      	ldr	r3, [r5, #0]
  20191c:	0798      	lsls	r0, r3, #30
  20191e:	f57f af5f 	bpl.w	2017e0 <HAL_RCC_OscConfig+0x1c>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
  201922:	f7ff f8b9 	bl	200a98 <HAL_GetTick>
  201926:	1b80      	subs	r0, r0, r6
  201928:	2802      	cmp	r0, #2
  20192a:	d9f6      	bls.n	20191a <HAL_RCC_OscConfig+0x156>
  20192c:	e791      	b.n	201852 <HAL_RCC_OscConfig+0x8e>
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
  20192e:	6963      	ldr	r3, [r4, #20]
  201930:	4d46      	ldr	r5, [pc, #280]	; (201a4c <HAL_RCC_OscConfig+0x288>)
  201932:	b183      	cbz	r3, 201956 <HAL_RCC_OscConfig+0x192>
      __HAL_RCC_LSI_ENABLE();
  201934:	6f6b      	ldr	r3, [r5, #116]	; 0x74
  201936:	f043 0301 	orr.w	r3, r3, #1
  20193a:	676b      	str	r3, [r5, #116]	; 0x74
      tickstart = HAL_GetTick();
  20193c:	f7ff f8ac 	bl	200a98 <HAL_GetTick>
  201940:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
  201942:	6f6b      	ldr	r3, [r5, #116]	; 0x74
  201944:	079b      	lsls	r3, r3, #30
  201946:	f53f af4f 	bmi.w	2017e8 <HAL_RCC_OscConfig+0x24>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
  20194a:	f7ff f8a5 	bl	200a98 <HAL_GetTick>
  20194e:	1b80      	subs	r0, r0, r6
  201950:	2802      	cmp	r0, #2
  201952:	d9f6      	bls.n	201942 <HAL_RCC_OscConfig+0x17e>
  201954:	e77d      	b.n	201852 <HAL_RCC_OscConfig+0x8e>
      __HAL_RCC_LSI_DISABLE();
  201956:	6f6b      	ldr	r3, [r5, #116]	; 0x74
  201958:	f023 0301 	bic.w	r3, r3, #1
  20195c:	676b      	str	r3, [r5, #116]	; 0x74
      tickstart = HAL_GetTick();
  20195e:	f7ff f89b 	bl	200a98 <HAL_GetTick>
  201962:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
  201964:	6f6b      	ldr	r3, [r5, #116]	; 0x74
  201966:	079f      	lsls	r7, r3, #30
  201968:	f57f af3e 	bpl.w	2017e8 <HAL_RCC_OscConfig+0x24>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
  20196c:	f7ff f894 	bl	200a98 <HAL_GetTick>
  201970:	1b80      	subs	r0, r0, r6
  201972:	2802      	cmp	r0, #2
  201974:	d9f6      	bls.n	201964 <HAL_RCC_OscConfig+0x1a0>
  201976:	e76c      	b.n	201852 <HAL_RCC_OscConfig+0x8e>
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
  201978:	4b34      	ldr	r3, [pc, #208]	; (201a4c <HAL_RCC_OscConfig+0x288>)
  20197a:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  20197c:	00d0      	lsls	r0, r2, #3
  20197e:	d427      	bmi.n	2019d0 <HAL_RCC_OscConfig+0x20c>
      __HAL_RCC_PWR_CLK_ENABLE();
  201980:	6c1a      	ldr	r2, [r3, #64]	; 0x40
      pwrclkchanged = SET;
  201982:	2601      	movs	r6, #1
      __HAL_RCC_PWR_CLK_ENABLE();
  201984:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
  201988:	641a      	str	r2, [r3, #64]	; 0x40
  20198a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  20198c:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
  201990:	9301      	str	r3, [sp, #4]
  201992:	9b01      	ldr	r3, [sp, #4]
    if(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
  201994:	4d2e      	ldr	r5, [pc, #184]	; (201a50 <HAL_RCC_OscConfig+0x28c>)
  201996:	682b      	ldr	r3, [r5, #0]
  201998:	05d9      	lsls	r1, r3, #23
  20199a:	d51b      	bpl.n	2019d4 <HAL_RCC_OscConfig+0x210>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
  20199c:	68a3      	ldr	r3, [r4, #8]
  20199e:	4d2b      	ldr	r5, [pc, #172]	; (201a4c <HAL_RCC_OscConfig+0x288>)
  2019a0:	2b01      	cmp	r3, #1
  2019a2:	d127      	bne.n	2019f4 <HAL_RCC_OscConfig+0x230>
  2019a4:	6f2b      	ldr	r3, [r5, #112]	; 0x70
  2019a6:	f043 0301 	orr.w	r3, r3, #1
  2019aa:	672b      	str	r3, [r5, #112]	; 0x70
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
  2019ac:	f241 3588 	movw	r5, #5000	; 0x1388
      tickstart = HAL_GetTick();
  2019b0:	f7ff f872 	bl	200a98 <HAL_GetTick>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
  2019b4:	4f25      	ldr	r7, [pc, #148]	; (201a4c <HAL_RCC_OscConfig+0x288>)
      tickstart = HAL_GetTick();
  2019b6:	4680      	mov	r8, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
  2019b8:	6f3b      	ldr	r3, [r7, #112]	; 0x70
  2019ba:	079b      	lsls	r3, r3, #30
  2019bc:	d53f      	bpl.n	201a3e <HAL_RCC_OscConfig+0x27a>
    if(pwrclkchanged == SET)
  2019be:	2e00      	cmp	r6, #0
  2019c0:	f43f af16 	beq.w	2017f0 <HAL_RCC_OscConfig+0x2c>
      __HAL_RCC_PWR_CLK_DISABLE();
  2019c4:	4a21      	ldr	r2, [pc, #132]	; (201a4c <HAL_RCC_OscConfig+0x288>)
  2019c6:	6c13      	ldr	r3, [r2, #64]	; 0x40
  2019c8:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
  2019cc:	6413      	str	r3, [r2, #64]	; 0x40
  2019ce:	e70f      	b.n	2017f0 <HAL_RCC_OscConfig+0x2c>
  FlagStatus pwrclkchanged = RESET;
  2019d0:	2600      	movs	r6, #0
  2019d2:	e7df      	b.n	201994 <HAL_RCC_OscConfig+0x1d0>
      PWR->CR1 |= PWR_CR1_DBP;
  2019d4:	682b      	ldr	r3, [r5, #0]
  2019d6:	f443 7380 	orr.w	r3, r3, #256	; 0x100
  2019da:	602b      	str	r3, [r5, #0]
      tickstart = HAL_GetTick();
  2019dc:	f7ff f85c 	bl	200a98 <HAL_GetTick>
  2019e0:	4607      	mov	r7, r0
      while(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
  2019e2:	682b      	ldr	r3, [r5, #0]
  2019e4:	05da      	lsls	r2, r3, #23
  2019e6:	d4d9      	bmi.n	20199c <HAL_RCC_OscConfig+0x1d8>
        if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
  2019e8:	f7ff f856 	bl	200a98 <HAL_GetTick>
  2019ec:	1bc0      	subs	r0, r0, r7
  2019ee:	2864      	cmp	r0, #100	; 0x64
  2019f0:	d9f7      	bls.n	2019e2 <HAL_RCC_OscConfig+0x21e>
  2019f2:	e72e      	b.n	201852 <HAL_RCC_OscConfig+0x8e>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
  2019f4:	b9ab      	cbnz	r3, 201a22 <HAL_RCC_OscConfig+0x25e>
  2019f6:	6f2b      	ldr	r3, [r5, #112]	; 0x70
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
  2019f8:	f241 3888 	movw	r8, #5000	; 0x1388
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
  2019fc:	f023 0301 	bic.w	r3, r3, #1
  201a00:	672b      	str	r3, [r5, #112]	; 0x70
  201a02:	6f2b      	ldr	r3, [r5, #112]	; 0x70
  201a04:	f023 0304 	bic.w	r3, r3, #4
  201a08:	672b      	str	r3, [r5, #112]	; 0x70
      tickstart = HAL_GetTick();
  201a0a:	f7ff f845 	bl	200a98 <HAL_GetTick>
  201a0e:	4607      	mov	r7, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
  201a10:	6f2b      	ldr	r3, [r5, #112]	; 0x70
  201a12:	0798      	lsls	r0, r3, #30
  201a14:	d5d3      	bpl.n	2019be <HAL_RCC_OscConfig+0x1fa>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
  201a16:	f7ff f83f 	bl	200a98 <HAL_GetTick>
  201a1a:	1bc0      	subs	r0, r0, r7
  201a1c:	4540      	cmp	r0, r8
  201a1e:	d9f7      	bls.n	201a10 <HAL_RCC_OscConfig+0x24c>
  201a20:	e717      	b.n	201852 <HAL_RCC_OscConfig+0x8e>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
  201a22:	2b05      	cmp	r3, #5
  201a24:	6f2b      	ldr	r3, [r5, #112]	; 0x70
  201a26:	d103      	bne.n	201a30 <HAL_RCC_OscConfig+0x26c>
  201a28:	f043 0304 	orr.w	r3, r3, #4
  201a2c:	672b      	str	r3, [r5, #112]	; 0x70
  201a2e:	e7b9      	b.n	2019a4 <HAL_RCC_OscConfig+0x1e0>
  201a30:	f023 0301 	bic.w	r3, r3, #1
  201a34:	672b      	str	r3, [r5, #112]	; 0x70
  201a36:	6f2b      	ldr	r3, [r5, #112]	; 0x70
  201a38:	f023 0304 	bic.w	r3, r3, #4
  201a3c:	e7b5      	b.n	2019aa <HAL_RCC_OscConfig+0x1e6>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
  201a3e:	f7ff f82b 	bl	200a98 <HAL_GetTick>
  201a42:	eba0 0008 	sub.w	r0, r0, r8
  201a46:	42a8      	cmp	r0, r5
  201a48:	d9b6      	bls.n	2019b8 <HAL_RCC_OscConfig+0x1f4>
  201a4a:	e702      	b.n	201852 <HAL_RCC_OscConfig+0x8e>
  201a4c:	40023800 	.word	0x40023800
  201a50:	40007000 	.word	0x40007000
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
  201a54:	4d24      	ldr	r5, [pc, #144]	; (201ae8 <HAL_RCC_OscConfig+0x324>)
  201a56:	68ab      	ldr	r3, [r5, #8]
  201a58:	f003 030c 	and.w	r3, r3, #12
  201a5c:	2b08      	cmp	r3, #8
  201a5e:	f43f aeb5 	beq.w	2017cc <HAL_RCC_OscConfig+0x8>
        __HAL_RCC_PLL_DISABLE();
  201a62:	682b      	ldr	r3, [r5, #0]
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
  201a64:	2a02      	cmp	r2, #2
        __HAL_RCC_PLL_DISABLE();
  201a66:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
  201a6a:	602b      	str	r3, [r5, #0]
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
  201a6c:	d12e      	bne.n	201acc <HAL_RCC_OscConfig+0x308>
        tickstart = HAL_GetTick();
  201a6e:	f7ff f813 	bl	200a98 <HAL_GetTick>
  201a72:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
  201a74:	682b      	ldr	r3, [r5, #0]
  201a76:	0199      	lsls	r1, r3, #6
  201a78:	d422      	bmi.n	201ac0 <HAL_RCC_OscConfig+0x2fc>
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
  201a7a:	6a22      	ldr	r2, [r4, #32]
  201a7c:	69e3      	ldr	r3, [r4, #28]
  201a7e:	4313      	orrs	r3, r2
  201a80:	6a62      	ldr	r2, [r4, #36]	; 0x24
  201a82:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
  201a86:	ea43 1382 	orr.w	r3, r3, r2, lsl #6
  201a8a:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  201a8c:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
  201a90:	6aa2      	ldr	r2, [r4, #40]	; 0x28
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
  201a92:	4c15      	ldr	r4, [pc, #84]	; (201ae8 <HAL_RCC_OscConfig+0x324>)
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
  201a94:	0852      	lsrs	r2, r2, #1
  201a96:	3a01      	subs	r2, #1
  201a98:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  201a9c:	606b      	str	r3, [r5, #4]
        __HAL_RCC_PLL_ENABLE();
  201a9e:	682b      	ldr	r3, [r5, #0]
  201aa0:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
  201aa4:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
  201aa6:	f7fe fff7 	bl	200a98 <HAL_GetTick>
  201aaa:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
  201aac:	6823      	ldr	r3, [r4, #0]
  201aae:	019a      	lsls	r2, r3, #6
  201ab0:	f53f aea2 	bmi.w	2017f8 <HAL_RCC_OscConfig+0x34>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
  201ab4:	f7fe fff0 	bl	200a98 <HAL_GetTick>
  201ab8:	1b40      	subs	r0, r0, r5
  201aba:	2802      	cmp	r0, #2
  201abc:	d9f6      	bls.n	201aac <HAL_RCC_OscConfig+0x2e8>
  201abe:	e6c8      	b.n	201852 <HAL_RCC_OscConfig+0x8e>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
  201ac0:	f7fe ffea 	bl	200a98 <HAL_GetTick>
  201ac4:	1b80      	subs	r0, r0, r6
  201ac6:	2802      	cmp	r0, #2
  201ac8:	d9d4      	bls.n	201a74 <HAL_RCC_OscConfig+0x2b0>
  201aca:	e6c2      	b.n	201852 <HAL_RCC_OscConfig+0x8e>
        tickstart = HAL_GetTick();
  201acc:	f7fe ffe4 	bl	200a98 <HAL_GetTick>
  201ad0:	4604      	mov	r4, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
  201ad2:	682b      	ldr	r3, [r5, #0]
  201ad4:	019b      	lsls	r3, r3, #6
  201ad6:	f57f ae8f 	bpl.w	2017f8 <HAL_RCC_OscConfig+0x34>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
  201ada:	f7fe ffdd 	bl	200a98 <HAL_GetTick>
  201ade:	1b00      	subs	r0, r0, r4
  201ae0:	2802      	cmp	r0, #2
  201ae2:	d9f6      	bls.n	201ad2 <HAL_RCC_OscConfig+0x30e>
  201ae4:	e6b5      	b.n	201852 <HAL_RCC_OscConfig+0x8e>
  201ae6:	bf00      	nop
  201ae8:	40023800 	.word	0x40023800

00201aec <HAL_RCC_GetSysClockFreq>:
{
  uint32_t pllm = 0, pllvco = 0, pllp = 0;
  uint32_t sysclockfreq = 0;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
  201aec:	4b11      	ldr	r3, [pc, #68]	; (201b34 <HAL_RCC_GetSysClockFreq+0x48>)
  201aee:	689a      	ldr	r2, [r3, #8]
  201af0:	f002 020c 	and.w	r2, r2, #12
  201af4:	2a04      	cmp	r2, #4
  201af6:	d003      	beq.n	201b00 <HAL_RCC_GetSysClockFreq+0x14>
  201af8:	2a08      	cmp	r2, #8
  201afa:	d003      	beq.n	201b04 <HAL_RCC_GetSysClockFreq+0x18>
  {
    case RCC_SYSCLKSOURCE_STATUS_HSI:  /* HSI used as system clock source */
    {
      sysclockfreq = HSI_VALUE;
  201afc:	480e      	ldr	r0, [pc, #56]	; (201b38 <HAL_RCC_GetSysClockFreq+0x4c>)
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
}
  201afe:	4770      	bx	lr
      sysclockfreq = HSE_VALUE;
  201b00:	480e      	ldr	r0, [pc, #56]	; (201b3c <HAL_RCC_GetSysClockFreq+0x50>)
  201b02:	4770      	bx	lr
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
  201b04:	685a      	ldr	r2, [r3, #4]
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLCFGR_PLLSRC_HSI)
  201b06:	6859      	ldr	r1, [r3, #4]
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
  201b08:	f002 023f 	and.w	r2, r2, #63	; 0x3f
        pllvco = ((HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos));
  201b0c:	685b      	ldr	r3, [r3, #4]
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLCFGR_PLLSRC_HSI)
  201b0e:	0249      	lsls	r1, r1, #9
        pllvco = ((HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos));
  201b10:	f3c3 1388 	ubfx	r3, r3, #6, #9
  201b14:	bf4c      	ite	mi
  201b16:	4809      	ldrmi	r0, [pc, #36]	; (201b3c <HAL_RCC_GetSysClockFreq+0x50>)
        pllvco = ((HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos));
  201b18:	4807      	ldrpl	r0, [pc, #28]	; (201b38 <HAL_RCC_GetSysClockFreq+0x4c>)
  201b1a:	fbb0 f0f2 	udiv	r0, r0, r2
  201b1e:	4358      	muls	r0, r3
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1 ) *2);
  201b20:	4b04      	ldr	r3, [pc, #16]	; (201b34 <HAL_RCC_GetSysClockFreq+0x48>)
  201b22:	685b      	ldr	r3, [r3, #4]
  201b24:	f3c3 4301 	ubfx	r3, r3, #16, #2
  201b28:	3301      	adds	r3, #1
  201b2a:	005b      	lsls	r3, r3, #1
      sysclockfreq = pllvco/pllp;
  201b2c:	fbb0 f0f3 	udiv	r0, r0, r3
  201b30:	4770      	bx	lr
  201b32:	bf00      	nop
  201b34:	40023800 	.word	0x40023800
  201b38:	00f42400 	.word	0x00f42400
  201b3c:	007a1200 	.word	0x007a1200

00201b40 <HAL_RCC_ClockConfig>:
{
  201b40:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  201b44:	460d      	mov	r5, r1
  if(RCC_ClkInitStruct == NULL)
  201b46:	4604      	mov	r4, r0
  201b48:	b910      	cbnz	r0, 201b50 <HAL_RCC_ClockConfig+0x10>
    return HAL_ERROR;
  201b4a:	2001      	movs	r0, #1
  201b4c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if(FLatency > __HAL_FLASH_GET_LATENCY())
  201b50:	4a3f      	ldr	r2, [pc, #252]	; (201c50 <HAL_RCC_ClockConfig+0x110>)
  201b52:	6813      	ldr	r3, [r2, #0]
  201b54:	f003 030f 	and.w	r3, r3, #15
  201b58:	428b      	cmp	r3, r1
  201b5a:	d328      	bcc.n	201bae <HAL_RCC_ClockConfig+0x6e>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
  201b5c:	6822      	ldr	r2, [r4, #0]
  201b5e:	0796      	lsls	r6, r2, #30
  201b60:	d430      	bmi.n	201bc4 <HAL_RCC_ClockConfig+0x84>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
  201b62:	07d0      	lsls	r0, r2, #31
  201b64:	d436      	bmi.n	201bd4 <HAL_RCC_ClockConfig+0x94>
  if(FLatency < __HAL_FLASH_GET_LATENCY())
  201b66:	4a3a      	ldr	r2, [pc, #232]	; (201c50 <HAL_RCC_ClockConfig+0x110>)
  201b68:	6813      	ldr	r3, [r2, #0]
  201b6a:	f003 030f 	and.w	r3, r3, #15
  201b6e:	429d      	cmp	r5, r3
  201b70:	d35a      	bcc.n	201c28 <HAL_RCC_ClockConfig+0xe8>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
  201b72:	6822      	ldr	r2, [r4, #0]
  201b74:	0751      	lsls	r1, r2, #29
  201b76:	d462      	bmi.n	201c3e <HAL_RCC_ClockConfig+0xfe>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
  201b78:	0713      	lsls	r3, r2, #28
  201b7a:	d507      	bpl.n	201b8c <HAL_RCC_ClockConfig+0x4c>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
  201b7c:	4a35      	ldr	r2, [pc, #212]	; (201c54 <HAL_RCC_ClockConfig+0x114>)
  201b7e:	6921      	ldr	r1, [r4, #16]
  201b80:	6893      	ldr	r3, [r2, #8]
  201b82:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
  201b86:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
  201b8a:	6093      	str	r3, [r2, #8]
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
  201b8c:	f7ff ffae 	bl	201aec <HAL_RCC_GetSysClockFreq>
  201b90:	4b30      	ldr	r3, [pc, #192]	; (201c54 <HAL_RCC_ClockConfig+0x114>)
  201b92:	4a31      	ldr	r2, [pc, #196]	; (201c58 <HAL_RCC_ClockConfig+0x118>)
  201b94:	689b      	ldr	r3, [r3, #8]
  201b96:	f3c3 1303 	ubfx	r3, r3, #4, #4
  201b9a:	5cd3      	ldrb	r3, [r2, r3]
  201b9c:	40d8      	lsrs	r0, r3
  201b9e:	4b2f      	ldr	r3, [pc, #188]	; (201c5c <HAL_RCC_ClockConfig+0x11c>)
  201ba0:	6018      	str	r0, [r3, #0]
  HAL_InitTick (TICK_INT_PRIORITY);
  201ba2:	2000      	movs	r0, #0
  201ba4:	f7fe ff4a 	bl	200a3c <HAL_InitTick>
  return HAL_OK;
  201ba8:	2000      	movs	r0, #0
  201baa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    __HAL_FLASH_SET_LATENCY(FLatency);
  201bae:	6813      	ldr	r3, [r2, #0]
  201bb0:	f023 030f 	bic.w	r3, r3, #15
  201bb4:	430b      	orrs	r3, r1
  201bb6:	6013      	str	r3, [r2, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
  201bb8:	6813      	ldr	r3, [r2, #0]
  201bba:	f003 030f 	and.w	r3, r3, #15
  201bbe:	4299      	cmp	r1, r3
  201bc0:	d1c3      	bne.n	201b4a <HAL_RCC_ClockConfig+0xa>
  201bc2:	e7cb      	b.n	201b5c <HAL_RCC_ClockConfig+0x1c>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
  201bc4:	4923      	ldr	r1, [pc, #140]	; (201c54 <HAL_RCC_ClockConfig+0x114>)
  201bc6:	68a0      	ldr	r0, [r4, #8]
  201bc8:	688b      	ldr	r3, [r1, #8]
  201bca:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
  201bce:	4303      	orrs	r3, r0
  201bd0:	608b      	str	r3, [r1, #8]
  201bd2:	e7c6      	b.n	201b62 <HAL_RCC_ClockConfig+0x22>
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
  201bd4:	6861      	ldr	r1, [r4, #4]
  201bd6:	4b1f      	ldr	r3, [pc, #124]	; (201c54 <HAL_RCC_ClockConfig+0x114>)
  201bd8:	2901      	cmp	r1, #1
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
  201bda:	681a      	ldr	r2, [r3, #0]
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
  201bdc:	d11c      	bne.n	201c18 <HAL_RCC_ClockConfig+0xd8>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
  201bde:	f412 3f00 	tst.w	r2, #131072	; 0x20000
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
  201be2:	d0b2      	beq.n	201b4a <HAL_RCC_ClockConfig+0xa>
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
  201be4:	689a      	ldr	r2, [r3, #8]
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
  201be6:	f241 3888 	movw	r8, #5000	; 0x1388
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
  201bea:	4e1a      	ldr	r6, [pc, #104]	; (201c54 <HAL_RCC_ClockConfig+0x114>)
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
  201bec:	f022 0203 	bic.w	r2, r2, #3
  201bf0:	430a      	orrs	r2, r1
  201bf2:	609a      	str	r2, [r3, #8]
    tickstart = HAL_GetTick();
  201bf4:	f7fe ff50 	bl	200a98 <HAL_GetTick>
  201bf8:	4607      	mov	r7, r0
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
  201bfa:	68b3      	ldr	r3, [r6, #8]
  201bfc:	6862      	ldr	r2, [r4, #4]
  201bfe:	f003 030c 	and.w	r3, r3, #12
  201c02:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
  201c06:	d0ae      	beq.n	201b66 <HAL_RCC_ClockConfig+0x26>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
  201c08:	f7fe ff46 	bl	200a98 <HAL_GetTick>
  201c0c:	1bc0      	subs	r0, r0, r7
  201c0e:	4540      	cmp	r0, r8
  201c10:	d9f3      	bls.n	201bfa <HAL_RCC_ClockConfig+0xba>
        return HAL_TIMEOUT;
  201c12:	2003      	movs	r0, #3
}
  201c14:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
  201c18:	2902      	cmp	r1, #2
  201c1a:	d102      	bne.n	201c22 <HAL_RCC_ClockConfig+0xe2>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
  201c1c:	f012 7f00 	tst.w	r2, #33554432	; 0x2000000
  201c20:	e7df      	b.n	201be2 <HAL_RCC_ClockConfig+0xa2>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
  201c22:	f012 0f02 	tst.w	r2, #2
  201c26:	e7dc      	b.n	201be2 <HAL_RCC_ClockConfig+0xa2>
    __HAL_FLASH_SET_LATENCY(FLatency);
  201c28:	6813      	ldr	r3, [r2, #0]
  201c2a:	f023 030f 	bic.w	r3, r3, #15
  201c2e:	432b      	orrs	r3, r5
  201c30:	6013      	str	r3, [r2, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
  201c32:	6813      	ldr	r3, [r2, #0]
  201c34:	f003 030f 	and.w	r3, r3, #15
  201c38:	429d      	cmp	r5, r3
  201c3a:	d186      	bne.n	201b4a <HAL_RCC_ClockConfig+0xa>
  201c3c:	e799      	b.n	201b72 <HAL_RCC_ClockConfig+0x32>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
  201c3e:	4905      	ldr	r1, [pc, #20]	; (201c54 <HAL_RCC_ClockConfig+0x114>)
  201c40:	68e0      	ldr	r0, [r4, #12]
  201c42:	688b      	ldr	r3, [r1, #8]
  201c44:	f423 53e0 	bic.w	r3, r3, #7168	; 0x1c00
  201c48:	4303      	orrs	r3, r0
  201c4a:	608b      	str	r3, [r1, #8]
  201c4c:	e794      	b.n	201b78 <HAL_RCC_ClockConfig+0x38>
  201c4e:	bf00      	nop
  201c50:	40023c00 	.word	0x40023c00
  201c54:	40023800 	.word	0x40023800
  201c58:	00207874 	.word	0x00207874
  201c5c:	20000014 	.word	0x20000014

00201c60 <HAL_RCC_GetHCLKFreq>:
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
  return SystemCoreClock;
}
  201c60:	4b01      	ldr	r3, [pc, #4]	; (201c68 <HAL_RCC_GetHCLKFreq+0x8>)
  201c62:	6818      	ldr	r0, [r3, #0]
  201c64:	4770      	bx	lr
  201c66:	bf00      	nop
  201c68:	20000014 	.word	0x20000014

00201c6c <HAL_RCC_GetPCLK1Freq>:
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{  
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> RCC_CFGR_PPRE1_Pos]);
  201c6c:	4b04      	ldr	r3, [pc, #16]	; (201c80 <HAL_RCC_GetPCLK1Freq+0x14>)
  201c6e:	4a05      	ldr	r2, [pc, #20]	; (201c84 <HAL_RCC_GetPCLK1Freq+0x18>)
  201c70:	689b      	ldr	r3, [r3, #8]
  201c72:	f3c3 2382 	ubfx	r3, r3, #10, #3
  201c76:	5cd3      	ldrb	r3, [r2, r3]
  201c78:	4a03      	ldr	r2, [pc, #12]	; (201c88 <HAL_RCC_GetPCLK1Freq+0x1c>)
  201c7a:	6810      	ldr	r0, [r2, #0]
}
  201c7c:	40d8      	lsrs	r0, r3
  201c7e:	4770      	bx	lr
  201c80:	40023800 	.word	0x40023800
  201c84:	00207884 	.word	0x00207884
  201c88:	20000014 	.word	0x20000014

00201c8c <HAL_RCC_GetPCLK2Freq>:
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> RCC_CFGR_PPRE2_Pos]);
  201c8c:	4b04      	ldr	r3, [pc, #16]	; (201ca0 <HAL_RCC_GetPCLK2Freq+0x14>)
  201c8e:	4a05      	ldr	r2, [pc, #20]	; (201ca4 <HAL_RCC_GetPCLK2Freq+0x18>)
  201c90:	689b      	ldr	r3, [r3, #8]
  201c92:	f3c3 3342 	ubfx	r3, r3, #13, #3
  201c96:	5cd3      	ldrb	r3, [r2, r3]
  201c98:	4a03      	ldr	r2, [pc, #12]	; (201ca8 <HAL_RCC_GetPCLK2Freq+0x1c>)
  201c9a:	6810      	ldr	r0, [r2, #0]
} 
  201c9c:	40d8      	lsrs	r0, r3
  201c9e:	4770      	bx	lr
  201ca0:	40023800 	.word	0x40023800
  201ca4:	00207884 	.word	0x00207884
  201ca8:	20000014 	.word	0x20000014

00201cac <HAL_RCCEx_PeriphCLKConfig>:
  *         the backup registers) are set to their reset values.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
  201cac:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    
  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));
  
  /*----------------------------------- I2S configuration ----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == (RCC_PERIPHCLK_I2S))
  201cb0:	6802      	ldr	r2, [r0, #0]
{
  201cb2:	4604      	mov	r4, r0
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == (RCC_PERIPHCLK_I2S))
  201cb4:	f012 0601 	ands.w	r6, r2, #1
  201cb8:	d00b      	beq.n	201cd2 <HAL_RCCEx_PeriphCLKConfig+0x26>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2SCLKSOURCE(PeriphClkInit->I2sClockSelection));
    
    /* Configure I2S Clock source */
    __HAL_RCC_I2S_CONFIG(PeriphClkInit->I2sClockSelection);
  201cba:	4bb8      	ldr	r3, [pc, #736]	; (201f9c <HAL_RCCEx_PeriphCLKConfig+0x2f0>)
  201cbc:	6899      	ldr	r1, [r3, #8]
  201cbe:	f421 0100 	bic.w	r1, r1, #8388608	; 0x800000
  201cc2:	6099      	str	r1, [r3, #8]
  201cc4:	6b46      	ldr	r6, [r0, #52]	; 0x34
  201cc6:	6899      	ldr	r1, [r3, #8]
  201cc8:	4331      	orrs	r1, r6
    
    /* Enable the PLLI2S when it's used as clock source for I2S */
    if(PeriphClkInit->I2sClockSelection == RCC_I2SCLKSOURCE_PLLI2S)
  201cca:	fab6 f686 	clz	r6, r6
  201cce:	0976      	lsrs	r6, r6, #5
    __HAL_RCC_I2S_CONFIG(PeriphClkInit->I2sClockSelection);
  201cd0:	6099      	str	r1, [r3, #8]
      plli2sused = 1; 
    }
  }
  
  /*------------------------------------ SAI1 configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == (RCC_PERIPHCLK_SAI1))
  201cd2:	f412 2500 	ands.w	r5, r2, #524288	; 0x80000
  201cd6:	d012      	beq.n	201cfe <HAL_RCCEx_PeriphCLKConfig+0x52>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI1CLKSOURCE(PeriphClkInit->Sai1ClockSelection));
    
    /* Configure SAI1 Clock source */
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
  201cd8:	49b0      	ldr	r1, [pc, #704]	; (201f9c <HAL_RCCEx_PeriphCLKConfig+0x2f0>)
  201cda:	6be5      	ldr	r5, [r4, #60]	; 0x3c
  201cdc:	f8d1 308c 	ldr.w	r3, [r1, #140]	; 0x8c
    /* Enable the PLLI2S when it's used as clock source for SAI */
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)
  201ce0:	f5b5 1f80 	cmp.w	r5, #1048576	; 0x100000
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
  201ce4:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
    {
      plli2sused = 1; 
  201ce8:	bf08      	it	eq
  201cea:	2601      	moveq	r6, #1
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
  201cec:	ea43 0305 	orr.w	r3, r3, r5
    }
    /* Enable the PLLSAI when it's used as clock source for SAI */
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)
  201cf0:	bf16      	itet	ne
  201cf2:	fab5 f585 	clzne	r5, r5
  uint32_t pllsaiused = 0;
  201cf6:	2500      	moveq	r5, #0
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)
  201cf8:	096d      	lsrne	r5, r5, #5
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
  201cfa:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
      pllsaiused = 1; 
    }
  }
  
  /*------------------------------------ SAI2 configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == (RCC_PERIPHCLK_SAI2))
  201cfe:	02d1      	lsls	r1, r2, #11
  201d00:	d510      	bpl.n	201d24 <HAL_RCCEx_PeriphCLKConfig+0x78>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI2CLKSOURCE(PeriphClkInit->Sai2ClockSelection));
    
    /* Configure SAI2 Clock source */
    __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
  201d02:	48a6      	ldr	r0, [pc, #664]	; (201f9c <HAL_RCCEx_PeriphCLKConfig+0x2f0>)
  201d04:	6c21      	ldr	r1, [r4, #64]	; 0x40
  201d06:	f8d0 308c 	ldr.w	r3, [r0, #140]	; 0x8c
    
    /* Enable the PLLI2S when it's used as clock source for SAI */
    if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)
  201d0a:	f5b1 0f80 	cmp.w	r1, #4194304	; 0x400000
    __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
  201d0e:	f423 0340 	bic.w	r3, r3, #12582912	; 0xc00000
  201d12:	ea43 0301 	orr.w	r3, r3, r1
  201d16:	f8c0 308c 	str.w	r3, [r0, #140]	; 0x8c
    if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)
  201d1a:	f000 8185 	beq.w	202028 <HAL_RCCEx_PeriphCLKConfig+0x37c>
      plli2sused = 1; 
    }
    /* Enable the PLLSAI when it's used as clock source for SAI */
    if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLSAI)
    {
      pllsaiused = 1; 
  201d1e:	2900      	cmp	r1, #0
  201d20:	bf08      	it	eq
  201d22:	2501      	moveq	r5, #1
  }
  
  /*-------------------------------------- SPDIF-RX Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
  {    
      plli2sused = 1; 
  201d24:	f012 7f80 	tst.w	r2, #16777216	; 0x1000000
  201d28:	bf18      	it	ne
  201d2a:	2601      	movne	r6, #1
  }  
  
  /*------------------------------------ RTC configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
  201d2c:	0692      	lsls	r2, r2, #26
  201d2e:	d531      	bpl.n	201d94 <HAL_RCCEx_PeriphCLKConfig+0xe8>
  {
    /* Check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));
    
    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
  201d30:	4b9a      	ldr	r3, [pc, #616]	; (201f9c <HAL_RCCEx_PeriphCLKConfig+0x2f0>)
    
    /* Enable write access to Backup domain */
    PWR->CR1 |= PWR_CR1_DBP;
  201d32:	4f9b      	ldr	r7, [pc, #620]	; (201fa0 <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
    __HAL_RCC_PWR_CLK_ENABLE();
  201d34:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  201d36:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
  201d3a:	641a      	str	r2, [r3, #64]	; 0x40
  201d3c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  201d3e:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
  201d42:	9301      	str	r3, [sp, #4]
  201d44:	9b01      	ldr	r3, [sp, #4]
    PWR->CR1 |= PWR_CR1_DBP;
  201d46:	683b      	ldr	r3, [r7, #0]
  201d48:	f443 7380 	orr.w	r3, r3, #256	; 0x100
  201d4c:	603b      	str	r3, [r7, #0]
    
    /* Get Start Tick*/
    tickstart = HAL_GetTick();
  201d4e:	f7fe fea3 	bl	200a98 <HAL_GetTick>
  201d52:	4680      	mov	r8, r0
    
    /* Wait for Backup domain Write protection disable */
    while((PWR->CR1 & PWR_CR1_DBP) == RESET)
  201d54:	683b      	ldr	r3, [r7, #0]
  201d56:	05db      	lsls	r3, r3, #23
  201d58:	f140 8168 	bpl.w	20202c <HAL_RCCEx_PeriphCLKConfig+0x380>
        return HAL_TIMEOUT;
      }
    }

    /* Reset the Backup domain only if the RTC Clock source selection is modified */
    tmpreg0 = (RCC->BDCR & RCC_BDCR_RTCSEL);
  201d5c:	4f8f      	ldr	r7, [pc, #572]	; (201f9c <HAL_RCCEx_PeriphCLKConfig+0x2f0>)
  201d5e:	6f3b      	ldr	r3, [r7, #112]	; 0x70

    if((tmpreg0 != 0x00000000U) && (tmpreg0 != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
  201d60:	f413 7340 	ands.w	r3, r3, #768	; 0x300
  201d64:	f040 816d 	bne.w	202042 <HAL_RCCEx_PeriphCLKConfig+0x396>
            return HAL_TIMEOUT;
          }
        }
      }
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
  201d68:	6b23      	ldr	r3, [r4, #48]	; 0x30
  201d6a:	f403 7240 	and.w	r2, r3, #768	; 0x300
  201d6e:	f5b2 7f40 	cmp.w	r2, #768	; 0x300
  201d72:	4a8a      	ldr	r2, [pc, #552]	; (201f9c <HAL_RCCEx_PeriphCLKConfig+0x2f0>)
  201d74:	f040 818b 	bne.w	20208e <HAL_RCCEx_PeriphCLKConfig+0x3e2>
  201d78:	6891      	ldr	r1, [r2, #8]
  201d7a:	f023 4070 	bic.w	r0, r3, #4026531840	; 0xf0000000
  201d7e:	f421 11f8 	bic.w	r1, r1, #2031616	; 0x1f0000
  201d82:	f420 7040 	bic.w	r0, r0, #768	; 0x300
  201d86:	4301      	orrs	r1, r0
  201d88:	6091      	str	r1, [r2, #8]
  201d8a:	f3c3 030b 	ubfx	r3, r3, #0, #12
  201d8e:	6f11      	ldr	r1, [r2, #112]	; 0x70
  201d90:	430b      	orrs	r3, r1
  201d92:	6713      	str	r3, [r2, #112]	; 0x70
  }

  /*------------------------------------ TIM configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == (RCC_PERIPHCLK_TIM))
  201d94:	6823      	ldr	r3, [r4, #0]
  201d96:	06da      	lsls	r2, r3, #27
  201d98:	d50c      	bpl.n	201db4 <HAL_RCCEx_PeriphCLKConfig+0x108>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));
    
    /* Configure Timer Prescaler */
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
  201d9a:	4a80      	ldr	r2, [pc, #512]	; (201f9c <HAL_RCCEx_PeriphCLKConfig+0x2f0>)
  201d9c:	f8d2 108c 	ldr.w	r1, [r2, #140]	; 0x8c
  201da0:	f021 7180 	bic.w	r1, r1, #16777216	; 0x1000000
  201da4:	f8c2 108c 	str.w	r1, [r2, #140]	; 0x8c
  201da8:	f8d2 108c 	ldr.w	r1, [r2, #140]	; 0x8c
  201dac:	6ba0      	ldr	r0, [r4, #56]	; 0x38
  201dae:	4301      	orrs	r1, r0
  201db0:	f8c2 108c 	str.w	r1, [r2, #140]	; 0x8c
  }
  
  /*-------------------------------------- I2C1 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
  201db4:	045f      	lsls	r7, r3, #17
  201db6:	d508      	bpl.n	201dca <HAL_RCCEx_PeriphCLKConfig+0x11e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));
    
    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
  201db8:	4978      	ldr	r1, [pc, #480]	; (201f9c <HAL_RCCEx_PeriphCLKConfig+0x2f0>)
  201dba:	6e60      	ldr	r0, [r4, #100]	; 0x64
  201dbc:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
  201dc0:	f422 3240 	bic.w	r2, r2, #196608	; 0x30000
  201dc4:	4302      	orrs	r2, r0
  201dc6:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }
  
  /*-------------------------------------- I2C2 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
  201dca:	0418      	lsls	r0, r3, #16
  201dcc:	d508      	bpl.n	201de0 <HAL_RCCEx_PeriphCLKConfig+0x134>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));
    
    /* Configure the I2C2 clock source */
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
  201dce:	4973      	ldr	r1, [pc, #460]	; (201f9c <HAL_RCCEx_PeriphCLKConfig+0x2f0>)
  201dd0:	6ea0      	ldr	r0, [r4, #104]	; 0x68
  201dd2:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
  201dd6:	f422 2240 	bic.w	r2, r2, #786432	; 0xc0000
  201dda:	4302      	orrs	r2, r0
  201ddc:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }
  
  /*-------------------------------------- I2C3 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
  201de0:	03d9      	lsls	r1, r3, #15
  201de2:	d508      	bpl.n	201df6 <HAL_RCCEx_PeriphCLKConfig+0x14a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));
    
    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
  201de4:	496d      	ldr	r1, [pc, #436]	; (201f9c <HAL_RCCEx_PeriphCLKConfig+0x2f0>)
  201de6:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
  201de8:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
  201dec:	f422 1240 	bic.w	r2, r2, #3145728	; 0x300000
  201df0:	4302      	orrs	r2, r0
  201df2:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }
    
  /*-------------------------------------- I2C4 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
  201df6:	039a      	lsls	r2, r3, #14
  201df8:	d508      	bpl.n	201e0c <HAL_RCCEx_PeriphCLKConfig+0x160>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));
    
    /* Configure the I2C4 clock source */
    __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
  201dfa:	4968      	ldr	r1, [pc, #416]	; (201f9c <HAL_RCCEx_PeriphCLKConfig+0x2f0>)
  201dfc:	6f20      	ldr	r0, [r4, #112]	; 0x70
  201dfe:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
  201e02:	f422 0240 	bic.w	r2, r2, #12582912	; 0xc00000
  201e06:	4302      	orrs	r2, r0
  201e08:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART1 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
  201e0c:	065f      	lsls	r7, r3, #25
  201e0e:	d508      	bpl.n	201e22 <HAL_RCCEx_PeriphCLKConfig+0x176>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));
    
    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
  201e10:	4962      	ldr	r1, [pc, #392]	; (201f9c <HAL_RCCEx_PeriphCLKConfig+0x2f0>)
  201e12:	6c60      	ldr	r0, [r4, #68]	; 0x44
  201e14:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
  201e18:	f022 0203 	bic.w	r2, r2, #3
  201e1c:	4302      	orrs	r2, r0
  201e1e:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART2 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
  201e22:	0618      	lsls	r0, r3, #24
  201e24:	d508      	bpl.n	201e38 <HAL_RCCEx_PeriphCLKConfig+0x18c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));
    
    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
  201e26:	495d      	ldr	r1, [pc, #372]	; (201f9c <HAL_RCCEx_PeriphCLKConfig+0x2f0>)
  201e28:	6ca0      	ldr	r0, [r4, #72]	; 0x48
  201e2a:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
  201e2e:	f022 020c 	bic.w	r2, r2, #12
  201e32:	4302      	orrs	r2, r0
  201e34:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART3 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
  201e38:	05d9      	lsls	r1, r3, #23
  201e3a:	d508      	bpl.n	201e4e <HAL_RCCEx_PeriphCLKConfig+0x1a2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection));
    
    /* Configure the USART3 clock source */
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
  201e3c:	4957      	ldr	r1, [pc, #348]	; (201f9c <HAL_RCCEx_PeriphCLKConfig+0x2f0>)
  201e3e:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
  201e40:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
  201e44:	f022 0230 	bic.w	r2, r2, #48	; 0x30
  201e48:	4302      	orrs	r2, r0
  201e4a:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART4 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
  201e4e:	059a      	lsls	r2, r3, #22
  201e50:	d508      	bpl.n	201e64 <HAL_RCCEx_PeriphCLKConfig+0x1b8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART4CLKSOURCE(PeriphClkInit->Uart4ClockSelection));
    
    /* Configure the UART4 clock source */
    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
  201e52:	4952      	ldr	r1, [pc, #328]	; (201f9c <HAL_RCCEx_PeriphCLKConfig+0x2f0>)
  201e54:	6d20      	ldr	r0, [r4, #80]	; 0x50
  201e56:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
  201e5a:	f022 02c0 	bic.w	r2, r2, #192	; 0xc0
  201e5e:	4302      	orrs	r2, r0
  201e60:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART5 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
  201e64:	055f      	lsls	r7, r3, #21
  201e66:	d508      	bpl.n	201e7a <HAL_RCCEx_PeriphCLKConfig+0x1ce>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART5CLKSOURCE(PeriphClkInit->Uart5ClockSelection));
    
    /* Configure the UART5 clock source */
    __HAL_RCC_UART5_CONFIG(PeriphClkInit->Uart5ClockSelection);
  201e68:	494c      	ldr	r1, [pc, #304]	; (201f9c <HAL_RCCEx_PeriphCLKConfig+0x2f0>)
  201e6a:	6d60      	ldr	r0, [r4, #84]	; 0x54
  201e6c:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
  201e70:	f422 7240 	bic.w	r2, r2, #768	; 0x300
  201e74:	4302      	orrs	r2, r0
  201e76:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART6 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART6) == RCC_PERIPHCLK_USART6)
  201e7a:	0518      	lsls	r0, r3, #20
  201e7c:	d508      	bpl.n	201e90 <HAL_RCCEx_PeriphCLKConfig+0x1e4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART6CLKSOURCE(PeriphClkInit->Usart6ClockSelection));
    
    /* Configure the USART6 clock source */
    __HAL_RCC_USART6_CONFIG(PeriphClkInit->Usart6ClockSelection);
  201e7e:	4947      	ldr	r1, [pc, #284]	; (201f9c <HAL_RCCEx_PeriphCLKConfig+0x2f0>)
  201e80:	6da0      	ldr	r0, [r4, #88]	; 0x58
  201e82:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
  201e86:	f422 6240 	bic.w	r2, r2, #3072	; 0xc00
  201e8a:	4302      	orrs	r2, r0
  201e8c:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART7 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART7) == RCC_PERIPHCLK_UART7)
  201e90:	04d9      	lsls	r1, r3, #19
  201e92:	d508      	bpl.n	201ea6 <HAL_RCCEx_PeriphCLKConfig+0x1fa>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART7CLKSOURCE(PeriphClkInit->Uart7ClockSelection));
    
    /* Configure the UART7 clock source */
    __HAL_RCC_UART7_CONFIG(PeriphClkInit->Uart7ClockSelection);
  201e94:	4941      	ldr	r1, [pc, #260]	; (201f9c <HAL_RCCEx_PeriphCLKConfig+0x2f0>)
  201e96:	6de0      	ldr	r0, [r4, #92]	; 0x5c
  201e98:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
  201e9c:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
  201ea0:	4302      	orrs	r2, r0
  201ea2:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART8 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART8) == RCC_PERIPHCLK_UART8)
  201ea6:	049a      	lsls	r2, r3, #18
  201ea8:	d508      	bpl.n	201ebc <HAL_RCCEx_PeriphCLKConfig+0x210>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART8CLKSOURCE(PeriphClkInit->Uart8ClockSelection));
    
    /* Configure the UART8 clock source */
    __HAL_RCC_UART8_CONFIG(PeriphClkInit->Uart8ClockSelection);
  201eaa:	493c      	ldr	r1, [pc, #240]	; (201f9c <HAL_RCCEx_PeriphCLKConfig+0x2f0>)
  201eac:	6e20      	ldr	r0, [r4, #96]	; 0x60
  201eae:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
  201eb2:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
  201eb6:	4302      	orrs	r2, r0
  201eb8:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }
  
  /*--------------------------------------- CEC Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CEC) == RCC_PERIPHCLK_CEC)
  201ebc:	025f      	lsls	r7, r3, #9
  201ebe:	d508      	bpl.n	201ed2 <HAL_RCCEx_PeriphCLKConfig+0x226>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CECCLKSOURCE(PeriphClkInit->CecClockSelection));
    
    /* Configure the CEC clock source */
    __HAL_RCC_CEC_CONFIG(PeriphClkInit->CecClockSelection);
  201ec0:	4936      	ldr	r1, [pc, #216]	; (201f9c <HAL_RCCEx_PeriphCLKConfig+0x2f0>)
  201ec2:	6fa0      	ldr	r0, [r4, #120]	; 0x78
  201ec4:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
  201ec8:	f022 6280 	bic.w	r2, r2, #67108864	; 0x4000000
  201ecc:	4302      	orrs	r2, r0
  201ece:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }
  
  /*-------------------------------------- CK48 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CLK48) == RCC_PERIPHCLK_CLK48)
  201ed2:	0298      	lsls	r0, r3, #10
  201ed4:	d50c      	bpl.n	201ef0 <HAL_RCCEx_PeriphCLKConfig+0x244>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CLK48SOURCE(PeriphClkInit->Clk48ClockSelection));
    
    /* Configure the CLK48 source */
    __HAL_RCC_CLK48_CONFIG(PeriphClkInit->Clk48ClockSelection);
  201ed6:	4831      	ldr	r0, [pc, #196]	; (201f9c <HAL_RCCEx_PeriphCLKConfig+0x2f0>)
  201ed8:	6fe1      	ldr	r1, [r4, #124]	; 0x7c
  201eda:	f8d0 2090 	ldr.w	r2, [r0, #144]	; 0x90

    /* Enable the PLLSAI when it's used as clock source for CK48 */
    if(PeriphClkInit->Clk48ClockSelection == RCC_CLK48SOURCE_PLLSAIP)
    {
      pllsaiused = 1; 
  201ede:	f1b1 6f00 	cmp.w	r1, #134217728	; 0x8000000
    __HAL_RCC_CLK48_CONFIG(PeriphClkInit->Clk48ClockSelection);
  201ee2:	f022 6200 	bic.w	r2, r2, #134217728	; 0x8000000
      pllsaiused = 1; 
  201ee6:	bf08      	it	eq
  201ee8:	2501      	moveq	r5, #1
    __HAL_RCC_CLK48_CONFIG(PeriphClkInit->Clk48ClockSelection);
  201eea:	430a      	orrs	r2, r1
  201eec:	f8c0 2090 	str.w	r2, [r0, #144]	; 0x90

  /*-------------------------------------- LTDC Configuration -----------------------------------*/
#if defined(STM32F746xx) || defined(STM32F756xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
  {
    pllsaiused = 1; 
  201ef0:	f013 0f08 	tst.w	r3, #8
  201ef4:	bf18      	it	ne
  201ef6:	2501      	movne	r5, #1
  }
#endif /* STM32F746xx || STM32F756xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
  
  /*-------------------------------------- LPTIM1 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
  201ef8:	0359      	lsls	r1, r3, #13
  201efa:	d508      	bpl.n	201f0e <HAL_RCCEx_PeriphCLKConfig+0x262>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM1CLK(PeriphClkInit->Lptim1ClockSelection));
    
    /* Configure the LTPIM1 clock source */
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
  201efc:	4927      	ldr	r1, [pc, #156]	; (201f9c <HAL_RCCEx_PeriphCLKConfig+0x2f0>)
  201efe:	6f60      	ldr	r0, [r4, #116]	; 0x74
  201f00:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
  201f04:	f022 7240 	bic.w	r2, r2, #50331648	; 0x3000000
  201f08:	4302      	orrs	r2, r0
  201f0a:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
   }
  
  /*------------------------------------- SDMMC1 Configuration ------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC1) == RCC_PERIPHCLK_SDMMC1)
  201f0e:	021a      	lsls	r2, r3, #8
  201f10:	d509      	bpl.n	201f26 <HAL_RCCEx_PeriphCLKConfig+0x27a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMC1CLKSOURCE(PeriphClkInit->Sdmmc1ClockSelection));
    
    /* Configure the SDMMC1 clock source */
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
  201f12:	4922      	ldr	r1, [pc, #136]	; (201f9c <HAL_RCCEx_PeriphCLKConfig+0x2f0>)
  201f14:	f8d4 0080 	ldr.w	r0, [r4, #128]	; 0x80
  201f18:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
  201f1c:	f022 5280 	bic.w	r2, r2, #268435456	; 0x10000000
  201f20:	4302      	orrs	r2, r0
  201f22:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }  
#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
  
  /*-------------------------------------- PLLI2S Configuration ---------------------------------*/
  /* PLLI2S is configured when a peripheral will use it as source clock : SAI1, SAI2, I2S or SPDIF-RX */
  if((plli2sused == 1) || (PeriphClkInit->PeriphClockSelection == RCC_PERIPHCLK_PLLI2S))
  201f26:	2e01      	cmp	r6, #1
  201f28:	f000 80b5 	beq.w	202096 <HAL_RCCEx_PeriphCLKConfig+0x3ea>
  201f2c:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
  201f30:	f000 80b1 	beq.w	202096 <HAL_RCCEx_PeriphCLKConfig+0x3ea>
    }
  } 
  
  /*-------------------------------------- PLLSAI Configuration ---------------------------------*/
  /* PLLSAI is configured when a peripheral will use it as source clock : SAI1, SAI2, LTDC or CK48 */
  if(pllsaiused == 1)
  201f34:	2d01      	cmp	r5, #1
  201f36:	d175      	bne.n	202024 <HAL_RCCEx_PeriphCLKConfig+0x378>
  {
    /* Disable PLLSAI Clock */
    __HAL_RCC_PLLSAI_DISABLE(); 
  201f38:	4d18      	ldr	r5, [pc, #96]	; (201f9c <HAL_RCCEx_PeriphCLKConfig+0x2f0>)
  201f3a:	682b      	ldr	r3, [r5, #0]
  201f3c:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
  201f40:	602b      	str	r3, [r5, #0]
    
    /* Get Start Tick*/
    tickstart = HAL_GetTick();
  201f42:	f7fe fda9 	bl	200a98 <HAL_GetTick>
  201f46:	4606      	mov	r6, r0

    /* Wait till PLLSAI is disabled */
    while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)
  201f48:	682b      	ldr	r3, [r5, #0]
  201f4a:	009f      	lsls	r7, r3, #2
  201f4c:	f100 8127 	bmi.w	20219e <HAL_RCCEx_PeriphCLKConfig+0x4f2>
    
    /* Check the PLLSAI division factors */
    assert_param(IS_RCC_PLLSAIN_VALUE(PeriphClkInit->PLLSAI.PLLSAIN));
    
    /*----------------- In Case of PLLSAI is selected as source clock for SAI -------------------*/  
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)) ||\
  201f50:	6821      	ldr	r1, [r4, #0]
  201f52:	030e      	lsls	r6, r1, #12
  201f54:	d501      	bpl.n	201f5a <HAL_RCCEx_PeriphCLKConfig+0x2ae>
  201f56:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  201f58:	b11b      	cbz	r3, 201f62 <HAL_RCCEx_PeriphCLKConfig+0x2b6>
  201f5a:	02cd      	lsls	r5, r1, #11
  201f5c:	d522      	bpl.n	201fa4 <HAL_RCCEx_PeriphCLKConfig+0x2f8>
       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLSAI)))
  201f5e:	6c23      	ldr	r3, [r4, #64]	; 0x40
  201f60:	bb03      	cbnz	r3, 201fa4 <HAL_RCCEx_PeriphCLKConfig+0x2f8>
      assert_param(IS_RCC_PLLSAIQ_VALUE(PeriphClkInit->PLLSAI.PLLSAIQ));
      /* check for PLLSAI/DIVQ Parameter */
      assert_param(IS_RCC_PLLSAI_DIVQ_VALUE(PeriphClkInit->PLLSAIDivQ));
    
      /* Read PLLSAIP value from PLLSAICFGR register (this value is not needed for SAI configuration) */
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> RCC_PLLSAICFGR_PLLSAIP_Pos);
  201f62:	4a0e      	ldr	r2, [pc, #56]	; (201f9c <HAL_RCCEx_PeriphCLKConfig+0x2f0>)
  201f64:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLSAICFGR_PLLSAIR_Pos);
  201f68:	f8d2 0088 	ldr.w	r0, [r2, #136]	; 0x88
      /* PLLSAI_VCO Input  = PLL_SOURCE/PLLM */
      /* PLLSAI_VCO Output = PLLSAI_VCO Input * PLLSAIN */
      /* SAI_CLK(first level) = PLLSAI_VCO Output/PLLSAIQ */
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg0, PeriphClkInit->PLLSAI.PLLSAIQ, tmpreg1);
  201f6c:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
  201f70:	f000 40e0 	and.w	r0, r0, #1879048192	; 0x70000000
  201f74:	4303      	orrs	r3, r0
  201f76:	6960      	ldr	r0, [r4, #20]
  201f78:	ea43 1380 	orr.w	r3, r3, r0, lsl #6
  201f7c:	69a0      	ldr	r0, [r4, #24]
  201f7e:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
  201f82:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
      
      /* SAI_CLK_x = SAI_CLK(first level)/PLLSAIDIVQ */ 
      __HAL_RCC_PLLSAI_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLSAIDivQ);
  201f86:	f8d2 308c 	ldr.w	r3, [r2, #140]	; 0x8c
  201f8a:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  201f8c:	f423 53f8 	bic.w	r3, r3, #7936	; 0x1f00
  201f90:	3801      	subs	r0, #1
  201f92:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
  201f96:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
  201f9a:	e003      	b.n	201fa4 <HAL_RCCEx_PeriphCLKConfig+0x2f8>
  201f9c:	40023800 	.word	0x40023800
  201fa0:	40007000 	.word	0x40007000
    }           

    /*----------------- In Case of PLLSAI is selected as source clock for CLK48 -------------------*/   
    /* In Case of PLLI2S is selected as source clock for CK48 */ 
    if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CLK48) == RCC_PERIPHCLK_CLK48) && (PeriphClkInit->Clk48ClockSelection == RCC_CLK48SOURCE_PLLSAIP))
  201fa4:	0288      	lsls	r0, r1, #10
  201fa6:	d515      	bpl.n	201fd4 <HAL_RCCEx_PeriphCLKConfig+0x328>
  201fa8:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
  201faa:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
  201fae:	d111      	bne.n	201fd4 <HAL_RCCEx_PeriphCLKConfig+0x328>
    {
      /* check for Parameters */
      assert_param(IS_RCC_PLLSAIP_VALUE(PeriphClkInit->PLLSAI.PLLSAIP));
      /* Read PLLSAIQ and PLLSAIR value from PLLSAICFGR register (this value is not needed for CK48 configuration) */
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);
  201fb0:	4a82      	ldr	r2, [pc, #520]	; (2021bc <HAL_RCCEx_PeriphCLKConfig+0x510>)
  201fb2:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIR) >> RCC_PLLSAICFGR_PLLSAIR_Pos);
  201fb6:	f8d2 0088 	ldr.w	r0, [r2, #136]	; 0x88
      
      /* Configure the PLLSAI division factors */
      /* PLLSAI_VCO = f(VCO clock) = f(PLLSAI clock input) x (PLLI2SN/PLLM) */
      /* 48CLK = f(PLLSAI clock output) = f(VCO clock) / PLLSAIP */
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , PeriphClkInit->PLLSAI.PLLSAIP, tmpreg0, tmpreg1);
  201fba:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
  201fbe:	f000 40e0 	and.w	r0, r0, #1879048192	; 0x70000000
  201fc2:	4303      	orrs	r3, r0
  201fc4:	6960      	ldr	r0, [r4, #20]
  201fc6:	ea43 1380 	orr.w	r3, r3, r0, lsl #6
  201fca:	6a20      	ldr	r0, [r4, #32]
  201fcc:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
  201fd0:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
    }        

#if defined(STM32F746xx) || defined(STM32F756xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx) 
    /*---------------------------- LTDC configuration -------------------------------*/
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == (RCC_PERIPHCLK_LTDC))
  201fd4:	070a      	lsls	r2, r1, #28
  201fd6:	d519      	bpl.n	20200c <HAL_RCCEx_PeriphCLKConfig+0x360>
    {
      assert_param(IS_RCC_PLLSAIR_VALUE(PeriphClkInit->PLLSAI.PLLSAIR));
      assert_param(IS_RCC_PLLSAI_DIVR_VALUE(PeriphClkInit->PLLSAIDivR));
      
      /* Read PLLSAIP and PLLSAIQ value from PLLSAICFGR register (these value are not needed for LTDC configuration) */
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);
  201fd8:	4978      	ldr	r1, [pc, #480]	; (2021bc <HAL_RCCEx_PeriphCLKConfig+0x510>)
  201fda:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> RCC_PLLSAICFGR_PLLSAIP_Pos);
  201fde:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
      
      /* PLLSAI_VCO Input  = PLL_SOURCE/PLLM */
      /* PLLSAI_VCO Output = PLLSAI_VCO Input * PLLSAIN */
      /* LTDC_CLK(first level) = PLLSAI_VCO Output/PLLSAIR */
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg1, tmpreg0, PeriphClkInit->PLLSAI.PLLSAIR);
  201fe2:	f002 6270 	and.w	r2, r2, #251658240	; 0xf000000
  201fe6:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
  201fea:	4313      	orrs	r3, r2
  201fec:	6962      	ldr	r2, [r4, #20]
  201fee:	ea43 1382 	orr.w	r3, r3, r2, lsl #6
  201ff2:	69e2      	ldr	r2, [r4, #28]
  201ff4:	ea43 7302 	orr.w	r3, r3, r2, lsl #28
  201ff8:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
      
      /* LTDC_CLK = LTDC_CLK(first level)/PLLSAIDIVR */ 
      __HAL_RCC_PLLSAI_PLLSAICLKDIVR_CONFIG(PeriphClkInit->PLLSAIDivR);
  201ffc:	f8d1 308c 	ldr.w	r3, [r1, #140]	; 0x8c
  202000:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  202002:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
  202006:	4313      	orrs	r3, r2
  202008:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
    }    
#endif /* STM32F746xx || STM32F756xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */  

    /* Enable PLLSAI Clock */
    __HAL_RCC_PLLSAI_ENABLE();
  20200c:	4c6b      	ldr	r4, [pc, #428]	; (2021bc <HAL_RCCEx_PeriphCLKConfig+0x510>)
  20200e:	6823      	ldr	r3, [r4, #0]
  202010:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
  202014:	6023      	str	r3, [r4, #0]
    
    /* Get Start Tick*/
    tickstart = HAL_GetTick();
  202016:	f7fe fd3f 	bl	200a98 <HAL_GetTick>
  20201a:	4605      	mov	r5, r0

    /* Wait till PLLSAI is ready */
    while(__HAL_RCC_PLLSAI_GET_FLAG() == RESET)
  20201c:	6823      	ldr	r3, [r4, #0]
  20201e:	009b      	lsls	r3, r3, #2
  202020:	f140 80c4 	bpl.w	2021ac <HAL_RCCEx_PeriphCLKConfig+0x500>
        /* return in case of Timeout detected */        
        return HAL_TIMEOUT;
      }
    }
  }
  return HAL_OK;
  202024:	2000      	movs	r0, #0
  202026:	e009      	b.n	20203c <HAL_RCCEx_PeriphCLKConfig+0x390>
      plli2sused = 1; 
  202028:	2601      	movs	r6, #1
  20202a:	e67b      	b.n	201d24 <HAL_RCCEx_PeriphCLKConfig+0x78>
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
  20202c:	f7fe fd34 	bl	200a98 <HAL_GetTick>
  202030:	eba0 0008 	sub.w	r0, r0, r8
  202034:	2864      	cmp	r0, #100	; 0x64
  202036:	f67f ae8d 	bls.w	201d54 <HAL_RCCEx_PeriphCLKConfig+0xa8>
        return HAL_TIMEOUT;
  20203a:	2003      	movs	r0, #3
}
  20203c:	b003      	add	sp, #12
  20203e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if((tmpreg0 != 0x00000000U) && (tmpreg0 != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
  202042:	6b22      	ldr	r2, [r4, #48]	; 0x30
  202044:	f402 7240 	and.w	r2, r2, #768	; 0x300
  202048:	4293      	cmp	r3, r2
  20204a:	f43f ae8d 	beq.w	201d68 <HAL_RCCEx_PeriphCLKConfig+0xbc>
      tmpreg0 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
  20204e:	6f3b      	ldr	r3, [r7, #112]	; 0x70
      __HAL_RCC_BACKUPRESET_FORCE();
  202050:	6f3a      	ldr	r2, [r7, #112]	; 0x70
      tmpreg0 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
  202052:	f423 7340 	bic.w	r3, r3, #768	; 0x300
      __HAL_RCC_BACKUPRESET_FORCE();
  202056:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
  20205a:	673a      	str	r2, [r7, #112]	; 0x70
      __HAL_RCC_BACKUPRESET_RELEASE();
  20205c:	6f3a      	ldr	r2, [r7, #112]	; 0x70
  20205e:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
  202062:	673a      	str	r2, [r7, #112]	; 0x70
      RCC->BDCR = tmpreg0;
  202064:	673b      	str	r3, [r7, #112]	; 0x70
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSEON))
  202066:	6f3b      	ldr	r3, [r7, #112]	; 0x70
  202068:	07d8      	lsls	r0, r3, #31
  20206a:	f57f ae7d 	bpl.w	201d68 <HAL_RCCEx_PeriphCLKConfig+0xbc>
        tickstart = HAL_GetTick();
  20206e:	f7fe fd13 	bl	200a98 <HAL_GetTick>
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
  202072:	f241 3988 	movw	r9, #5000	; 0x1388
        tickstart = HAL_GetTick();
  202076:	4680      	mov	r8, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
  202078:	6f3b      	ldr	r3, [r7, #112]	; 0x70
  20207a:	0799      	lsls	r1, r3, #30
  20207c:	f53f ae74 	bmi.w	201d68 <HAL_RCCEx_PeriphCLKConfig+0xbc>
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
  202080:	f7fe fd0a 	bl	200a98 <HAL_GetTick>
  202084:	eba0 0008 	sub.w	r0, r0, r8
  202088:	4548      	cmp	r0, r9
  20208a:	d9f5      	bls.n	202078 <HAL_RCCEx_PeriphCLKConfig+0x3cc>
  20208c:	e7d5      	b.n	20203a <HAL_RCCEx_PeriphCLKConfig+0x38e>
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
  20208e:	6891      	ldr	r1, [r2, #8]
  202090:	f421 11f8 	bic.w	r1, r1, #2031616	; 0x1f0000
  202094:	e678      	b.n	201d88 <HAL_RCCEx_PeriphCLKConfig+0xdc>
    __HAL_RCC_PLLI2S_DISABLE();  
  202096:	4e49      	ldr	r6, [pc, #292]	; (2021bc <HAL_RCCEx_PeriphCLKConfig+0x510>)
  202098:	6833      	ldr	r3, [r6, #0]
  20209a:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
  20209e:	6033      	str	r3, [r6, #0]
    tickstart = HAL_GetTick();
  2020a0:	f7fe fcfa 	bl	200a98 <HAL_GetTick>
  2020a4:	4607      	mov	r7, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
  2020a6:	6833      	ldr	r3, [r6, #0]
  2020a8:	011b      	lsls	r3, r3, #4
  2020aa:	d472      	bmi.n	202192 <HAL_RCCEx_PeriphCLKConfig+0x4e6>
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) && (PeriphClkInit->I2sClockSelection == RCC_I2SCLKSOURCE_PLLI2S)))
  2020ac:	6822      	ldr	r2, [r4, #0]
  2020ae:	07d7      	lsls	r7, r2, #31
  2020b0:	d512      	bpl.n	2020d8 <HAL_RCCEx_PeriphCLKConfig+0x42c>
  2020b2:	6b63      	ldr	r3, [r4, #52]	; 0x34
  2020b4:	b983      	cbnz	r3, 2020d8 <HAL_RCCEx_PeriphCLKConfig+0x42c>
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> RCC_PLLI2SCFGR_PLLI2SP_Pos);
  2020b6:	f8d6 3084 	ldr.w	r3, [r6, #132]	; 0x84
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> RCC_PLLI2SCFGR_PLLI2SQ_Pos);
  2020ba:	f8d6 1084 	ldr.w	r1, [r6, #132]	; 0x84
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , tmpreg0, tmpreg1, PeriphClkInit->PLLI2S.PLLI2SR);
  2020be:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
  2020c2:	f001 6170 	and.w	r1, r1, #251658240	; 0xf000000
  2020c6:	430b      	orrs	r3, r1
  2020c8:	6861      	ldr	r1, [r4, #4]
  2020ca:	ea43 1381 	orr.w	r3, r3, r1, lsl #6
  2020ce:	68a1      	ldr	r1, [r4, #8]
  2020d0:	ea43 7301 	orr.w	r3, r3, r1, lsl #28
  2020d4:	f8c6 3084 	str.w	r3, [r6, #132]	; 0x84
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)) ||
  2020d8:	0316      	lsls	r6, r2, #12
  2020da:	d503      	bpl.n	2020e4 <HAL_RCCEx_PeriphCLKConfig+0x438>
  2020dc:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  2020de:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
  2020e2:	d005      	beq.n	2020f0 <HAL_RCCEx_PeriphCLKConfig+0x444>
  2020e4:	02d0      	lsls	r0, r2, #11
  2020e6:	d51e      	bpl.n	202126 <HAL_RCCEx_PeriphCLKConfig+0x47a>
       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S))) 
  2020e8:	6c23      	ldr	r3, [r4, #64]	; 0x40
  2020ea:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
  2020ee:	d11a      	bne.n	202126 <HAL_RCCEx_PeriphCLKConfig+0x47a>
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> RCC_PLLI2SCFGR_PLLI2SP_Pos);
  2020f0:	4932      	ldr	r1, [pc, #200]	; (2021bc <HAL_RCCEx_PeriphCLKConfig+0x510>)
  2020f2:	f8d1 3084 	ldr.w	r3, [r1, #132]	; 0x84
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);
  2020f6:	f8d1 0084 	ldr.w	r0, [r1, #132]	; 0x84
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN, tmpreg0, PeriphClkInit->PLLI2S.PLLI2SQ, tmpreg1);
  2020fa:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
  2020fe:	f000 40e0 	and.w	r0, r0, #1879048192	; 0x70000000
  202102:	4303      	orrs	r3, r0
  202104:	6860      	ldr	r0, [r4, #4]
  202106:	ea43 1380 	orr.w	r3, r3, r0, lsl #6
  20210a:	68e0      	ldr	r0, [r4, #12]
  20210c:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
  202110:	f8c1 3084 	str.w	r3, [r1, #132]	; 0x84
      __HAL_RCC_PLLI2S_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLI2SDivQ);   
  202114:	f8d1 008c 	ldr.w	r0, [r1, #140]	; 0x8c
  202118:	6a63      	ldr	r3, [r4, #36]	; 0x24
  20211a:	f020 001f 	bic.w	r0, r0, #31
  20211e:	3b01      	subs	r3, #1
  202120:	4303      	orrs	r3, r0
  202122:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
  202126:	01d1      	lsls	r1, r2, #7
  202128:	d511      	bpl.n	20214e <HAL_RCCEx_PeriphCLKConfig+0x4a2>
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> RCC_PLLI2SCFGR_PLLI2SQ_Pos);
  20212a:	4924      	ldr	r1, [pc, #144]	; (2021bc <HAL_RCCEx_PeriphCLKConfig+0x510>)
  20212c:	f8d1 3084 	ldr.w	r3, [r1, #132]	; 0x84
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);
  202130:	f8d1 0084 	ldr.w	r0, [r1, #132]	; 0x84
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, tmpreg0, tmpreg1);
  202134:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
  202138:	f000 40e0 	and.w	r0, r0, #1879048192	; 0x70000000
  20213c:	4303      	orrs	r3, r0
  20213e:	6860      	ldr	r0, [r4, #4]
  202140:	ea43 1380 	orr.w	r3, r3, r0, lsl #6
  202144:	6920      	ldr	r0, [r4, #16]
  202146:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
  20214a:	f8c1 3084 	str.w	r3, [r1, #132]	; 0x84
    if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_PLLI2S) == RCC_PERIPHCLK_PLLI2S)
  20214e:	0192      	lsls	r2, r2, #6
  202150:	d50d      	bpl.n	20216e <HAL_RCCEx_PeriphCLKConfig+0x4c2>
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, PeriphClkInit->PLLI2S.PLLI2SQ, PeriphClkInit->PLLI2S.PLLI2SR);
  202152:	6923      	ldr	r3, [r4, #16]
  202154:	6862      	ldr	r2, [r4, #4]
  202156:	041b      	lsls	r3, r3, #16
  202158:	ea43 1382 	orr.w	r3, r3, r2, lsl #6
  20215c:	68e2      	ldr	r2, [r4, #12]
  20215e:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
  202162:	68a2      	ldr	r2, [r4, #8]
  202164:	ea43 7302 	orr.w	r3, r3, r2, lsl #28
  202168:	4a14      	ldr	r2, [pc, #80]	; (2021bc <HAL_RCCEx_PeriphCLKConfig+0x510>)
  20216a:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
    __HAL_RCC_PLLI2S_ENABLE();
  20216e:	4e13      	ldr	r6, [pc, #76]	; (2021bc <HAL_RCCEx_PeriphCLKConfig+0x510>)
  202170:	6833      	ldr	r3, [r6, #0]
  202172:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
  202176:	6033      	str	r3, [r6, #0]
    tickstart = HAL_GetTick();
  202178:	f7fe fc8e 	bl	200a98 <HAL_GetTick>
  20217c:	4607      	mov	r7, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
  20217e:	6833      	ldr	r3, [r6, #0]
  202180:	011b      	lsls	r3, r3, #4
  202182:	f53f aed7 	bmi.w	201f34 <HAL_RCCEx_PeriphCLKConfig+0x288>
      if((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)
  202186:	f7fe fc87 	bl	200a98 <HAL_GetTick>
  20218a:	1bc0      	subs	r0, r0, r7
  20218c:	2864      	cmp	r0, #100	; 0x64
  20218e:	d9f6      	bls.n	20217e <HAL_RCCEx_PeriphCLKConfig+0x4d2>
  202190:	e753      	b.n	20203a <HAL_RCCEx_PeriphCLKConfig+0x38e>
      if((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)
  202192:	f7fe fc81 	bl	200a98 <HAL_GetTick>
  202196:	1bc0      	subs	r0, r0, r7
  202198:	2864      	cmp	r0, #100	; 0x64
  20219a:	d984      	bls.n	2020a6 <HAL_RCCEx_PeriphCLKConfig+0x3fa>
  20219c:	e74d      	b.n	20203a <HAL_RCCEx_PeriphCLKConfig+0x38e>
      if((HAL_GetTick() - tickstart) > PLLSAI_TIMEOUT_VALUE)
  20219e:	f7fe fc7b 	bl	200a98 <HAL_GetTick>
  2021a2:	1b80      	subs	r0, r0, r6
  2021a4:	2864      	cmp	r0, #100	; 0x64
  2021a6:	f67f aecf 	bls.w	201f48 <HAL_RCCEx_PeriphCLKConfig+0x29c>
  2021aa:	e746      	b.n	20203a <HAL_RCCEx_PeriphCLKConfig+0x38e>
      if((HAL_GetTick() - tickstart) > PLLSAI_TIMEOUT_VALUE)
  2021ac:	f7fe fc74 	bl	200a98 <HAL_GetTick>
  2021b0:	1b40      	subs	r0, r0, r5
  2021b2:	2864      	cmp	r0, #100	; 0x64
  2021b4:	f67f af32 	bls.w	20201c <HAL_RCCEx_PeriphCLKConfig+0x370>
  2021b8:	e73f      	b.n	20203a <HAL_RCCEx_PeriphCLKConfig+0x38e>
  2021ba:	bf00      	nop
  2021bc:	40023800 	.word	0x40023800

002021c0 <HAL_TIM_Base_Start_IT>:
{
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  
  /* Enable the TIM Update interrupt */
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
  2021c0:	6803      	ldr	r3, [r0, #0]
  /* Enable the Peripheral */
  __HAL_TIM_ENABLE(htim);
      
  /* Return function status */
  return HAL_OK;
}
  2021c2:	2000      	movs	r0, #0
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
  2021c4:	68da      	ldr	r2, [r3, #12]
  2021c6:	f042 0201 	orr.w	r2, r2, #1
  2021ca:	60da      	str	r2, [r3, #12]
  __HAL_TIM_ENABLE(htim);
  2021cc:	681a      	ldr	r2, [r3, #0]
  2021ce:	f042 0201 	orr.w	r2, r2, #1
  2021d2:	601a      	str	r2, [r3, #0]
}
  2021d4:	4770      	bx	lr

002021d6 <HAL_TIM_Encoder_Start>:
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Encoder_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
{
  2021d6:	6803      	ldr	r3, [r0, #0]
  /* Check the parameters */
  assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
  
  /* Enable the encoder interface channels */
  switch (Channel)
  2021d8:	b189      	cbz	r1, 2021fe <HAL_TIM_Encoder_Start+0x28>
  2021da:	2904      	cmp	r1, #4
  2021dc:	d007      	beq.n	2021ee <HAL_TIM_Encoder_Start+0x18>
  assert_param(IS_TIM_CHANNELS(Channel));

  tmp = TIM_CCER_CC1E << Channel;

  /* Reset the CCxE Bit */
  TIMx->CCER &= ~tmp;
  2021de:	6a1a      	ldr	r2, [r3, #32]
  2021e0:	f022 0201 	bic.w	r2, r2, #1
  2021e4:	621a      	str	r2, [r3, #32]

  /* Set or reset the CCxE Bit */ 
  TIMx->CCER |= (uint32_t)(ChannelState << Channel);
  2021e6:	6a1a      	ldr	r2, [r3, #32]
  2021e8:	f042 0201 	orr.w	r2, r2, #1
  2021ec:	621a      	str	r2, [r3, #32]
  TIMx->CCER &= ~tmp;
  2021ee:	6a1a      	ldr	r2, [r3, #32]
  2021f0:	f022 0210 	bic.w	r2, r2, #16
  2021f4:	621a      	str	r2, [r3, #32]
  TIMx->CCER |= (uint32_t)(ChannelState << Channel);
  2021f6:	6a1a      	ldr	r2, [r3, #32]
  2021f8:	f042 0210 	orr.w	r2, r2, #16
  2021fc:	e006      	b.n	20220c <HAL_TIM_Encoder_Start+0x36>
  TIMx->CCER &= ~tmp;
  2021fe:	6a1a      	ldr	r2, [r3, #32]
  202200:	f022 0201 	bic.w	r2, r2, #1
  202204:	621a      	str	r2, [r3, #32]
  TIMx->CCER |= (uint32_t)(ChannelState << Channel);
  202206:	6a1a      	ldr	r2, [r3, #32]
  202208:	f042 0201 	orr.w	r2, r2, #1
  20220c:	621a      	str	r2, [r3, #32]
}
  20220e:	2000      	movs	r0, #0
  __HAL_TIM_ENABLE(htim);
  202210:	681a      	ldr	r2, [r3, #0]
  202212:	f042 0201 	orr.w	r2, r2, #1
  202216:	601a      	str	r2, [r3, #0]
}
  202218:	4770      	bx	lr

0020221a <HAL_TIM_OC_DelayElapsedCallback>:
  20221a:	4770      	bx	lr

0020221c <HAL_TIM_IC_CaptureCallback>:
  20221c:	4770      	bx	lr

0020221e <HAL_TIM_PWM_PulseFinishedCallback>:
  20221e:	4770      	bx	lr

00202220 <HAL_TIM_TriggerCallback>:
  202220:	4770      	bx	lr

00202222 <HAL_TIM_IRQHandler>:
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
  202222:	6803      	ldr	r3, [r0, #0]
  202224:	691a      	ldr	r2, [r3, #16]
  202226:	0791      	lsls	r1, r2, #30
{
  202228:	b510      	push	{r4, lr}
  20222a:	4604      	mov	r4, r0
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
  20222c:	d50f      	bpl.n	20224e <HAL_TIM_IRQHandler+0x2c>
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) !=RESET)
  20222e:	68da      	ldr	r2, [r3, #12]
  202230:	0792      	lsls	r2, r2, #30
  202232:	d50c      	bpl.n	20224e <HAL_TIM_IRQHandler+0x2c>
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
  202234:	f06f 0202 	mvn.w	r2, #2
  202238:	611a      	str	r2, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
  20223a:	2201      	movs	r2, #1
        if((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00)
  20223c:	699b      	ldr	r3, [r3, #24]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
  20223e:	7702      	strb	r2, [r0, #28]
        if((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00)
  202240:	0799      	lsls	r1, r3, #30
  202242:	f000 8085 	beq.w	202350 <HAL_TIM_IRQHandler+0x12e>
          HAL_TIM_IC_CaptureCallback(htim);
  202246:	f7ff ffe9 	bl	20221c <HAL_TIM_IC_CaptureCallback>
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
  20224a:	2300      	movs	r3, #0
  20224c:	7723      	strb	r3, [r4, #28]
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
  20224e:	6823      	ldr	r3, [r4, #0]
  202250:	691a      	ldr	r2, [r3, #16]
  202252:	0752      	lsls	r2, r2, #29
  202254:	d510      	bpl.n	202278 <HAL_TIM_IRQHandler+0x56>
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) !=RESET)
  202256:	68da      	ldr	r2, [r3, #12]
  202258:	0750      	lsls	r0, r2, #29
  20225a:	d50d      	bpl.n	202278 <HAL_TIM_IRQHandler+0x56>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
  20225c:	f06f 0204 	mvn.w	r2, #4
        HAL_TIM_IC_CaptureCallback(htim);
  202260:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
  202262:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
  202264:	2202      	movs	r2, #2
      if((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00)
  202266:	699b      	ldr	r3, [r3, #24]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
  202268:	7722      	strb	r2, [r4, #28]
      if((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00)
  20226a:	f413 7f40 	tst.w	r3, #768	; 0x300
  20226e:	d075      	beq.n	20235c <HAL_TIM_IRQHandler+0x13a>
        HAL_TIM_IC_CaptureCallback(htim);
  202270:	f7ff ffd4 	bl	20221c <HAL_TIM_IC_CaptureCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
  202274:	2300      	movs	r3, #0
  202276:	7723      	strb	r3, [r4, #28]
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
  202278:	6823      	ldr	r3, [r4, #0]
  20227a:	691a      	ldr	r2, [r3, #16]
  20227c:	0711      	lsls	r1, r2, #28
  20227e:	d50f      	bpl.n	2022a0 <HAL_TIM_IRQHandler+0x7e>
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) !=RESET)
  202280:	68da      	ldr	r2, [r3, #12]
  202282:	0712      	lsls	r2, r2, #28
  202284:	d50c      	bpl.n	2022a0 <HAL_TIM_IRQHandler+0x7e>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
  202286:	f06f 0208 	mvn.w	r2, #8
        HAL_TIM_IC_CaptureCallback(htim);
  20228a:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
  20228c:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
  20228e:	2204      	movs	r2, #4
      if((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00)
  202290:	69db      	ldr	r3, [r3, #28]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
  202292:	7722      	strb	r2, [r4, #28]
      if((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00)
  202294:	079b      	lsls	r3, r3, #30
  202296:	d067      	beq.n	202368 <HAL_TIM_IRQHandler+0x146>
        HAL_TIM_IC_CaptureCallback(htim);
  202298:	f7ff ffc0 	bl	20221c <HAL_TIM_IC_CaptureCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
  20229c:	2300      	movs	r3, #0
  20229e:	7723      	strb	r3, [r4, #28]
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
  2022a0:	6823      	ldr	r3, [r4, #0]
  2022a2:	691a      	ldr	r2, [r3, #16]
  2022a4:	06d0      	lsls	r0, r2, #27
  2022a6:	d510      	bpl.n	2022ca <HAL_TIM_IRQHandler+0xa8>
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) !=RESET)
  2022a8:	68da      	ldr	r2, [r3, #12]
  2022aa:	06d1      	lsls	r1, r2, #27
  2022ac:	d50d      	bpl.n	2022ca <HAL_TIM_IRQHandler+0xa8>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
  2022ae:	f06f 0210 	mvn.w	r2, #16
        HAL_TIM_IC_CaptureCallback(htim);
  2022b2:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
  2022b4:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
  2022b6:	2208      	movs	r2, #8
      if((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00)
  2022b8:	69db      	ldr	r3, [r3, #28]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
  2022ba:	7722      	strb	r2, [r4, #28]
      if((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00)
  2022bc:	f413 7f40 	tst.w	r3, #768	; 0x300
  2022c0:	d058      	beq.n	202374 <HAL_TIM_IRQHandler+0x152>
        HAL_TIM_IC_CaptureCallback(htim);
  2022c2:	f7ff ffab 	bl	20221c <HAL_TIM_IC_CaptureCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
  2022c6:	2300      	movs	r3, #0
  2022c8:	7723      	strb	r3, [r4, #28]
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
  2022ca:	6823      	ldr	r3, [r4, #0]
  2022cc:	691a      	ldr	r2, [r3, #16]
  2022ce:	07d2      	lsls	r2, r2, #31
  2022d0:	d508      	bpl.n	2022e4 <HAL_TIM_IRQHandler+0xc2>
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) !=RESET)
  2022d2:	68da      	ldr	r2, [r3, #12]
  2022d4:	07d0      	lsls	r0, r2, #31
  2022d6:	d505      	bpl.n	2022e4 <HAL_TIM_IRQHandler+0xc2>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
  2022d8:	f06f 0201 	mvn.w	r2, #1
      HAL_TIM_PeriodElapsedCallback(htim);
  2022dc:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
  2022de:	611a      	str	r2, [r3, #16]
      HAL_TIM_PeriodElapsedCallback(htim);
  2022e0:	f001 fcfc 	bl	203cdc <HAL_TIM_PeriodElapsedCallback>
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
  2022e4:	6823      	ldr	r3, [r4, #0]
  2022e6:	691a      	ldr	r2, [r3, #16]
  2022e8:	0611      	lsls	r1, r2, #24
  2022ea:	d508      	bpl.n	2022fe <HAL_TIM_IRQHandler+0xdc>
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) !=RESET)
  2022ec:	68da      	ldr	r2, [r3, #12]
  2022ee:	0612      	lsls	r2, r2, #24
  2022f0:	d505      	bpl.n	2022fe <HAL_TIM_IRQHandler+0xdc>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
  2022f2:	f06f 0280 	mvn.w	r2, #128	; 0x80
      HAL_TIMEx_BreakCallback(htim);
  2022f6:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
  2022f8:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_BreakCallback(htim);
  2022fa:	f000 fac8 	bl	20288e <HAL_TIMEx_BreakCallback>
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK2) != RESET)
  2022fe:	6823      	ldr	r3, [r4, #0]
  202300:	691a      	ldr	r2, [r3, #16]
  202302:	05d0      	lsls	r0, r2, #23
  202304:	d508      	bpl.n	202318 <HAL_TIM_IRQHandler+0xf6>
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) !=RESET)
  202306:	68da      	ldr	r2, [r3, #12]
  202308:	0611      	lsls	r1, r2, #24
  20230a:	d505      	bpl.n	202318 <HAL_TIM_IRQHandler+0xf6>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
  20230c:	f06f 0280 	mvn.w	r2, #128	; 0x80
      HAL_TIMEx_BreakCallback(htim);
  202310:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
  202312:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_BreakCallback(htim);
  202314:	f000 fabb 	bl	20288e <HAL_TIMEx_BreakCallback>
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
  202318:	6823      	ldr	r3, [r4, #0]
  20231a:	691a      	ldr	r2, [r3, #16]
  20231c:	0652      	lsls	r2, r2, #25
  20231e:	d508      	bpl.n	202332 <HAL_TIM_IRQHandler+0x110>
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) !=RESET)
  202320:	68da      	ldr	r2, [r3, #12]
  202322:	0650      	lsls	r0, r2, #25
  202324:	d505      	bpl.n	202332 <HAL_TIM_IRQHandler+0x110>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
  202326:	f06f 0240 	mvn.w	r2, #64	; 0x40
      HAL_TIM_TriggerCallback(htim);
  20232a:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
  20232c:	611a      	str	r2, [r3, #16]
      HAL_TIM_TriggerCallback(htim);
  20232e:	f7ff ff77 	bl	202220 <HAL_TIM_TriggerCallback>
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
  202332:	6823      	ldr	r3, [r4, #0]
  202334:	691a      	ldr	r2, [r3, #16]
  202336:	0691      	lsls	r1, r2, #26
  202338:	d522      	bpl.n	202380 <HAL_TIM_IRQHandler+0x15e>
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) !=RESET)
  20233a:	68da      	ldr	r2, [r3, #12]
  20233c:	0692      	lsls	r2, r2, #26
  20233e:	d51f      	bpl.n	202380 <HAL_TIM_IRQHandler+0x15e>
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
  202340:	f06f 0220 	mvn.w	r2, #32
      HAL_TIMEx_CommutationCallback(htim);
  202344:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
  202346:	611a      	str	r2, [r3, #16]
}
  202348:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      HAL_TIMEx_CommutationCallback(htim);
  20234c:	f000 ba9e 	b.w	20288c <HAL_TIMEx_CommutationCallback>
          HAL_TIM_OC_DelayElapsedCallback(htim);
  202350:	f7ff ff63 	bl	20221a <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
  202354:	4620      	mov	r0, r4
  202356:	f7ff ff62 	bl	20221e <HAL_TIM_PWM_PulseFinishedCallback>
  20235a:	e776      	b.n	20224a <HAL_TIM_IRQHandler+0x28>
        HAL_TIM_OC_DelayElapsedCallback(htim);
  20235c:	f7ff ff5d 	bl	20221a <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
  202360:	4620      	mov	r0, r4
  202362:	f7ff ff5c 	bl	20221e <HAL_TIM_PWM_PulseFinishedCallback>
  202366:	e785      	b.n	202274 <HAL_TIM_IRQHandler+0x52>
        HAL_TIM_OC_DelayElapsedCallback(htim);
  202368:	f7ff ff57 	bl	20221a <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim); 
  20236c:	4620      	mov	r0, r4
  20236e:	f7ff ff56 	bl	20221e <HAL_TIM_PWM_PulseFinishedCallback>
  202372:	e793      	b.n	20229c <HAL_TIM_IRQHandler+0x7a>
        HAL_TIM_OC_DelayElapsedCallback(htim);
  202374:	f7ff ff51 	bl	20221a <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
  202378:	4620      	mov	r0, r4
  20237a:	f7ff ff50 	bl	20221e <HAL_TIM_PWM_PulseFinishedCallback>
  20237e:	e7a2      	b.n	2022c6 <HAL_TIM_IRQHandler+0xa4>
  202380:	bd10      	pop	{r4, pc}
	...

00202384 <TIM_Base_SetConfig>:
  if(IS_TIM_CC3_INSTANCE(TIMx) != RESET)   
  202384:	4a30      	ldr	r2, [pc, #192]	; (202448 <TIM_Base_SetConfig+0xc4>)
  tmpcr1 = TIMx->CR1;
  202386:	6803      	ldr	r3, [r0, #0]
  if(IS_TIM_CC3_INSTANCE(TIMx) != RESET)   
  202388:	4290      	cmp	r0, r2
  20238a:	d012      	beq.n	2023b2 <TIM_Base_SetConfig+0x2e>
  20238c:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
  202390:	d00f      	beq.n	2023b2 <TIM_Base_SetConfig+0x2e>
  202392:	f5a2 427c 	sub.w	r2, r2, #64512	; 0xfc00
  202396:	4290      	cmp	r0, r2
  202398:	d00b      	beq.n	2023b2 <TIM_Base_SetConfig+0x2e>
  20239a:	f502 6280 	add.w	r2, r2, #1024	; 0x400
  20239e:	4290      	cmp	r0, r2
  2023a0:	d007      	beq.n	2023b2 <TIM_Base_SetConfig+0x2e>
  2023a2:	f502 6280 	add.w	r2, r2, #1024	; 0x400
  2023a6:	4290      	cmp	r0, r2
  2023a8:	d003      	beq.n	2023b2 <TIM_Base_SetConfig+0x2e>
  2023aa:	f502 4278 	add.w	r2, r2, #63488	; 0xf800
  2023ae:	4290      	cmp	r0, r2
  2023b0:	d11d      	bne.n	2023ee <TIM_Base_SetConfig+0x6a>
    tmpcr1 |= Structure->CounterMode;
  2023b2:	684a      	ldr	r2, [r1, #4]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
  2023b4:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
  2023b8:	4313      	orrs	r3, r2
  if(IS_TIM_CC1_INSTANCE(TIMx) != RESET)  
  2023ba:	4a23      	ldr	r2, [pc, #140]	; (202448 <TIM_Base_SetConfig+0xc4>)
  2023bc:	4290      	cmp	r0, r2
  2023be:	d104      	bne.n	2023ca <TIM_Base_SetConfig+0x46>
    tmpcr1 &= ~TIM_CR1_CKD;
  2023c0:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
  2023c4:	68ca      	ldr	r2, [r1, #12]
  2023c6:	4313      	orrs	r3, r2
  2023c8:	e028      	b.n	20241c <TIM_Base_SetConfig+0x98>
  if(IS_TIM_CC1_INSTANCE(TIMx) != RESET)  
  2023ca:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
  2023ce:	d0f7      	beq.n	2023c0 <TIM_Base_SetConfig+0x3c>
  2023d0:	4a1e      	ldr	r2, [pc, #120]	; (20244c <TIM_Base_SetConfig+0xc8>)
  2023d2:	4290      	cmp	r0, r2
  2023d4:	d0f4      	beq.n	2023c0 <TIM_Base_SetConfig+0x3c>
  2023d6:	f502 6280 	add.w	r2, r2, #1024	; 0x400
  2023da:	4290      	cmp	r0, r2
  2023dc:	d0f0      	beq.n	2023c0 <TIM_Base_SetConfig+0x3c>
  2023de:	f502 6280 	add.w	r2, r2, #1024	; 0x400
  2023e2:	4290      	cmp	r0, r2
  2023e4:	d0ec      	beq.n	2023c0 <TIM_Base_SetConfig+0x3c>
  2023e6:	f502 4278 	add.w	r2, r2, #63488	; 0xf800
  2023ea:	4290      	cmp	r0, r2
  2023ec:	d0e8      	beq.n	2023c0 <TIM_Base_SetConfig+0x3c>
  2023ee:	4a18      	ldr	r2, [pc, #96]	; (202450 <TIM_Base_SetConfig+0xcc>)
  2023f0:	4290      	cmp	r0, r2
  2023f2:	d0e5      	beq.n	2023c0 <TIM_Base_SetConfig+0x3c>
  2023f4:	f502 6280 	add.w	r2, r2, #1024	; 0x400
  2023f8:	4290      	cmp	r0, r2
  2023fa:	d0e1      	beq.n	2023c0 <TIM_Base_SetConfig+0x3c>
  2023fc:	f502 6280 	add.w	r2, r2, #1024	; 0x400
  202400:	4290      	cmp	r0, r2
  202402:	d0dd      	beq.n	2023c0 <TIM_Base_SetConfig+0x3c>
  202404:	f5a2 3298 	sub.w	r2, r2, #77824	; 0x13000
  202408:	4290      	cmp	r0, r2
  20240a:	d0d9      	beq.n	2023c0 <TIM_Base_SetConfig+0x3c>
  20240c:	f502 6280 	add.w	r2, r2, #1024	; 0x400
  202410:	4290      	cmp	r0, r2
  202412:	d0d5      	beq.n	2023c0 <TIM_Base_SetConfig+0x3c>
  202414:	f502 6280 	add.w	r2, r2, #1024	; 0x400
  202418:	4290      	cmp	r0, r2
  20241a:	d0d1      	beq.n	2023c0 <TIM_Base_SetConfig+0x3c>
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
  20241c:	694a      	ldr	r2, [r1, #20]
  20241e:	f023 0380 	bic.w	r3, r3, #128	; 0x80
  202422:	4313      	orrs	r3, r2
  TIMx->CR1 = tmpcr1;
  202424:	6003      	str	r3, [r0, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
  202426:	688b      	ldr	r3, [r1, #8]
  202428:	62c3      	str	r3, [r0, #44]	; 0x2c
  TIMx->PSC = (uint32_t)Structure->Prescaler;
  20242a:	680b      	ldr	r3, [r1, #0]
  20242c:	6283      	str	r3, [r0, #40]	; 0x28
  if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)  
  20242e:	4b06      	ldr	r3, [pc, #24]	; (202448 <TIM_Base_SetConfig+0xc4>)
  202430:	4298      	cmp	r0, r3
  202432:	d006      	beq.n	202442 <TIM_Base_SetConfig+0xbe>
  202434:	f503 6380 	add.w	r3, r3, #1024	; 0x400
  202438:	4298      	cmp	r0, r3
  20243a:	d002      	beq.n	202442 <TIM_Base_SetConfig+0xbe>
  TIMx->EGR = TIM_EGR_UG;
  20243c:	2301      	movs	r3, #1
  20243e:	6143      	str	r3, [r0, #20]
}
  202440:	4770      	bx	lr
    TIMx->RCR = Structure->RepetitionCounter;
  202442:	690b      	ldr	r3, [r1, #16]
  202444:	6303      	str	r3, [r0, #48]	; 0x30
  202446:	e7f9      	b.n	20243c <TIM_Base_SetConfig+0xb8>
  202448:	40010000 	.word	0x40010000
  20244c:	40000400 	.word	0x40000400
  202450:	40014000 	.word	0x40014000

00202454 <HAL_TIM_Base_Init>:
{ 
  202454:	b510      	push	{r4, lr}
  if(htim == NULL)
  202456:	4604      	mov	r4, r0
  202458:	b1a0      	cbz	r0, 202484 <HAL_TIM_Base_Init+0x30>
  if(htim->State == HAL_TIM_STATE_RESET)
  20245a:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
  20245e:	f003 02ff 	and.w	r2, r3, #255	; 0xff
  202462:	b91b      	cbnz	r3, 20246c <HAL_TIM_Base_Init+0x18>
    htim->Lock = HAL_UNLOCKED;
  202464:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
    HAL_TIM_Base_MspInit(htim);
  202468:	f004 fa44 	bl	2068f4 <HAL_TIM_Base_MspInit>
  htim->State= HAL_TIM_STATE_BUSY;
  20246c:	2302      	movs	r3, #2
  TIM_Base_SetConfig(htim->Instance, &htim->Init); 
  20246e:	6820      	ldr	r0, [r4, #0]
  202470:	1d21      	adds	r1, r4, #4
  htim->State= HAL_TIM_STATE_BUSY;
  202472:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  TIM_Base_SetConfig(htim->Instance, &htim->Init); 
  202476:	f7ff ff85 	bl	202384 <TIM_Base_SetConfig>
  htim->State= HAL_TIM_STATE_READY;
  20247a:	2301      	movs	r3, #1
  return HAL_OK;
  20247c:	2000      	movs	r0, #0
  htim->State= HAL_TIM_STATE_READY;
  20247e:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  return HAL_OK;
  202482:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
  202484:	2001      	movs	r0, #1
}
  202486:	bd10      	pop	{r4, pc}

00202488 <HAL_TIM_PWM_Init>:
{
  202488:	b510      	push	{r4, lr}
  if(htim == NULL)
  20248a:	4604      	mov	r4, r0
  20248c:	b1a0      	cbz	r0, 2024b8 <HAL_TIM_PWM_Init+0x30>
  if(htim->State == HAL_TIM_STATE_RESET)
  20248e:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
  202492:	f003 02ff 	and.w	r2, r3, #255	; 0xff
  202496:	b91b      	cbnz	r3, 2024a0 <HAL_TIM_PWM_Init+0x18>
    htim->Lock = HAL_UNLOCKED;  
  202498:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
    HAL_TIM_PWM_MspInit(htim);
  20249c:	f004 f984 	bl	2067a8 <HAL_TIM_PWM_MspInit>
  htim->State= HAL_TIM_STATE_BUSY;  
  2024a0:	2302      	movs	r3, #2
  TIM_Base_SetConfig(htim->Instance, &htim->Init); 
  2024a2:	6820      	ldr	r0, [r4, #0]
  2024a4:	1d21      	adds	r1, r4, #4
  htim->State= HAL_TIM_STATE_BUSY;  
  2024a6:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  TIM_Base_SetConfig(htim->Instance, &htim->Init); 
  2024aa:	f7ff ff6b 	bl	202384 <TIM_Base_SetConfig>
  htim->State= HAL_TIM_STATE_READY;
  2024ae:	2301      	movs	r3, #1
  return HAL_OK;
  2024b0:	2000      	movs	r0, #0
  htim->State= HAL_TIM_STATE_READY;
  2024b2:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  return HAL_OK;
  2024b6:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
  2024b8:	2001      	movs	r0, #1
}  
  2024ba:	bd10      	pop	{r4, pc}

002024bc <HAL_TIM_Encoder_Init>:
{
  2024bc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  2024be:	460c      	mov	r4, r1
  if(htim == NULL)
  2024c0:	4605      	mov	r5, r0
  2024c2:	2800      	cmp	r0, #0
  2024c4:	d043      	beq.n	20254e <HAL_TIM_Encoder_Init+0x92>
  if(htim->State == HAL_TIM_STATE_RESET)
  2024c6:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
  2024ca:	f003 02ff 	and.w	r2, r3, #255	; 0xff
  2024ce:	b91b      	cbnz	r3, 2024d8 <HAL_TIM_Encoder_Init+0x1c>
    htim->Lock = HAL_UNLOCKED;  
  2024d0:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
    HAL_TIM_Encoder_MspInit(htim);
  2024d4:	f004 f9cc 	bl	206870 <HAL_TIM_Encoder_MspInit>
  htim->Instance->SMCR &= ~TIM_SMCR_SMS;
  2024d8:	4629      	mov	r1, r5
  htim->State= HAL_TIM_STATE_BUSY;   
  2024da:	2302      	movs	r3, #2
  htim->Instance->SMCR &= ~TIM_SMCR_SMS;
  2024dc:	f851 0b04 	ldr.w	r0, [r1], #4
  htim->State= HAL_TIM_STATE_BUSY;   
  2024e0:	f885 303d 	strb.w	r3, [r5, #61]	; 0x3d
  htim->Instance->SMCR &= ~TIM_SMCR_SMS;
  2024e4:	6883      	ldr	r3, [r0, #8]
  2024e6:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
  2024ea:	f023 0307 	bic.w	r3, r3, #7
  2024ee:	6083      	str	r3, [r0, #8]
  TIM_Base_SetConfig(htim->Instance, &htim->Init);  
  2024f0:	f7ff ff48 	bl	202384 <TIM_Base_SetConfig>
  tmpsmcr = htim->Instance->SMCR;
  2024f4:	6828      	ldr	r0, [r5, #0]
  tmpsmcr |= sConfig->EncoderMode;
  2024f6:	6823      	ldr	r3, [r4, #0]
  tmpsmcr = htim->Instance->SMCR;
  2024f8:	6886      	ldr	r6, [r0, #8]
  tmpccmr1 = htim->Instance->CCMR1;
  2024fa:	6982      	ldr	r2, [r0, #24]
  tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8));
  2024fc:	68a1      	ldr	r1, [r4, #8]
  tmpsmcr |= sConfig->EncoderMode;
  2024fe:	431e      	orrs	r6, r3
  tmpccmr1 &= ~(TIM_CCMR1_CC1S | TIM_CCMR1_CC2S);
  202500:	f422 7240 	bic.w	r2, r2, #768	; 0x300
  tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8));
  202504:	69a3      	ldr	r3, [r4, #24]
  tmpccer = htim->Instance->CCER;
  202506:	6a07      	ldr	r7, [r0, #32]
  tmpccmr1 &= ~(TIM_CCMR1_CC1S | TIM_CCMR1_CC2S);
  202508:	f022 0203 	bic.w	r2, r2, #3
  tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8));
  20250c:	ea41 2303 	orr.w	r3, r1, r3, lsl #8
  tmpccmr1 |= sConfig->IC1Prescaler | (sConfig->IC2Prescaler << 8);
  202510:	69e1      	ldr	r1, [r4, #28]
  tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8));
  202512:	4313      	orrs	r3, r2
  tmpccmr1 &= ~(TIM_CCMR1_IC1F | TIM_CCMR1_IC2F);
  202514:	f423 427c 	bic.w	r2, r3, #64512	; 0xfc00
  tmpccmr1 |= (sConfig->IC1Filter << 4) | (sConfig->IC2Filter << 12);
  202518:	6923      	ldr	r3, [r4, #16]
  20251a:	011b      	lsls	r3, r3, #4
  tmpccmr1 &= ~(TIM_CCMR1_IC1F | TIM_CCMR1_IC2F);
  20251c:	f022 02fc 	bic.w	r2, r2, #252	; 0xfc
  tmpccmr1 |= (sConfig->IC1Filter << 4) | (sConfig->IC2Filter << 12);
  202520:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
  202524:	68e1      	ldr	r1, [r4, #12]
  202526:	430b      	orrs	r3, r1
  202528:	6a21      	ldr	r1, [r4, #32]
  20252a:	ea43 3301 	orr.w	r3, r3, r1, lsl #12
  tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4);
  20252e:	6961      	ldr	r1, [r4, #20]
  tmpccmr1 |= (sConfig->IC1Filter << 4) | (sConfig->IC2Filter << 12);
  202530:	4313      	orrs	r3, r2
  tmpccer &= ~(TIM_CCER_CC1NP | TIM_CCER_CC2NP);
  202532:	f027 02aa 	bic.w	r2, r7, #170	; 0xaa
  tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4);
  202536:	6867      	ldr	r7, [r4, #4]
  htim->Instance->SMCR = tmpsmcr;
  202538:	6086      	str	r6, [r0, #8]
  tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4);
  20253a:	ea47 1701 	orr.w	r7, r7, r1, lsl #4
  htim->Instance->CCMR1 = tmpccmr1;
  20253e:	6183      	str	r3, [r0, #24]
  htim->State= HAL_TIM_STATE_READY;
  202540:	2301      	movs	r3, #1
  tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4);
  202542:	4317      	orrs	r7, r2
  htim->Instance->CCER = tmpccer;
  202544:	6207      	str	r7, [r0, #32]
  return HAL_OK;
  202546:	2000      	movs	r0, #0
  htim->State= HAL_TIM_STATE_READY;
  202548:	f885 303d 	strb.w	r3, [r5, #61]	; 0x3d
  return HAL_OK;
  20254c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return HAL_ERROR;
  20254e:	2001      	movs	r0, #1
}
  202550:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

00202554 <TIM_OC1_SetConfig>:
  TIMx->CCER &= ~TIM_CCER_CC1E;
  202554:	6a03      	ldr	r3, [r0, #32]
  202556:	f023 0301 	bic.w	r3, r3, #1
{
  20255a:	b570      	push	{r4, r5, r6, lr}
  TIMx->CCER &= ~TIM_CCER_CC1E;
  20255c:	6203      	str	r3, [r0, #32]
  tmpccer = TIMx->CCER;
  20255e:	6a03      	ldr	r3, [r0, #32]
  tmpcr2 = TIMx->CR2;
  202560:	6842      	ldr	r2, [r0, #4]
  tmpccmrx = TIMx->CCMR1;
  202562:	6984      	ldr	r4, [r0, #24]
  tmpccer &= ~TIM_CCER_CC1P;
  202564:	f023 0302 	bic.w	r3, r3, #2
  tmpccmrx |= OC_Config->OCMode;
  202568:	680d      	ldr	r5, [r1, #0]
  tmpccmrx &= ~TIM_CCMR1_CC1S;
  20256a:	f424 3480 	bic.w	r4, r4, #65536	; 0x10000
  20256e:	f024 0473 	bic.w	r4, r4, #115	; 0x73
  tmpccmrx |= OC_Config->OCMode;
  202572:	432c      	orrs	r4, r5
  tmpccer |= OC_Config->OCPolarity;
  202574:	688d      	ldr	r5, [r1, #8]
  202576:	432b      	orrs	r3, r5
  if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
  202578:	4d0c      	ldr	r5, [pc, #48]	; (2025ac <TIM_OC1_SetConfig+0x58>)
  20257a:	42a8      	cmp	r0, r5
  20257c:	d009      	beq.n	202592 <TIM_OC1_SetConfig+0x3e>
  20257e:	f505 6580 	add.w	r5, r5, #1024	; 0x400
  202582:	42a8      	cmp	r0, r5
  202584:	d005      	beq.n	202592 <TIM_OC1_SetConfig+0x3e>
  TIMx->CR2 = tmpcr2;
  202586:	6042      	str	r2, [r0, #4]
  TIMx->CCR1 = OC_Config->Pulse;
  202588:	684a      	ldr	r2, [r1, #4]
  TIMx->CCMR1 = tmpccmrx;
  20258a:	6184      	str	r4, [r0, #24]
  TIMx->CCR1 = OC_Config->Pulse;
  20258c:	6342      	str	r2, [r0, #52]	; 0x34
  TIMx->CCER = tmpccer;  
  20258e:	6203      	str	r3, [r0, #32]
} 
  202590:	bd70      	pop	{r4, r5, r6, pc}
    tmpccer |= OC_Config->OCNPolarity;
  202592:	68cd      	ldr	r5, [r1, #12]
    tmpccer &= ~TIM_CCER_CC1NP;
  202594:	f023 0308 	bic.w	r3, r3, #8
    tmpcr2 |= OC_Config->OCNIdleState;
  202598:	698e      	ldr	r6, [r1, #24]
    tmpcr2 &= ~TIM_CR2_OIS1N;
  20259a:	f422 7240 	bic.w	r2, r2, #768	; 0x300
    tmpccer |= OC_Config->OCNPolarity;
  20259e:	432b      	orrs	r3, r5
    tmpcr2 |= OC_Config->OCNIdleState;
  2025a0:	694d      	ldr	r5, [r1, #20]
  2025a2:	4335      	orrs	r5, r6
    tmpccer &= ~TIM_CCER_CC1NE;
  2025a4:	f023 0304 	bic.w	r3, r3, #4
    tmpcr2 |= OC_Config->OCNIdleState;
  2025a8:	432a      	orrs	r2, r5
  2025aa:	e7ec      	b.n	202586 <TIM_OC1_SetConfig+0x32>
  2025ac:	40010000 	.word	0x40010000

002025b0 <TIM_OC2_SetConfig>:
  TIMx->CCER &= ~TIM_CCER_CC2E;
  2025b0:	6a03      	ldr	r3, [r0, #32]
  2025b2:	f023 0310 	bic.w	r3, r3, #16
{
  2025b6:	b570      	push	{r4, r5, r6, lr}
  TIMx->CCER &= ~TIM_CCER_CC2E;
  2025b8:	6203      	str	r3, [r0, #32]
  tmpccer = TIMx->CCER;
  2025ba:	6a03      	ldr	r3, [r0, #32]
  tmpcr2 = TIMx->CR2;
  2025bc:	6842      	ldr	r2, [r0, #4]
  tmpccmrx = TIMx->CCMR1;
  2025be:	6984      	ldr	r4, [r0, #24]
  tmpccer &= ~TIM_CCER_CC2P;
  2025c0:	f023 0320 	bic.w	r3, r3, #32
  tmpccmrx |= (OC_Config->OCMode << 8);
  2025c4:	680d      	ldr	r5, [r1, #0]
  tmpccmrx &= ~TIM_CCMR1_CC2S;
  2025c6:	f024 7480 	bic.w	r4, r4, #16777216	; 0x1000000
  2025ca:	f424 44e6 	bic.w	r4, r4, #29440	; 0x7300
  tmpccmrx |= (OC_Config->OCMode << 8);
  2025ce:	ea44 2405 	orr.w	r4, r4, r5, lsl #8
  tmpccer |= (OC_Config->OCPolarity << 4);
  2025d2:	688d      	ldr	r5, [r1, #8]
  2025d4:	ea43 1305 	orr.w	r3, r3, r5, lsl #4
  if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
  2025d8:	4d0d      	ldr	r5, [pc, #52]	; (202610 <TIM_OC2_SetConfig+0x60>)
  2025da:	42a8      	cmp	r0, r5
  2025dc:	d009      	beq.n	2025f2 <TIM_OC2_SetConfig+0x42>
  2025de:	f505 6580 	add.w	r5, r5, #1024	; 0x400
  2025e2:	42a8      	cmp	r0, r5
  2025e4:	d005      	beq.n	2025f2 <TIM_OC2_SetConfig+0x42>
  TIMx->CR2 = tmpcr2;
  2025e6:	6042      	str	r2, [r0, #4]
  TIMx->CCR2 = OC_Config->Pulse;
  2025e8:	684a      	ldr	r2, [r1, #4]
  TIMx->CCMR1 = tmpccmrx;
  2025ea:	6184      	str	r4, [r0, #24]
  TIMx->CCR2 = OC_Config->Pulse;
  2025ec:	6382      	str	r2, [r0, #56]	; 0x38
  TIMx->CCER = tmpccer;
  2025ee:	6203      	str	r3, [r0, #32]
}
  2025f0:	bd70      	pop	{r4, r5, r6, pc}
    tmpccer |= (OC_Config->OCNPolarity << 4);
  2025f2:	68cd      	ldr	r5, [r1, #12]
    tmpccer &= ~TIM_CCER_CC2NP;
  2025f4:	f023 0380 	bic.w	r3, r3, #128	; 0x80
    tmpcr2 |= (OC_Config->OCNIdleState << 2);
  2025f8:	698e      	ldr	r6, [r1, #24]
    tmpcr2 &= ~TIM_CR2_OIS2N;
  2025fa:	f422 6240 	bic.w	r2, r2, #3072	; 0xc00
    tmpccer |= (OC_Config->OCNPolarity << 4);
  2025fe:	ea43 1305 	orr.w	r3, r3, r5, lsl #4
    tmpcr2 |= (OC_Config->OCIdleState << 2);
  202602:	694d      	ldr	r5, [r1, #20]
    tmpcr2 |= (OC_Config->OCNIdleState << 2);
  202604:	4335      	orrs	r5, r6
    tmpccer &= ~TIM_CCER_CC2NE;
  202606:	f023 0340 	bic.w	r3, r3, #64	; 0x40
    tmpcr2 |= (OC_Config->OCNIdleState << 2);
  20260a:	ea42 0285 	orr.w	r2, r2, r5, lsl #2
  20260e:	e7ea      	b.n	2025e6 <TIM_OC2_SetConfig+0x36>
  202610:	40010000 	.word	0x40010000

00202614 <TIM_OC3_SetConfig>:
  TIMx->CCER &= ~TIM_CCER_CC3E;
  202614:	6a03      	ldr	r3, [r0, #32]
  202616:	f423 7380 	bic.w	r3, r3, #256	; 0x100
{
  20261a:	b570      	push	{r4, r5, r6, lr}
  TIMx->CCER &= ~TIM_CCER_CC3E;
  20261c:	6203      	str	r3, [r0, #32]
  tmpccer = TIMx->CCER;
  20261e:	6a03      	ldr	r3, [r0, #32]
  tmpcr2 = TIMx->CR2;
  202620:	6842      	ldr	r2, [r0, #4]
  tmpccmrx = TIMx->CCMR2;
  202622:	69c4      	ldr	r4, [r0, #28]
  tmpccer &= ~TIM_CCER_CC3P;
  202624:	f423 7300 	bic.w	r3, r3, #512	; 0x200
  tmpccmrx |= OC_Config->OCMode;
  202628:	680d      	ldr	r5, [r1, #0]
  tmpccmrx &= ~TIM_CCMR2_CC3S;  
  20262a:	f424 3480 	bic.w	r4, r4, #65536	; 0x10000
  20262e:	f024 0473 	bic.w	r4, r4, #115	; 0x73
  tmpccmrx |= OC_Config->OCMode;
  202632:	432c      	orrs	r4, r5
  tmpccer |= (OC_Config->OCPolarity << 8);
  202634:	688d      	ldr	r5, [r1, #8]
  202636:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
  if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
  20263a:	4d0e      	ldr	r5, [pc, #56]	; (202674 <TIM_OC3_SetConfig+0x60>)
  20263c:	42a8      	cmp	r0, r5
  20263e:	d009      	beq.n	202654 <TIM_OC3_SetConfig+0x40>
  202640:	f505 6580 	add.w	r5, r5, #1024	; 0x400
  202644:	42a8      	cmp	r0, r5
  202646:	d005      	beq.n	202654 <TIM_OC3_SetConfig+0x40>
  TIMx->CR2 = tmpcr2;
  202648:	6042      	str	r2, [r0, #4]
  TIMx->CCR3 = OC_Config->Pulse;
  20264a:	684a      	ldr	r2, [r1, #4]
  TIMx->CCMR2 = tmpccmrx;
  20264c:	61c4      	str	r4, [r0, #28]
  TIMx->CCR3 = OC_Config->Pulse;
  20264e:	63c2      	str	r2, [r0, #60]	; 0x3c
  TIMx->CCER = tmpccer;
  202650:	6203      	str	r3, [r0, #32]
}
  202652:	bd70      	pop	{r4, r5, r6, pc}
    tmpccer |= (OC_Config->OCNPolarity << 8);
  202654:	68cd      	ldr	r5, [r1, #12]
    tmpccer &= ~TIM_CCER_CC3NP;
  202656:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
    tmpcr2 |= (OC_Config->OCNIdleState << 4);
  20265a:	698e      	ldr	r6, [r1, #24]
    tmpcr2 &= ~TIM_CR2_OIS3N;
  20265c:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
    tmpccer |= (OC_Config->OCNPolarity << 8);
  202660:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
    tmpcr2 |= (OC_Config->OCIdleState << 4);
  202664:	694d      	ldr	r5, [r1, #20]
    tmpcr2 |= (OC_Config->OCNIdleState << 4);
  202666:	4335      	orrs	r5, r6
    tmpccer &= ~TIM_CCER_CC3NE;
  202668:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
    tmpcr2 |= (OC_Config->OCNIdleState << 4);
  20266c:	ea42 1205 	orr.w	r2, r2, r5, lsl #4
  202670:	e7ea      	b.n	202648 <TIM_OC3_SetConfig+0x34>
  202672:	bf00      	nop
  202674:	40010000 	.word	0x40010000

00202678 <TIM_OC4_SetConfig>:
  TIMx->CCER &= ~TIM_CCER_CC4E;
  202678:	6a03      	ldr	r3, [r0, #32]
  20267a:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
{
  20267e:	b530      	push	{r4, r5, lr}
  TIMx->CCER &= ~TIM_CCER_CC4E;
  202680:	6203      	str	r3, [r0, #32]
  tmpccer = TIMx->CCER;
  202682:	6a04      	ldr	r4, [r0, #32]
  tmpcr2 = TIMx->CR2;
  202684:	6842      	ldr	r2, [r0, #4]
  tmpccmrx = TIMx->CCMR2;
  202686:	69c3      	ldr	r3, [r0, #28]
  tmpccer &= ~TIM_CCER_CC4P;
  202688:	f424 5400 	bic.w	r4, r4, #8192	; 0x2000
  tmpccmrx |= (OC_Config->OCMode << 8);
  20268c:	680d      	ldr	r5, [r1, #0]
  tmpccmrx &= ~TIM_CCMR2_CC4S;
  20268e:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
  202692:	f423 43e6 	bic.w	r3, r3, #29440	; 0x7300
  tmpccmrx |= (OC_Config->OCMode << 8);
  202696:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
  tmpccer |= (OC_Config->OCPolarity << 12);
  20269a:	688d      	ldr	r5, [r1, #8]
  20269c:	ea44 3405 	orr.w	r4, r4, r5, lsl #12
  if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
  2026a0:	4d09      	ldr	r5, [pc, #36]	; (2026c8 <TIM_OC4_SetConfig+0x50>)
  2026a2:	42a8      	cmp	r0, r5
  2026a4:	d009      	beq.n	2026ba <TIM_OC4_SetConfig+0x42>
  2026a6:	f505 6580 	add.w	r5, r5, #1024	; 0x400
  2026aa:	42a8      	cmp	r0, r5
  2026ac:	d005      	beq.n	2026ba <TIM_OC4_SetConfig+0x42>
  TIMx->CR2 = tmpcr2;
  2026ae:	6042      	str	r2, [r0, #4]
  TIMx->CCMR2 = tmpccmrx;
  2026b0:	61c3      	str	r3, [r0, #28]
  TIMx->CCR4 = OC_Config->Pulse;
  2026b2:	684b      	ldr	r3, [r1, #4]
  2026b4:	6403      	str	r3, [r0, #64]	; 0x40
  TIMx->CCER = tmpccer;
  2026b6:	6204      	str	r4, [r0, #32]
}
  2026b8:	bd30      	pop	{r4, r5, pc}
    tmpcr2 &= ~TIM_CR2_OIS4;
  2026ba:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
    tmpcr2 |= (OC_Config->OCIdleState << 6);
  2026be:	694d      	ldr	r5, [r1, #20]
  2026c0:	ea42 1285 	orr.w	r2, r2, r5, lsl #6
  2026c4:	e7f3      	b.n	2026ae <TIM_OC4_SetConfig+0x36>
  2026c6:	bf00      	nop
  2026c8:	40010000 	.word	0x40010000

002026cc <TIM_CCxChannelCmd>:
{
  2026cc:	b510      	push	{r4, lr}
  tmp = TIM_CCER_CC1E << Channel;
  2026ce:	2401      	movs	r4, #1
  TIMx->CCER &= ~tmp;
  2026d0:	6a03      	ldr	r3, [r0, #32]
  TIMx->CCER |= (uint32_t)(ChannelState << Channel);
  2026d2:	408a      	lsls	r2, r1
  tmp = TIM_CCER_CC1E << Channel;
  2026d4:	408c      	lsls	r4, r1
  TIMx->CCER &= ~tmp;
  2026d6:	ea23 0304 	bic.w	r3, r3, r4
  2026da:	6203      	str	r3, [r0, #32]
  TIMx->CCER |= (uint32_t)(ChannelState << Channel);
  2026dc:	6a03      	ldr	r3, [r0, #32]
  2026de:	431a      	orrs	r2, r3
  2026e0:	6202      	str	r2, [r0, #32]
  2026e2:	bd10      	pop	{r4, pc}

002026e4 <HAL_TIM_PWM_Start>:
{
  2026e4:	b510      	push	{r4, lr}
  2026e6:	4604      	mov	r4, r0
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
  2026e8:	2201      	movs	r2, #1
  2026ea:	6800      	ldr	r0, [r0, #0]
  2026ec:	f7ff ffee 	bl	2026cc <TIM_CCxChannelCmd>
  if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
  2026f0:	6823      	ldr	r3, [r4, #0]
  2026f2:	4a08      	ldr	r2, [pc, #32]	; (202714 <HAL_TIM_PWM_Start+0x30>)
  2026f4:	4293      	cmp	r3, r2
  2026f6:	d003      	beq.n	202700 <HAL_TIM_PWM_Start+0x1c>
  2026f8:	f502 6280 	add.w	r2, r2, #1024	; 0x400
  2026fc:	4293      	cmp	r3, r2
  2026fe:	d103      	bne.n	202708 <HAL_TIM_PWM_Start+0x24>
    __HAL_TIM_MOE_ENABLE(htim);
  202700:	6c5a      	ldr	r2, [r3, #68]	; 0x44
  202702:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
  202706:	645a      	str	r2, [r3, #68]	; 0x44
  __HAL_TIM_ENABLE(htim);
  202708:	681a      	ldr	r2, [r3, #0]
} 
  20270a:	2000      	movs	r0, #0
  __HAL_TIM_ENABLE(htim);
  20270c:	f042 0201 	orr.w	r2, r2, #1
  202710:	601a      	str	r2, [r3, #0]
} 
  202712:	bd10      	pop	{r4, pc}
  202714:	40010000 	.word	0x40010000

00202718 <TIM_OC5_SetConfig>:
  uint32_t tmpccmrx = 0;
  uint32_t tmpccer = 0;
  uint32_t tmpcr2 = 0; 

  /* Disable the output: Reset the CCxE Bit */
  TIMx->CCER &= ~TIM_CCER_CC5E;
  202718:	6a03      	ldr	r3, [r0, #32]
  20271a:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
{
  20271e:	b530      	push	{r4, r5, lr}
  TIMx->CCER &= ~TIM_CCER_CC5E;
  202720:	6203      	str	r3, [r0, #32]
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
  202722:	6a02      	ldr	r2, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2; 
  202724:	6844      	ldr	r4, [r0, #4]
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR3;
  202726:	6d43      	ldr	r3, [r0, #84]	; 0x54
  tmpccmrx &= ~(TIM_CCMR3_OC5M);
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
  
  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC5P;
  202728:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
  tmpccmrx |= OC_Config->OCMode;
  20272c:	680d      	ldr	r5, [r1, #0]
  tmpccmrx &= ~(TIM_CCMR3_OC5M);
  20272e:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
  202732:	f023 0370 	bic.w	r3, r3, #112	; 0x70
  tmpccmrx |= OC_Config->OCMode;
  202736:	432b      	orrs	r3, r5
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 16);
  202738:	688d      	ldr	r5, [r1, #8]
  20273a:	ea42 4205 	orr.w	r2, r2, r5, lsl #16

  if(IS_TIM_BREAK_INSTANCE(TIMx))
  20273e:	4d09      	ldr	r5, [pc, #36]	; (202764 <TIM_OC5_SetConfig+0x4c>)
  202740:	42a8      	cmp	r0, r5
  202742:	d003      	beq.n	20274c <TIM_OC5_SetConfig+0x34>
  202744:	f505 6580 	add.w	r5, r5, #1024	; 0x400
  202748:	42a8      	cmp	r0, r5
  20274a:	d104      	bne.n	202756 <TIM_OC5_SetConfig+0x3e>
  {   
    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS5;
  20274c:	f424 3480 	bic.w	r4, r4, #65536	; 0x10000
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 8);
  202750:	694d      	ldr	r5, [r1, #20]
  202752:	ea44 2405 	orr.w	r4, r4, r5, lsl #8
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
  202756:	6044      	str	r4, [r0, #4]
  
  /* Write to TIMx CCMR3 */
  TIMx->CCMR3 = tmpccmrx;
  202758:	6543      	str	r3, [r0, #84]	; 0x54
  
  /* Set the Capture Compare Register value */
  TIMx->CCR5 = OC_Config->Pulse;
  20275a:	684b      	ldr	r3, [r1, #4]
  20275c:	6583      	str	r3, [r0, #88]	; 0x58
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;  
  20275e:	6202      	str	r2, [r0, #32]
  202760:	bd30      	pop	{r4, r5, pc}
  202762:	bf00      	nop
  202764:	40010000 	.word	0x40010000

00202768 <TIM_OC6_SetConfig>:
  uint32_t tmpccmrx = 0;
  uint32_t tmpccer = 0;
  uint32_t tmpcr2 = 0; 

  /* Disable the output: Reset the CCxE Bit */
  TIMx->CCER &= ~TIM_CCER_CC6E;
  202768:	6a03      	ldr	r3, [r0, #32]
  20276a:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
{
  20276e:	b530      	push	{r4, r5, lr}
  TIMx->CCER &= ~TIM_CCER_CC6E;
  202770:	6203      	str	r3, [r0, #32]
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
  202772:	6a02      	ldr	r2, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2; 
  202774:	6844      	ldr	r4, [r0, #4]
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR3;
  202776:	6d43      	ldr	r3, [r0, #84]	; 0x54
  tmpccmrx &= ~(TIM_CCMR3_OC6M);
  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8);
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC6P;
  202778:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
  tmpccmrx |= (OC_Config->OCMode << 8);
  20277c:	680d      	ldr	r5, [r1, #0]
  tmpccmrx &= ~(TIM_CCMR3_OC6M);
  20277e:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
  202782:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
  tmpccmrx |= (OC_Config->OCMode << 8);
  202786:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 20);
  20278a:	688d      	ldr	r5, [r1, #8]
  20278c:	ea42 5205 	orr.w	r2, r2, r5, lsl #20

  if(IS_TIM_BREAK_INSTANCE(TIMx))
  202790:	4d08      	ldr	r5, [pc, #32]	; (2027b4 <TIM_OC6_SetConfig+0x4c>)
  202792:	42a8      	cmp	r0, r5
  202794:	d003      	beq.n	20279e <TIM_OC6_SetConfig+0x36>
  202796:	f505 6580 	add.w	r5, r5, #1024	; 0x400
  20279a:	42a8      	cmp	r0, r5
  20279c:	d104      	bne.n	2027a8 <TIM_OC6_SetConfig+0x40>
  {   
    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS6;
  20279e:	f424 2480 	bic.w	r4, r4, #262144	; 0x40000
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 10);
  2027a2:	694d      	ldr	r5, [r1, #20]
  2027a4:	ea44 2485 	orr.w	r4, r4, r5, lsl #10
  }
  
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
  2027a8:	6044      	str	r4, [r0, #4]
  
  /* Write to TIMx CCMR3 */
  TIMx->CCMR3 = tmpccmrx;
  2027aa:	6543      	str	r3, [r0, #84]	; 0x54
  
  /* Set the Capture Compare Register value */
  TIMx->CCR6 = OC_Config->Pulse;
  2027ac:	684b      	ldr	r3, [r1, #4]
  2027ae:	65c3      	str	r3, [r0, #92]	; 0x5c
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;  
  2027b0:	6202      	str	r2, [r0, #32]
  2027b2:	bd30      	pop	{r4, r5, pc}
  2027b4:	40010000 	.word	0x40010000

002027b8 <HAL_TIMEx_MasterConfigSynchronization>:
  __HAL_LOCK(htim);
  2027b8:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
  2027bc:	2b01      	cmp	r3, #1
{
  2027be:	b530      	push	{r4, r5, lr}
  __HAL_LOCK(htim);
  2027c0:	d01c      	beq.n	2027fc <HAL_TIMEx_MasterConfigSynchronization+0x44>
  tmpcr2 = htim->Instance->CR2;
  2027c2:	6802      	ldr	r2, [r0, #0]
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
  2027c4:	4d0e      	ldr	r5, [pc, #56]	; (202800 <HAL_TIMEx_MasterConfigSynchronization+0x48>)
  tmpcr2 = htim->Instance->CR2;
  2027c6:	6853      	ldr	r3, [r2, #4]
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
  2027c8:	42aa      	cmp	r2, r5
  tmpsmcr = htim->Instance->SMCR;
  2027ca:	6894      	ldr	r4, [r2, #8]
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
  2027cc:	d003      	beq.n	2027d6 <HAL_TIMEx_MasterConfigSynchronization+0x1e>
  2027ce:	f505 6580 	add.w	r5, r5, #1024	; 0x400
  2027d2:	42aa      	cmp	r2, r5
  2027d4:	d103      	bne.n	2027de <HAL_TIMEx_MasterConfigSynchronization+0x26>
    tmpcr2 &= ~TIM_CR2_MMS2;
  2027d6:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
  2027da:	684d      	ldr	r5, [r1, #4]
  2027dc:	432b      	orrs	r3, r5
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
  2027de:	680d      	ldr	r5, [r1, #0]
  tmpcr2 &= ~TIM_CR2_MMS;
  2027e0:	f023 0370 	bic.w	r3, r3, #112	; 0x70
  tmpsmcr |= sMasterConfig->MasterSlaveMode;
  2027e4:	6889      	ldr	r1, [r1, #8]
  tmpsmcr &= ~TIM_SMCR_MSM;
  2027e6:	f024 0480 	bic.w	r4, r4, #128	; 0x80
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
  2027ea:	432b      	orrs	r3, r5
  tmpsmcr |= sMasterConfig->MasterSlaveMode;
  2027ec:	4321      	orrs	r1, r4
  htim->Instance->CR2 = tmpcr2;
  2027ee:	6053      	str	r3, [r2, #4]
  __HAL_UNLOCK(htim);
  2027f0:	2300      	movs	r3, #0
  htim->Instance->SMCR = tmpsmcr;
  2027f2:	6091      	str	r1, [r2, #8]
  __HAL_UNLOCK(htim);
  2027f4:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  return HAL_OK;
  2027f8:	4618      	mov	r0, r3
  2027fa:	bd30      	pop	{r4, r5, pc}
  __HAL_LOCK(htim);
  2027fc:	2002      	movs	r0, #2
} 
  2027fe:	bd30      	pop	{r4, r5, pc}
  202800:	40010000 	.word	0x40010000

00202804 <HAL_TIMEx_ConfigBreakDeadTime>:
  __HAL_LOCK(htim);
  202804:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
  202808:	2b01      	cmp	r3, #1
  20280a:	f04f 0302 	mov.w	r3, #2
{
  20280e:	b510      	push	{r4, lr}
  __HAL_LOCK(htim);
  202810:	d038      	beq.n	202884 <HAL_TIMEx_ConfigBreakDeadTime+0x80>
  htim->State = HAL_TIM_STATE_BUSY;
  202812:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
  MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, sBreakDeadTimeConfig->LockLevel);
  202816:	68cb      	ldr	r3, [r1, #12]
  202818:	688a      	ldr	r2, [r1, #8]
  20281a:	f423 7340 	bic.w	r3, r3, #768	; 0x300
  if (IS_TIM_BKIN2_INSTANCE(htim->Instance))
  20281e:	4c1a      	ldr	r4, [pc, #104]	; (202888 <HAL_TIMEx_ConfigBreakDeadTime+0x84>)
  MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, sBreakDeadTimeConfig->LockLevel);
  202820:	4313      	orrs	r3, r2
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSI, sBreakDeadTimeConfig->OffStateIDLEMode);
  202822:	684a      	ldr	r2, [r1, #4]
  202824:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
  202828:	4313      	orrs	r3, r2
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSR, sBreakDeadTimeConfig->OffStateRunMode);
  20282a:	680a      	ldr	r2, [r1, #0]
  20282c:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
  202830:	4313      	orrs	r3, r2
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKE, sBreakDeadTimeConfig->BreakState);
  202832:	690a      	ldr	r2, [r1, #16]
  202834:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
  202838:	4313      	orrs	r3, r2
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, sBreakDeadTimeConfig->BreakPolarity);
  20283a:	694a      	ldr	r2, [r1, #20]
  20283c:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
  202840:	4313      	orrs	r3, r2
  MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);
  202842:	6a8a      	ldr	r2, [r1, #40]	; 0x28
  MODIFY_REG(tmpbdtr, TIM_BDTR_MOE, sBreakDeadTimeConfig->AutomaticOutput);
  202844:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
  202848:	4313      	orrs	r3, r2
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKF, (sBreakDeadTimeConfig->BreakFilter << BDTR_BKF_SHIFT));
  20284a:	698a      	ldr	r2, [r1, #24]
  20284c:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
  202850:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  if (IS_TIM_BKIN2_INSTANCE(htim->Instance))
  202854:	6802      	ldr	r2, [r0, #0]
  202856:	42a2      	cmp	r2, r4
  202858:	d003      	beq.n	202862 <HAL_TIMEx_ConfigBreakDeadTime+0x5e>
  20285a:	f504 6480 	add.w	r4, r4, #1024	; 0x400
  20285e:	42a2      	cmp	r2, r4
  202860:	d10c      	bne.n	20287c <HAL_TIMEx_ConfigBreakDeadTime+0x78>
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2F, (sBreakDeadTimeConfig->Break2Filter << BDTR_BK2F_SHIFT));
  202862:	6a4c      	ldr	r4, [r1, #36]	; 0x24
  202864:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
  202868:	ea43 5304 	orr.w	r3, r3, r4, lsl #20
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2E, sBreakDeadTimeConfig->Break2State);
  20286c:	69cc      	ldr	r4, [r1, #28]
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2P, sBreakDeadTimeConfig->Break2Polarity);
  20286e:	6a09      	ldr	r1, [r1, #32]
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2E, sBreakDeadTimeConfig->Break2State);
  202870:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
  202874:	4323      	orrs	r3, r4
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2P, sBreakDeadTimeConfig->Break2Polarity);
  202876:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
  20287a:	430b      	orrs	r3, r1
  htim->Instance->BDTR = tmpbdtr;
  20287c:	6453      	str	r3, [r2, #68]	; 0x44
  __HAL_UNLOCK(htim);
  20287e:	2300      	movs	r3, #0
  202880:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  __HAL_LOCK(htim);
  202884:	4618      	mov	r0, r3
}
  202886:	bd10      	pop	{r4, pc}
  202888:	40010000 	.word	0x40010000

0020288c <HAL_TIMEx_CommutationCallback>:
  20288c:	4770      	bx	lr

0020288e <HAL_TIMEx_BreakCallback>:
{
  20288e:	4770      	bx	lr

00202890 <HAL_TIM_PWM_ConfigChannel>:
{
  202890:	b538      	push	{r3, r4, r5, lr}
  __HAL_LOCK(htim);
  202892:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
{
  202896:	4604      	mov	r4, r0
  202898:	460d      	mov	r5, r1
  20289a:	2002      	movs	r0, #2
  __HAL_LOCK(htim);
  20289c:	2b01      	cmp	r3, #1
  20289e:	d010      	beq.n	2028c2 <HAL_TIM_PWM_ConfigChannel+0x32>
  2028a0:	2301      	movs	r3, #1
  switch (Channel)
  2028a2:	2a08      	cmp	r2, #8
  htim->State = HAL_TIM_STATE_BUSY;
  2028a4:	f884 003d 	strb.w	r0, [r4, #61]	; 0x3d
  __HAL_LOCK(htim);
  2028a8:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
  switch (Channel)
  2028ac:	d043      	beq.n	202936 <HAL_TIM_PWM_ConfigChannel+0xa6>
  2028ae:	d809      	bhi.n	2028c4 <HAL_TIM_PWM_ConfigChannel+0x34>
  2028b0:	b1fa      	cbz	r2, 2028f2 <HAL_TIM_PWM_ConfigChannel+0x62>
  2028b2:	2a04      	cmp	r2, #4
  2028b4:	d02e      	beq.n	202914 <HAL_TIM_PWM_ConfigChannel+0x84>
  htim->State = HAL_TIM_STATE_READY;
  2028b6:	2301      	movs	r3, #1
  __HAL_UNLOCK(htim);
  2028b8:	2000      	movs	r0, #0
  htim->State = HAL_TIM_STATE_READY;
  2028ba:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  __HAL_UNLOCK(htim);
  2028be:	f884 003c 	strb.w	r0, [r4, #60]	; 0x3c
}
  2028c2:	bd38      	pop	{r3, r4, r5, pc}
  switch (Channel)
  2028c4:	2a10      	cmp	r2, #16
  2028c6:	d047      	beq.n	202958 <HAL_TIM_PWM_ConfigChannel+0xc8>
  2028c8:	2a14      	cmp	r2, #20
  2028ca:	d056      	beq.n	20297a <HAL_TIM_PWM_ConfigChannel+0xea>
  2028cc:	2a0c      	cmp	r2, #12
  2028ce:	d1f2      	bne.n	2028b6 <HAL_TIM_PWM_ConfigChannel+0x26>
      TIM_OC4_SetConfig(htim->Instance, sConfig);
  2028d0:	6820      	ldr	r0, [r4, #0]
  2028d2:	f7ff fed1 	bl	202678 <TIM_OC4_SetConfig>
      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
  2028d6:	6823      	ldr	r3, [r4, #0]
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8;  
  2028d8:	6929      	ldr	r1, [r5, #16]
      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
  2028da:	69da      	ldr	r2, [r3, #28]
  2028dc:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
  2028e0:	61da      	str	r2, [r3, #28]
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
  2028e2:	69da      	ldr	r2, [r3, #28]
  2028e4:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
  2028e8:	61da      	str	r2, [r3, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8;  
  2028ea:	69da      	ldr	r2, [r3, #28]
  2028ec:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
  2028f0:	e030      	b.n	202954 <HAL_TIM_PWM_ConfigChannel+0xc4>
      TIM_OC1_SetConfig(htim->Instance, sConfig);
  2028f2:	6820      	ldr	r0, [r4, #0]
  2028f4:	f7ff fe2e 	bl	202554 <TIM_OC1_SetConfig>
      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
  2028f8:	6823      	ldr	r3, [r4, #0]
      htim->Instance->CCMR1 |= sConfig->OCFastMode;
  2028fa:	6929      	ldr	r1, [r5, #16]
      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
  2028fc:	699a      	ldr	r2, [r3, #24]
  2028fe:	f042 0208 	orr.w	r2, r2, #8
  202902:	619a      	str	r2, [r3, #24]
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
  202904:	699a      	ldr	r2, [r3, #24]
  202906:	f022 0204 	bic.w	r2, r2, #4
  20290a:	619a      	str	r2, [r3, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode;
  20290c:	699a      	ldr	r2, [r3, #24]
  20290e:	430a      	orrs	r2, r1
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8;
  202910:	619a      	str	r2, [r3, #24]
    break;
  202912:	e7d0      	b.n	2028b6 <HAL_TIM_PWM_ConfigChannel+0x26>
      TIM_OC2_SetConfig(htim->Instance, sConfig);
  202914:	6820      	ldr	r0, [r4, #0]
  202916:	f7ff fe4b 	bl	2025b0 <TIM_OC2_SetConfig>
      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
  20291a:	6823      	ldr	r3, [r4, #0]
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8;
  20291c:	6929      	ldr	r1, [r5, #16]
      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
  20291e:	699a      	ldr	r2, [r3, #24]
  202920:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
  202924:	619a      	str	r2, [r3, #24]
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
  202926:	699a      	ldr	r2, [r3, #24]
  202928:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
  20292c:	619a      	str	r2, [r3, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8;
  20292e:	699a      	ldr	r2, [r3, #24]
  202930:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
  202934:	e7ec      	b.n	202910 <HAL_TIM_PWM_ConfigChannel+0x80>
      TIM_OC3_SetConfig(htim->Instance, sConfig);
  202936:	6820      	ldr	r0, [r4, #0]
  202938:	f7ff fe6c 	bl	202614 <TIM_OC3_SetConfig>
      htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
  20293c:	6823      	ldr	r3, [r4, #0]
      htim->Instance->CCMR2 |= sConfig->OCFastMode;  
  20293e:	6929      	ldr	r1, [r5, #16]
      htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
  202940:	69da      	ldr	r2, [r3, #28]
  202942:	f042 0208 	orr.w	r2, r2, #8
  202946:	61da      	str	r2, [r3, #28]
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
  202948:	69da      	ldr	r2, [r3, #28]
  20294a:	f022 0204 	bic.w	r2, r2, #4
  20294e:	61da      	str	r2, [r3, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode;  
  202950:	69da      	ldr	r2, [r3, #28]
  202952:	430a      	orrs	r2, r1
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8;  
  202954:	61da      	str	r2, [r3, #28]
    break;
  202956:	e7ae      	b.n	2028b6 <HAL_TIM_PWM_ConfigChannel+0x26>
      TIM_OC5_SetConfig(htim->Instance, sConfig);
  202958:	6820      	ldr	r0, [r4, #0]
  20295a:	f7ff fedd 	bl	202718 <TIM_OC5_SetConfig>
      htim->Instance->CCMR3 |= TIM_CCMR3_OC5PE;
  20295e:	6823      	ldr	r3, [r4, #0]
      htim->Instance->CCMR3 |= sConfig->OCFastMode;  
  202960:	6909      	ldr	r1, [r1, #16]
      htim->Instance->CCMR3 |= TIM_CCMR3_OC5PE;
  202962:	6d5a      	ldr	r2, [r3, #84]	; 0x54
  202964:	f042 0208 	orr.w	r2, r2, #8
  202968:	655a      	str	r2, [r3, #84]	; 0x54
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC5FE;
  20296a:	6d5a      	ldr	r2, [r3, #84]	; 0x54
  20296c:	f022 0204 	bic.w	r2, r2, #4
  202970:	655a      	str	r2, [r3, #84]	; 0x54
      htim->Instance->CCMR3 |= sConfig->OCFastMode;  
  202972:	6d5a      	ldr	r2, [r3, #84]	; 0x54
  202974:	430a      	orrs	r2, r1
      htim->Instance->CCMR3 |= sConfig->OCFastMode << 8;  
  202976:	655a      	str	r2, [r3, #84]	; 0x54
    break;
  202978:	e79d      	b.n	2028b6 <HAL_TIM_PWM_ConfigChannel+0x26>
      TIM_OC6_SetConfig(htim->Instance, sConfig);
  20297a:	6820      	ldr	r0, [r4, #0]
  20297c:	f7ff fef4 	bl	202768 <TIM_OC6_SetConfig>
      htim->Instance->CCMR3 |= TIM_CCMR3_OC6PE;
  202980:	6823      	ldr	r3, [r4, #0]
      htim->Instance->CCMR3 |= sConfig->OCFastMode << 8;  
  202982:	6909      	ldr	r1, [r1, #16]
      htim->Instance->CCMR3 |= TIM_CCMR3_OC6PE;
  202984:	6d5a      	ldr	r2, [r3, #84]	; 0x54
  202986:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
  20298a:	655a      	str	r2, [r3, #84]	; 0x54
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC6FE;
  20298c:	6d5a      	ldr	r2, [r3, #84]	; 0x54
  20298e:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
  202992:	655a      	str	r2, [r3, #84]	; 0x54
      htim->Instance->CCMR3 |= sConfig->OCFastMode << 8;  
  202994:	6d5a      	ldr	r2, [r3, #84]	; 0x54
  202996:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
  20299a:	e7ec      	b.n	202976 <HAL_TIM_PWM_ConfigChannel+0xe6>

0020299c <UART_EndRxTransfer>:
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
  20299c:	6803      	ldr	r3, [r0, #0]
  20299e:	681a      	ldr	r2, [r3, #0]
  2029a0:	f422 7290 	bic.w	r2, r2, #288	; 0x120
  2029a4:	601a      	str	r2, [r3, #0]
  CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
  2029a6:	689a      	ldr	r2, [r3, #8]
  2029a8:	f022 0201 	bic.w	r2, r2, #1
  2029ac:	609a      	str	r2, [r3, #8]

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
  2029ae:	2320      	movs	r3, #32
  2029b0:	f880 306a 	strb.w	r3, [r0, #106]	; 0x6a
  2029b4:	4770      	bx	lr
	...

002029b8 <HAL_UART_Receive_DMA>:
{
  2029b8:	4613      	mov	r3, r2
  if(huart->RxState == HAL_UART_STATE_READY)
  2029ba:	f890 206a 	ldrb.w	r2, [r0, #106]	; 0x6a
  2029be:	2a20      	cmp	r2, #32
{
  2029c0:	b570      	push	{r4, r5, r6, lr}
  2029c2:	4604      	mov	r4, r0
  if(huart->RxState == HAL_UART_STATE_READY)
  2029c4:	d133      	bne.n	202a2e <HAL_UART_Receive_DMA+0x76>
    if((pData == NULL ) || (Size == 0U))
  2029c6:	2900      	cmp	r1, #0
  2029c8:	d02f      	beq.n	202a2a <HAL_UART_Receive_DMA+0x72>
  2029ca:	2b00      	cmp	r3, #0
  2029cc:	d02d      	beq.n	202a2a <HAL_UART_Receive_DMA+0x72>
    __HAL_LOCK(huart);
  2029ce:	f890 2068 	ldrb.w	r2, [r0, #104]	; 0x68
  2029d2:	2a01      	cmp	r2, #1
  2029d4:	d02b      	beq.n	202a2e <HAL_UART_Receive_DMA+0x76>
  2029d6:	2201      	movs	r2, #1
    huart->ErrorCode = HAL_UART_ERROR_NONE;
  2029d8:	2500      	movs	r5, #0
    huart->pRxBuffPtr = pData;
  2029da:	6541      	str	r1, [r0, #84]	; 0x54
    __HAL_LOCK(huart);
  2029dc:	f880 2068 	strb.w	r2, [r0, #104]	; 0x68
    huart->RxState = HAL_UART_STATE_BUSY_RX;
  2029e0:	2222      	movs	r2, #34	; 0x22
    huart->ErrorCode = HAL_UART_ERROR_NONE;
  2029e2:	66c5      	str	r5, [r0, #108]	; 0x6c
    huart->RxXferSize = Size;
  2029e4:	f8a0 3058 	strh.w	r3, [r0, #88]	; 0x58
    huart->RxState = HAL_UART_STATE_BUSY_RX;
  2029e8:	f880 206a 	strb.w	r2, [r0, #106]	; 0x6a
    huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
  2029ec:	6e40      	ldr	r0, [r0, #100]	; 0x64
  2029ee:	4a11      	ldr	r2, [pc, #68]	; (202a34 <HAL_UART_Receive_DMA+0x7c>)
    HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->RDR, *(uint32_t*)tmp, Size);
  2029f0:	6826      	ldr	r6, [r4, #0]
    huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
  2029f2:	63c2      	str	r2, [r0, #60]	; 0x3c
    huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
  2029f4:	4a10      	ldr	r2, [pc, #64]	; (202a38 <HAL_UART_Receive_DMA+0x80>)
    huart->hdmarx->XferAbortCallback = NULL;
  2029f6:	6505      	str	r5, [r0, #80]	; 0x50
    huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
  2029f8:	6402      	str	r2, [r0, #64]	; 0x40
    huart->hdmarx->XferErrorCallback = UART_DMAError;
  2029fa:	4a10      	ldr	r2, [pc, #64]	; (202a3c <HAL_UART_Receive_DMA+0x84>)
  2029fc:	64c2      	str	r2, [r0, #76]	; 0x4c
    HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->RDR, *(uint32_t*)tmp, Size);
  2029fe:	460a      	mov	r2, r1
  202a00:	f106 0124 	add.w	r1, r6, #36	; 0x24
  202a04:	f7fe f96e 	bl	200ce4 <HAL_DMA_Start_IT>
    SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
  202a08:	6823      	ldr	r3, [r4, #0]
    __HAL_UNLOCK(huart);
  202a0a:	f884 5068 	strb.w	r5, [r4, #104]	; 0x68
    return HAL_OK;
  202a0e:	4628      	mov	r0, r5
    SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
  202a10:	681a      	ldr	r2, [r3, #0]
  202a12:	f442 7280 	orr.w	r2, r2, #256	; 0x100
  202a16:	601a      	str	r2, [r3, #0]
    SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
  202a18:	689a      	ldr	r2, [r3, #8]
  202a1a:	f042 0201 	orr.w	r2, r2, #1
  202a1e:	609a      	str	r2, [r3, #8]
    SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
  202a20:	689a      	ldr	r2, [r3, #8]
  202a22:	f042 0240 	orr.w	r2, r2, #64	; 0x40
  202a26:	609a      	str	r2, [r3, #8]
    return HAL_OK;
  202a28:	bd70      	pop	{r4, r5, r6, pc}
      return HAL_ERROR;
  202a2a:	2001      	movs	r0, #1
  202a2c:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_BUSY;
  202a2e:	2002      	movs	r0, #2
}
  202a30:	bd70      	pop	{r4, r5, r6, pc}
  202a32:	bf00      	nop
  202a34:	00202b57 	.word	0x00202b57
  202a38:	00202c01 	.word	0x00202c01
  202a3c:	00202c0d 	.word	0x00202c0d

00202a40 <UART_WaitOnFlagUntilTimeout>:
{
  202a40:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  202a44:	9d06      	ldr	r5, [sp, #24]
  202a46:	4604      	mov	r4, r0
  202a48:	460f      	mov	r7, r1
  202a4a:	4616      	mov	r6, r2
  202a4c:	4698      	mov	r8, r3
  while((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
  202a4e:	6821      	ldr	r1, [r4, #0]
  202a50:	69ca      	ldr	r2, [r1, #28]
  202a52:	ea37 0302 	bics.w	r3, r7, r2
  202a56:	bf0c      	ite	eq
  202a58:	2201      	moveq	r2, #1
  202a5a:	2200      	movne	r2, #0
  202a5c:	42b2      	cmp	r2, r6
  202a5e:	d002      	beq.n	202a66 <UART_WaitOnFlagUntilTimeout+0x26>
  return HAL_OK;
  202a60:	2000      	movs	r0, #0
}
  202a62:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if(Timeout != HAL_MAX_DELAY)
  202a66:	1c6b      	adds	r3, r5, #1
  202a68:	d0f2      	beq.n	202a50 <UART_WaitOnFlagUntilTimeout+0x10>
      if((Timeout == 0U)||((HAL_GetTick()-Tickstart) >=  Timeout))
  202a6a:	b99d      	cbnz	r5, 202a94 <UART_WaitOnFlagUntilTimeout+0x54>
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
  202a6c:	6823      	ldr	r3, [r4, #0]
        __HAL_UNLOCK(huart);
  202a6e:	2003      	movs	r0, #3
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
  202a70:	681a      	ldr	r2, [r3, #0]
  202a72:	f422 72d0 	bic.w	r2, r2, #416	; 0x1a0
  202a76:	601a      	str	r2, [r3, #0]
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
  202a78:	689a      	ldr	r2, [r3, #8]
  202a7a:	f022 0201 	bic.w	r2, r2, #1
  202a7e:	609a      	str	r2, [r3, #8]
        huart->gState = HAL_UART_STATE_READY;
  202a80:	2320      	movs	r3, #32
  202a82:	f884 3069 	strb.w	r3, [r4, #105]	; 0x69
        huart->RxState = HAL_UART_STATE_READY;
  202a86:	f884 306a 	strb.w	r3, [r4, #106]	; 0x6a
        __HAL_UNLOCK(huart);
  202a8a:	2300      	movs	r3, #0
  202a8c:	f884 3068 	strb.w	r3, [r4, #104]	; 0x68
  202a90:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if((Timeout == 0U)||((HAL_GetTick()-Tickstart) >=  Timeout))
  202a94:	f7fe f800 	bl	200a98 <HAL_GetTick>
  202a98:	eba0 0008 	sub.w	r0, r0, r8
  202a9c:	4285      	cmp	r5, r0
  202a9e:	d8d6      	bhi.n	202a4e <UART_WaitOnFlagUntilTimeout+0xe>
  202aa0:	e7e4      	b.n	202a6c <UART_WaitOnFlagUntilTimeout+0x2c>

00202aa2 <HAL_UART_Transmit>:
{
  202aa2:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  202aa6:	461f      	mov	r7, r3
  if(huart->gState == HAL_UART_STATE_READY)
  202aa8:	f890 3069 	ldrb.w	r3, [r0, #105]	; 0x69
{
  202aac:	4604      	mov	r4, r0
  202aae:	460d      	mov	r5, r1
  if(huart->gState == HAL_UART_STATE_READY)
  202ab0:	2b20      	cmp	r3, #32
{
  202ab2:	4690      	mov	r8, r2
  if(huart->gState == HAL_UART_STATE_READY)
  202ab4:	d14c      	bne.n	202b50 <HAL_UART_Transmit+0xae>
    if((pData == NULL ) || (Size == 0U))
  202ab6:	2900      	cmp	r1, #0
  202ab8:	d048      	beq.n	202b4c <HAL_UART_Transmit+0xaa>
  202aba:	2a00      	cmp	r2, #0
  202abc:	d046      	beq.n	202b4c <HAL_UART_Transmit+0xaa>
    __HAL_LOCK(huart);
  202abe:	f890 3068 	ldrb.w	r3, [r0, #104]	; 0x68
  202ac2:	2b01      	cmp	r3, #1
  202ac4:	d044      	beq.n	202b50 <HAL_UART_Transmit+0xae>
  202ac6:	2301      	movs	r3, #1
  202ac8:	f880 3068 	strb.w	r3, [r0, #104]	; 0x68
    huart->ErrorCode = HAL_UART_ERROR_NONE;
  202acc:	2300      	movs	r3, #0
  202ace:	66c3      	str	r3, [r0, #108]	; 0x6c
    huart->gState = HAL_UART_STATE_BUSY_TX;
  202ad0:	2321      	movs	r3, #33	; 0x21
  202ad2:	f880 3069 	strb.w	r3, [r0, #105]	; 0x69
    tickstart = HAL_GetTick();
  202ad6:	f7fd ffdf 	bl	200a98 <HAL_GetTick>
  202ada:	4606      	mov	r6, r0
    huart->TxXferSize = Size;
  202adc:	f8a4 8050 	strh.w	r8, [r4, #80]	; 0x50
    huart->TxXferCount = Size;
  202ae0:	f8a4 8052 	strh.w	r8, [r4, #82]	; 0x52
    while(huart->TxXferCount > 0U)
  202ae4:	f8b4 2052 	ldrh.w	r2, [r4, #82]	; 0x52
  202ae8:	b292      	uxth	r2, r2
  202aea:	b962      	cbnz	r2, 202b06 <HAL_UART_Transmit+0x64>
    if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
  202aec:	9700      	str	r7, [sp, #0]
  202aee:	4633      	mov	r3, r6
  202af0:	2140      	movs	r1, #64	; 0x40
  202af2:	4620      	mov	r0, r4
  202af4:	f7ff ffa4 	bl	202a40 <UART_WaitOnFlagUntilTimeout>
  202af8:	b998      	cbnz	r0, 202b22 <HAL_UART_Transmit+0x80>
    huart->gState = HAL_UART_STATE_READY;
  202afa:	2320      	movs	r3, #32
    __HAL_UNLOCK(huart);
  202afc:	f884 0068 	strb.w	r0, [r4, #104]	; 0x68
    huart->gState = HAL_UART_STATE_READY;
  202b00:	f884 3069 	strb.w	r3, [r4, #105]	; 0x69
    return HAL_OK;
  202b04:	e00e      	b.n	202b24 <HAL_UART_Transmit+0x82>
      huart->TxXferCount--;
  202b06:	f8b4 3052 	ldrh.w	r3, [r4, #82]	; 0x52
      if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
  202b0a:	2200      	movs	r2, #0
  202b0c:	9700      	str	r7, [sp, #0]
  202b0e:	2180      	movs	r1, #128	; 0x80
      huart->TxXferCount--;
  202b10:	3b01      	subs	r3, #1
      if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
  202b12:	4620      	mov	r0, r4
      huart->TxXferCount--;
  202b14:	b29b      	uxth	r3, r3
  202b16:	f8a4 3052 	strh.w	r3, [r4, #82]	; 0x52
      if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
  202b1a:	4633      	mov	r3, r6
  202b1c:	f7ff ff90 	bl	202a40 <UART_WaitOnFlagUntilTimeout>
  202b20:	b118      	cbz	r0, 202b2a <HAL_UART_Transmit+0x88>
        return HAL_TIMEOUT;
  202b22:	2003      	movs	r0, #3
}
  202b24:	b002      	add	sp, #8
  202b26:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
  202b2a:	68a3      	ldr	r3, [r4, #8]
  202b2c:	6822      	ldr	r2, [r4, #0]
  202b2e:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
  202b32:	d107      	bne.n	202b44 <HAL_UART_Transmit+0xa2>
  202b34:	6923      	ldr	r3, [r4, #16]
  202b36:	b92b      	cbnz	r3, 202b44 <HAL_UART_Transmit+0xa2>
        huart->Instance->TDR = (*tmp & (uint16_t)0x01FFU);
  202b38:	f835 3b02 	ldrh.w	r3, [r5], #2
  202b3c:	f3c3 0308 	ubfx	r3, r3, #0, #9
  202b40:	6293      	str	r3, [r2, #40]	; 0x28
        pData += 2;
  202b42:	e7cf      	b.n	202ae4 <HAL_UART_Transmit+0x42>
        huart->Instance->TDR = (*pData++ & (uint8_t)0xFFU);
  202b44:	782b      	ldrb	r3, [r5, #0]
  202b46:	3501      	adds	r5, #1
  202b48:	6293      	str	r3, [r2, #40]	; 0x28
  202b4a:	e7cb      	b.n	202ae4 <HAL_UART_Transmit+0x42>
      return  HAL_ERROR;
  202b4c:	2001      	movs	r0, #1
  202b4e:	e7e9      	b.n	202b24 <HAL_UART_Transmit+0x82>
    return HAL_BUSY;
  202b50:	2002      	movs	r0, #2
  202b52:	e7e7      	b.n	202b24 <HAL_UART_Transmit+0x82>

00202b54 <HAL_UART_TxCpltCallback>:
  202b54:	4770      	bx	lr

00202b56 <UART_DMAReceiveCplt>:
{
  202b56:	b508      	push	{r3, lr}
  if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
  202b58:	6803      	ldr	r3, [r0, #0]
  UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
  202b5a:	6b82      	ldr	r2, [r0, #56]	; 0x38
  if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
  202b5c:	681b      	ldr	r3, [r3, #0]
  202b5e:	f413 7380 	ands.w	r3, r3, #256	; 0x100
  202b62:	d111      	bne.n	202b88 <UART_DMAReceiveCplt+0x32>
    huart->RxXferCount = 0U;
  202b64:	f8a2 305a 	strh.w	r3, [r2, #90]	; 0x5a
    CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
  202b68:	6813      	ldr	r3, [r2, #0]
  202b6a:	6819      	ldr	r1, [r3, #0]
  202b6c:	f421 7180 	bic.w	r1, r1, #256	; 0x100
  202b70:	6019      	str	r1, [r3, #0]
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
  202b72:	6899      	ldr	r1, [r3, #8]
  202b74:	f021 0101 	bic.w	r1, r1, #1
  202b78:	6099      	str	r1, [r3, #8]
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
  202b7a:	6899      	ldr	r1, [r3, #8]
  202b7c:	f021 0140 	bic.w	r1, r1, #64	; 0x40
  202b80:	6099      	str	r1, [r3, #8]
    huart->RxState = HAL_UART_STATE_READY;
  202b82:	2320      	movs	r3, #32
  202b84:	f882 306a 	strb.w	r3, [r2, #106]	; 0x6a
  HAL_UART_RxCpltCallback(huart);
  202b88:	4610      	mov	r0, r2
  202b8a:	f002 f95b 	bl	204e44 <HAL_UART_RxCpltCallback>
  202b8e:	bd08      	pop	{r3, pc}

00202b90 <UART_Receive_IT>:
  if(huart->RxState == HAL_UART_STATE_BUSY_RX)
  202b90:	f890 306a 	ldrb.w	r3, [r0, #106]	; 0x6a
  202b94:	6802      	ldr	r2, [r0, #0]
  202b96:	2b22      	cmp	r3, #34	; 0x22
{
  202b98:	b510      	push	{r4, lr}
  if(huart->RxState == HAL_UART_STATE_BUSY_RX)
  202b9a:	d12a      	bne.n	202bf2 <UART_Receive_IT+0x62>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
  202b9c:	6883      	ldr	r3, [r0, #8]
  uint16_t uhMask = huart->Mask;
  202b9e:	f8b0 105c 	ldrh.w	r1, [r0, #92]	; 0x5c
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
  202ba2:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
  202ba6:	6d43      	ldr	r3, [r0, #84]	; 0x54
  202ba8:	d11d      	bne.n	202be6 <UART_Receive_IT+0x56>
  202baa:	6904      	ldr	r4, [r0, #16]
  202bac:	b9dc      	cbnz	r4, 202be6 <UART_Receive_IT+0x56>
      *tmp = (uint16_t)(huart->Instance->RDR & uhMask);
  202bae:	6a52      	ldr	r2, [r2, #36]	; 0x24
  202bb0:	4011      	ands	r1, r2
  202bb2:	f823 1b02 	strh.w	r1, [r3], #2
      huart->pRxBuffPtr +=2;
  202bb6:	6543      	str	r3, [r0, #84]	; 0x54
    if(--huart->RxXferCount == 0)
  202bb8:	f8b0 405a 	ldrh.w	r4, [r0, #90]	; 0x5a
  202bbc:	3c01      	subs	r4, #1
  202bbe:	b2a4      	uxth	r4, r4
  202bc0:	f8a0 405a 	strh.w	r4, [r0, #90]	; 0x5a
  202bc4:	b96c      	cbnz	r4, 202be2 <UART_Receive_IT+0x52>
      CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
  202bc6:	6803      	ldr	r3, [r0, #0]
  202bc8:	681a      	ldr	r2, [r3, #0]
  202bca:	f422 7290 	bic.w	r2, r2, #288	; 0x120
  202bce:	601a      	str	r2, [r3, #0]
      CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
  202bd0:	689a      	ldr	r2, [r3, #8]
  202bd2:	f022 0201 	bic.w	r2, r2, #1
  202bd6:	609a      	str	r2, [r3, #8]
      huart->RxState = HAL_UART_STATE_READY;
  202bd8:	2320      	movs	r3, #32
  202bda:	f880 306a 	strb.w	r3, [r0, #106]	; 0x6a
      HAL_UART_RxCpltCallback(huart);
  202bde:	f002 f931 	bl	204e44 <HAL_UART_RxCpltCallback>
    return HAL_OK;
  202be2:	2000      	movs	r0, #0
}
  202be4:	bd10      	pop	{r4, pc}
      *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->RDR & (uint8_t)uhMask);
  202be6:	6a52      	ldr	r2, [r2, #36]	; 0x24
  202be8:	1c5c      	adds	r4, r3, #1
  202bea:	4011      	ands	r1, r2
  202bec:	6544      	str	r4, [r0, #84]	; 0x54
  202bee:	7019      	strb	r1, [r3, #0]
  202bf0:	e7e2      	b.n	202bb8 <UART_Receive_IT+0x28>
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  202bf2:	6993      	ldr	r3, [r2, #24]
    return HAL_BUSY;
  202bf4:	2002      	movs	r0, #2
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  202bf6:	f043 0308 	orr.w	r3, r3, #8
  202bfa:	6193      	str	r3, [r2, #24]
    return HAL_BUSY;
  202bfc:	bd10      	pop	{r4, pc}

00202bfe <HAL_UART_RxHalfCpltCallback>:
  202bfe:	4770      	bx	lr

00202c00 <UART_DMARxHalfCplt>:
{
  202c00:	b508      	push	{r3, lr}
  HAL_UART_RxHalfCpltCallback(huart);
  202c02:	6b80      	ldr	r0, [r0, #56]	; 0x38
  202c04:	f7ff fffb 	bl	202bfe <HAL_UART_RxHalfCpltCallback>
  202c08:	bd08      	pop	{r3, pc}

00202c0a <HAL_UART_ErrorCallback>:
{
  202c0a:	4770      	bx	lr

00202c0c <UART_DMAError>:
{
  202c0c:	b508      	push	{r3, lr}
  UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
  202c0e:	6b81      	ldr	r1, [r0, #56]	; 0x38
  huart->RxXferCount = 0U;
  202c10:	2300      	movs	r3, #0
  202c12:	f8a1 305a 	strh.w	r3, [r1, #90]	; 0x5a
  huart->TxXferCount = 0U;
  202c16:	f8a1 3052 	strh.w	r3, [r1, #82]	; 0x52
  if (  (huart->gState == HAL_UART_STATE_BUSY_TX)
  202c1a:	f891 3069 	ldrb.w	r3, [r1, #105]	; 0x69
  202c1e:	2b21      	cmp	r3, #33	; 0x21
  202c20:	d10a      	bne.n	202c38 <UART_DMAError+0x2c>
      &&(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)) )
  202c22:	680b      	ldr	r3, [r1, #0]
  202c24:	689a      	ldr	r2, [r3, #8]
  202c26:	0612      	lsls	r2, r2, #24
  202c28:	d506      	bpl.n	202c38 <UART_DMAError+0x2c>
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
  202c2a:	681a      	ldr	r2, [r3, #0]
  202c2c:	f022 02c0 	bic.w	r2, r2, #192	; 0xc0
  202c30:	601a      	str	r2, [r3, #0]
  huart->gState = HAL_UART_STATE_READY;
  202c32:	2320      	movs	r3, #32
  202c34:	f881 3069 	strb.w	r3, [r1, #105]	; 0x69
  if (  (huart->RxState == HAL_UART_STATE_BUSY_RX)
  202c38:	f891 306a 	ldrb.w	r3, [r1, #106]	; 0x6a
  202c3c:	2b22      	cmp	r3, #34	; 0x22
  202c3e:	d106      	bne.n	202c4e <UART_DMAError+0x42>
      &&(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) )
  202c40:	680b      	ldr	r3, [r1, #0]
  202c42:	689b      	ldr	r3, [r3, #8]
  202c44:	065b      	lsls	r3, r3, #25
  202c46:	d502      	bpl.n	202c4e <UART_DMAError+0x42>
    UART_EndRxTransfer(huart);
  202c48:	4608      	mov	r0, r1
  202c4a:	f7ff fea7 	bl	20299c <UART_EndRxTransfer>
  SET_BIT(huart->ErrorCode, HAL_UART_ERROR_DMA);
  202c4e:	6ecb      	ldr	r3, [r1, #108]	; 0x6c
  HAL_UART_ErrorCallback(huart);
  202c50:	4608      	mov	r0, r1
  SET_BIT(huart->ErrorCode, HAL_UART_ERROR_DMA);
  202c52:	f043 0310 	orr.w	r3, r3, #16
  202c56:	66cb      	str	r3, [r1, #108]	; 0x6c
  HAL_UART_ErrorCallback(huart);
  202c58:	f7ff ffd7 	bl	202c0a <HAL_UART_ErrorCallback>
  202c5c:	bd08      	pop	{r3, pc}
	...

00202c60 <HAL_UART_IRQHandler>:
  uint32_t isrflags   = READ_REG(huart->Instance->ISR);
  202c60:	6803      	ldr	r3, [r0, #0]
  202c62:	69da      	ldr	r2, [r3, #28]
  uint32_t cr1its     = READ_REG(huart->Instance->CR1);
  202c64:	6819      	ldr	r1, [r3, #0]
{
  202c66:	b570      	push	{r4, r5, r6, lr}
  if (errorflags == RESET)
  202c68:	0716      	lsls	r6, r2, #28
{
  202c6a:	4604      	mov	r4, r0
  uint32_t cr3its     = READ_REG(huart->Instance->CR3);
  202c6c:	689d      	ldr	r5, [r3, #8]
  if (errorflags == RESET)
  202c6e:	d107      	bne.n	202c80 <HAL_UART_IRQHandler+0x20>
    if(((isrflags & USART_ISR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
  202c70:	0695      	lsls	r5, r2, #26
  202c72:	d563      	bpl.n	202d3c <HAL_UART_IRQHandler+0xdc>
  202c74:	068e      	lsls	r6, r1, #26
  202c76:	d561      	bpl.n	202d3c <HAL_UART_IRQHandler+0xdc>
}
  202c78:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      UART_Receive_IT(huart);
  202c7c:	f7ff bf88 	b.w	202b90 <UART_Receive_IT>
     && (   ((cr3its & USART_CR3_EIE) != RESET)
  202c80:	f015 0001 	ands.w	r0, r5, #1
  202c84:	d102      	bne.n	202c8c <HAL_UART_IRQHandler+0x2c>
         || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != RESET)) )
  202c86:	f411 7f90 	tst.w	r1, #288	; 0x120
  202c8a:	d057      	beq.n	202d3c <HAL_UART_IRQHandler+0xdc>
    if(((isrflags & USART_ISR_PE) != RESET) && ((cr1its & USART_CR1_PEIE) != RESET))
  202c8c:	07d5      	lsls	r5, r2, #31
  202c8e:	d507      	bpl.n	202ca0 <HAL_UART_IRQHandler+0x40>
  202c90:	05ce      	lsls	r6, r1, #23
  202c92:	d505      	bpl.n	202ca0 <HAL_UART_IRQHandler+0x40>
      __HAL_UART_CLEAR_IT(huart, UART_CLEAR_PEF);
  202c94:	2501      	movs	r5, #1
  202c96:	621d      	str	r5, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_PE;
  202c98:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
  202c9a:	f045 0501 	orr.w	r5, r5, #1
  202c9e:	66e5      	str	r5, [r4, #108]	; 0x6c
    if(((isrflags & USART_ISR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
  202ca0:	0795      	lsls	r5, r2, #30
  202ca2:	d506      	bpl.n	202cb2 <HAL_UART_IRQHandler+0x52>
  202ca4:	b128      	cbz	r0, 202cb2 <HAL_UART_IRQHandler+0x52>
      __HAL_UART_CLEAR_IT(huart, UART_CLEAR_FEF);
  202ca6:	2502      	movs	r5, #2
  202ca8:	621d      	str	r5, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_FE;
  202caa:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
  202cac:	f045 0504 	orr.w	r5, r5, #4
  202cb0:	66e5      	str	r5, [r4, #108]	; 0x6c
    if(((isrflags & USART_ISR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
  202cb2:	0756      	lsls	r6, r2, #29
  202cb4:	d506      	bpl.n	202cc4 <HAL_UART_IRQHandler+0x64>
  202cb6:	b128      	cbz	r0, 202cc4 <HAL_UART_IRQHandler+0x64>
      __HAL_UART_CLEAR_IT(huart, UART_CLEAR_NEF);
  202cb8:	2504      	movs	r5, #4
  202cba:	621d      	str	r5, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_NE;
  202cbc:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
  202cbe:	f045 0502 	orr.w	r5, r5, #2
  202cc2:	66e5      	str	r5, [r4, #108]	; 0x6c
    if(((isrflags & USART_ISR_ORE) != RESET) &&
  202cc4:	0715      	lsls	r5, r2, #28
  202cc6:	d507      	bpl.n	202cd8 <HAL_UART_IRQHandler+0x78>
  202cc8:	068e      	lsls	r6, r1, #26
  202cca:	d400      	bmi.n	202cce <HAL_UART_IRQHandler+0x6e>
       (((cr1its & USART_CR1_RXNEIE) != RESET) || ((cr3its & USART_CR3_EIE) != RESET)))
  202ccc:	b120      	cbz	r0, 202cd8 <HAL_UART_IRQHandler+0x78>
      __HAL_UART_CLEAR_IT(huart, UART_CLEAR_OREF);
  202cce:	2008      	movs	r0, #8
  202cd0:	6218      	str	r0, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_ORE;
  202cd2:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
  202cd4:	4303      	orrs	r3, r0
  202cd6:	66e3      	str	r3, [r4, #108]	; 0x6c
    if(huart->ErrorCode != HAL_UART_ERROR_NONE)
  202cd8:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
  202cda:	2b00      	cmp	r3, #0
  202cdc:	d06a      	beq.n	202db4 <HAL_UART_IRQHandler+0x154>
      if(((isrflags & USART_ISR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
  202cde:	0695      	lsls	r5, r2, #26
  202ce0:	d504      	bpl.n	202cec <HAL_UART_IRQHandler+0x8c>
  202ce2:	0688      	lsls	r0, r1, #26
  202ce4:	d502      	bpl.n	202cec <HAL_UART_IRQHandler+0x8c>
        UART_Receive_IT(huart);
  202ce6:	4620      	mov	r0, r4
  202ce8:	f7ff ff52 	bl	202b90 <UART_Receive_IT>
      if (((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) ||
  202cec:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
        UART_EndRxTransfer(huart);
  202cee:	4620      	mov	r0, r4
      if (((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) ||
  202cf0:	0719      	lsls	r1, r3, #28
  202cf2:	d404      	bmi.n	202cfe <HAL_UART_IRQHandler+0x9e>
          (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)))
  202cf4:	6823      	ldr	r3, [r4, #0]
  202cf6:	689d      	ldr	r5, [r3, #8]
      if (((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) ||
  202cf8:	f015 0540 	ands.w	r5, r5, #64	; 0x40
  202cfc:	d01a      	beq.n	202d34 <HAL_UART_IRQHandler+0xd4>
        UART_EndRxTransfer(huart);
  202cfe:	f7ff fe4d 	bl	20299c <UART_EndRxTransfer>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
  202d02:	6823      	ldr	r3, [r4, #0]
  202d04:	689a      	ldr	r2, [r3, #8]
  202d06:	0652      	lsls	r2, r2, #25
  202d08:	d510      	bpl.n	202d2c <HAL_UART_IRQHandler+0xcc>
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
  202d0a:	689a      	ldr	r2, [r3, #8]
          if(huart->hdmarx != NULL)
  202d0c:	6e60      	ldr	r0, [r4, #100]	; 0x64
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
  202d0e:	f022 0240 	bic.w	r2, r2, #64	; 0x40
  202d12:	609a      	str	r2, [r3, #8]
          if(huart->hdmarx != NULL)
  202d14:	b150      	cbz	r0, 202d2c <HAL_UART_IRQHandler+0xcc>
            huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
  202d16:	4b28      	ldr	r3, [pc, #160]	; (202db8 <HAL_UART_IRQHandler+0x158>)
  202d18:	6503      	str	r3, [r0, #80]	; 0x50
            if(HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
  202d1a:	f7fe f820 	bl	200d5e <HAL_DMA_Abort_IT>
  202d1e:	2800      	cmp	r0, #0
  202d20:	d048      	beq.n	202db4 <HAL_UART_IRQHandler+0x154>
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
  202d22:	6e60      	ldr	r0, [r4, #100]	; 0x64
}
  202d24:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
  202d28:	6d03      	ldr	r3, [r0, #80]	; 0x50
  202d2a:	4718      	bx	r3
            HAL_UART_ErrorCallback(huart);
  202d2c:	4620      	mov	r0, r4
  202d2e:	f7ff ff6c 	bl	202c0a <HAL_UART_ErrorCallback>
  202d32:	bd70      	pop	{r4, r5, r6, pc}
        HAL_UART_ErrorCallback(huart);
  202d34:	f7ff ff69 	bl	202c0a <HAL_UART_ErrorCallback>
        huart->ErrorCode = HAL_UART_ERROR_NONE;
  202d38:	66e5      	str	r5, [r4, #108]	; 0x6c
  202d3a:	bd70      	pop	{r4, r5, r6, pc}
  if(((isrflags & USART_ISR_TXE) != RESET) && ((cr1its & USART_CR1_TXEIE) != RESET))
  202d3c:	0616      	lsls	r6, r2, #24
  202d3e:	d52b      	bpl.n	202d98 <HAL_UART_IRQHandler+0x138>
  202d40:	060d      	lsls	r5, r1, #24
  202d42:	d529      	bpl.n	202d98 <HAL_UART_IRQHandler+0x138>
  if (huart->gState == HAL_UART_STATE_BUSY_TX)
  202d44:	f894 2069 	ldrb.w	r2, [r4, #105]	; 0x69
  202d48:	2a21      	cmp	r2, #33	; 0x21
  202d4a:	d133      	bne.n	202db4 <HAL_UART_IRQHandler+0x154>
    if(huart->TxXferCount == 0U)
  202d4c:	f8b4 2052 	ldrh.w	r2, [r4, #82]	; 0x52
  202d50:	b292      	uxth	r2, r2
  202d52:	b942      	cbnz	r2, 202d66 <HAL_UART_IRQHandler+0x106>
      CLEAR_BIT(huart->Instance->CR1, USART_CR1_TXEIE);
  202d54:	681a      	ldr	r2, [r3, #0]
  202d56:	f022 0280 	bic.w	r2, r2, #128	; 0x80
  202d5a:	601a      	str	r2, [r3, #0]
      SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
  202d5c:	681a      	ldr	r2, [r3, #0]
  202d5e:	f042 0240 	orr.w	r2, r2, #64	; 0x40
  202d62:	601a      	str	r2, [r3, #0]
  202d64:	bd70      	pop	{r4, r5, r6, pc}
      if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
  202d66:	68a2      	ldr	r2, [r4, #8]
  202d68:	f5b2 5f80 	cmp.w	r2, #4096	; 0x1000
  202d6c:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
  202d6e:	d10e      	bne.n	202d8e <HAL_UART_IRQHandler+0x12e>
  202d70:	6921      	ldr	r1, [r4, #16]
  202d72:	b961      	cbnz	r1, 202d8e <HAL_UART_IRQHandler+0x12e>
        huart->Instance->TDR = (*tmp & (uint16_t)0x01FFU);
  202d74:	f832 1b02 	ldrh.w	r1, [r2], #2
  202d78:	f3c1 0108 	ubfx	r1, r1, #0, #9
  202d7c:	6299      	str	r1, [r3, #40]	; 0x28
        huart->pTxBuffPtr += 2U;
  202d7e:	64e2      	str	r2, [r4, #76]	; 0x4c
      huart->TxXferCount--;
  202d80:	f8b4 3052 	ldrh.w	r3, [r4, #82]	; 0x52
  202d84:	3b01      	subs	r3, #1
  202d86:	b29b      	uxth	r3, r3
  202d88:	f8a4 3052 	strh.w	r3, [r4, #82]	; 0x52
  202d8c:	bd70      	pop	{r4, r5, r6, pc}
        huart->Instance->TDR = (uint8_t)(*huart->pTxBuffPtr++ & (uint8_t)0xFFU);
  202d8e:	1c51      	adds	r1, r2, #1
  202d90:	64e1      	str	r1, [r4, #76]	; 0x4c
  202d92:	7812      	ldrb	r2, [r2, #0]
  202d94:	629a      	str	r2, [r3, #40]	; 0x28
  202d96:	e7f3      	b.n	202d80 <HAL_UART_IRQHandler+0x120>
  if(((isrflags & USART_ISR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
  202d98:	0650      	lsls	r0, r2, #25
  202d9a:	d50b      	bpl.n	202db4 <HAL_UART_IRQHandler+0x154>
  202d9c:	064a      	lsls	r2, r1, #25
  202d9e:	d509      	bpl.n	202db4 <HAL_UART_IRQHandler+0x154>
  CLEAR_BIT(huart->Instance->CR1, USART_CR1_TCIE);
  202da0:	681a      	ldr	r2, [r3, #0]
  HAL_UART_TxCpltCallback(huart);
  202da2:	4620      	mov	r0, r4
  CLEAR_BIT(huart->Instance->CR1, USART_CR1_TCIE);
  202da4:	f022 0240 	bic.w	r2, r2, #64	; 0x40
  202da8:	601a      	str	r2, [r3, #0]
  huart->gState = HAL_UART_STATE_READY;
  202daa:	2320      	movs	r3, #32
  202dac:	f884 3069 	strb.w	r3, [r4, #105]	; 0x69
  HAL_UART_TxCpltCallback(huart);
  202db0:	f7ff fed0 	bl	202b54 <HAL_UART_TxCpltCallback>
  202db4:	bd70      	pop	{r4, r5, r6, pc}
  202db6:	bf00      	nop
  202db8:	00202dbd 	.word	0x00202dbd

00202dbc <UART_DMAAbortOnError>:
{
  202dbc:	b508      	push	{r3, lr}
  UART_HandleTypeDef* huart = (UART_HandleTypeDef*)(hdma->Parent);
  202dbe:	6b80      	ldr	r0, [r0, #56]	; 0x38
  huart->RxXferCount = 0U;
  202dc0:	2300      	movs	r3, #0
  202dc2:	f8a0 305a 	strh.w	r3, [r0, #90]	; 0x5a
  huart->TxXferCount = 0U;
  202dc6:	f8a0 3052 	strh.w	r3, [r0, #82]	; 0x52
  HAL_UART_ErrorCallback(huart);
  202dca:	f7ff ff1e 	bl	202c0a <HAL_UART_ErrorCallback>
  202dce:	bd08      	pop	{r3, pc}

00202dd0 <UART_SetConfig>:
  * @brief Configure the UART peripheral
  * @param huart: uart handle
  * @retval None
  */
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
  202dd0:	b538      	push	{r3, r4, r5, lr}
  202dd2:	4604      	mov	r4, r0
   *  set the M bits according to huart->Init.WordLength value
   *  set PCE and PS bits according to huart->Init.Parity value
   *  set TE and RE bits according to huart->Init.Mode value
   *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
  MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
  202dd4:	6805      	ldr	r5, [r0, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
  202dd6:	69c3      	ldr	r3, [r0, #28]
  202dd8:	6921      	ldr	r1, [r4, #16]
  202dda:	68a2      	ldr	r2, [r4, #8]
  MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
  202ddc:	6828      	ldr	r0, [r5, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
  202dde:	430a      	orrs	r2, r1
  202de0:	6961      	ldr	r1, [r4, #20]
  202de2:	430a      	orrs	r2, r1
  MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
  202de4:	4993      	ldr	r1, [pc, #588]	; (203034 <UART_SetConfig+0x264>)
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
  202de6:	431a      	orrs	r2, r3
  MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
  202de8:	4001      	ands	r1, r0
  /* Configure
   * - UART HardWare Flow Control: set CTSE and RTSE bits according
   *   to huart->Init.HwFlowCtl value
   * - one-bit sampling method versus three samples' majority rule according
   *   to huart->Init.OneBitSampling */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl | huart->Init.OneBitSampling ;
  202dea:	6a20      	ldr	r0, [r4, #32]
  MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
  202dec:	430a      	orrs	r2, r1
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
  202dee:	68e1      	ldr	r1, [r4, #12]
  MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
  202df0:	602a      	str	r2, [r5, #0]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
  202df2:	686a      	ldr	r2, [r5, #4]
  202df4:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
  202df8:	430a      	orrs	r2, r1
  202dfa:	606a      	str	r2, [r5, #4]
  tmpreg = (uint32_t)huart->Init.HwFlowCtl | huart->Init.OneBitSampling ;
  202dfc:	69a2      	ldr	r2, [r4, #24]
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE | USART_CR3_ONEBIT), tmpreg);
  202dfe:	68a9      	ldr	r1, [r5, #8]
  tmpreg = (uint32_t)huart->Init.HwFlowCtl | huart->Init.OneBitSampling ;
  202e00:	4302      	orrs	r2, r0
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE | USART_CR3_ONEBIT), tmpreg);
  202e02:	f421 6130 	bic.w	r1, r1, #2816	; 0xb00
  202e06:	430a      	orrs	r2, r1
  202e08:	60aa      	str	r2, [r5, #8]

  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
  202e0a:	4a8b      	ldr	r2, [pc, #556]	; (203038 <UART_SetConfig+0x268>)
  202e0c:	4295      	cmp	r5, r2
  202e0e:	d119      	bne.n	202e44 <UART_SetConfig+0x74>
  202e10:	f502 3294 	add.w	r2, r2, #75776	; 0x12800
  202e14:	4989      	ldr	r1, [pc, #548]	; (20303c <UART_SetConfig+0x26c>)
  202e16:	f8d2 2090 	ldr.w	r2, [r2, #144]	; 0x90
  202e1a:	f002 0203 	and.w	r2, r2, #3

  /* Check UART Over Sampling to set Baud Rate Register */
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
  202e1e:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
  202e22:	5c8a      	ldrb	r2, [r1, r2]
  202e24:	f040 80b3 	bne.w	202f8e <UART_SetConfig+0x1be>
  {
    switch (clocksource)
  202e28:	2a08      	cmp	r2, #8
  202e2a:	f200 80ad 	bhi.w	202f88 <UART_SetConfig+0x1b8>
  202e2e:	e8df f012 	tbh	[pc, r2, lsl #1]
  202e32:	0026      	.short	0x0026
  202e34:	00e9007b 	.word	0x00e9007b
  202e38:	00f500ab 	.word	0x00f500ab
  202e3c:	00ab00ab 	.word	0x00ab00ab
  202e40:	00fb00ab 	.word	0x00fb00ab
  UART_GETCLOCKSOURCE(huart, clocksource);
  202e44:	4a7e      	ldr	r2, [pc, #504]	; (203040 <UART_SetConfig+0x270>)
  202e46:	4295      	cmp	r5, r2
  202e48:	d107      	bne.n	202e5a <UART_SetConfig+0x8a>
  202e4a:	f502 32fa 	add.w	r2, r2, #128000	; 0x1f400
  202e4e:	497d      	ldr	r1, [pc, #500]	; (203044 <UART_SetConfig+0x274>)
  202e50:	f8d2 2090 	ldr.w	r2, [r2, #144]	; 0x90
  202e54:	f002 020c 	and.w	r2, r2, #12
  202e58:	e7e1      	b.n	202e1e <UART_SetConfig+0x4e>
  202e5a:	4a7b      	ldr	r2, [pc, #492]	; (203048 <UART_SetConfig+0x278>)
  202e5c:	4295      	cmp	r5, r2
  202e5e:	d12b      	bne.n	202eb8 <UART_SetConfig+0xe8>
  202e60:	f502 32f8 	add.w	r2, r2, #126976	; 0x1f000
  202e64:	f8d2 2090 	ldr.w	r2, [r2, #144]	; 0x90
  202e68:	f002 0230 	and.w	r2, r2, #48	; 0x30
  202e6c:	2a10      	cmp	r2, #16
  202e6e:	f000 80d2 	beq.w	203016 <UART_SetConfig+0x246>
  202e72:	d816      	bhi.n	202ea2 <UART_SetConfig+0xd2>
  202e74:	b9da      	cbnz	r2, 202eae <UART_SetConfig+0xde>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
  202e76:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
  202e7a:	f040 809f 	bne.w	202fbc <UART_SetConfig+0x1ec>
    {
    case UART_CLOCKSOURCE_PCLK1:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
  202e7e:	f7fe fef5 	bl	201c6c <HAL_RCC_GetPCLK1Freq>
      break;
    case UART_CLOCKSOURCE_PCLK2:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
  202e82:	6861      	ldr	r1, [r4, #4]
  202e84:	084a      	lsrs	r2, r1, #1
  202e86:	eb02 0340 	add.w	r3, r2, r0, lsl #1
  202e8a:	fbb3 f3f1 	udiv	r3, r3, r1
  202e8e:	b29b      	uxth	r3, r3
  HAL_StatusTypeDef ret               = HAL_OK;
  202e90:	2000      	movs	r0, #0
    default:
        ret = HAL_ERROR;
      break;
    }

    brrtemp = usartdiv & 0xFFF0U;
  202e92:	f023 020f 	bic.w	r2, r3, #15
    brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
  202e96:	f3c3 0342 	ubfx	r3, r3, #1, #3
    huart->Instance->BRR = brrtemp;
  202e9a:	6821      	ldr	r1, [r4, #0]
  202e9c:	4313      	orrs	r3, r2
  202e9e:	60cb      	str	r3, [r1, #12]
  202ea0:	bd38      	pop	{r3, r4, r5, pc}
  UART_GETCLOCKSOURCE(huart, clocksource);
  202ea2:	2a20      	cmp	r2, #32
  202ea4:	f000 80ab 	beq.w	202ffe <UART_SetConfig+0x22e>
  202ea8:	2a30      	cmp	r2, #48	; 0x30
  202eaa:	f000 80ba 	beq.w	203022 <UART_SetConfig+0x252>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
  202eae:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
  202eb2:	d069      	beq.n	202f88 <UART_SetConfig+0x1b8>
    case UART_CLOCKSOURCE_LSE:
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate));
      break;
      case UART_CLOCKSOURCE_UNDEFINED:
    default:
        ret = HAL_ERROR;
  202eb4:	2001      	movs	r0, #1
    }
  }

  return ret;

}
  202eb6:	bd38      	pop	{r3, r4, r5, pc}
  UART_GETCLOCKSOURCE(huart, clocksource);
  202eb8:	4a64      	ldr	r2, [pc, #400]	; (20304c <UART_SetConfig+0x27c>)
  202eba:	4295      	cmp	r5, r2
  202ebc:	d10e      	bne.n	202edc <UART_SetConfig+0x10c>
  202ebe:	f502 32f6 	add.w	r2, r2, #125952	; 0x1ec00
  202ec2:	f8d2 2090 	ldr.w	r2, [r2, #144]	; 0x90
  202ec6:	f002 02c0 	and.w	r2, r2, #192	; 0xc0
  202eca:	2a40      	cmp	r2, #64	; 0x40
  202ecc:	f000 80a3 	beq.w	203016 <UART_SetConfig+0x246>
  202ed0:	d9d0      	bls.n	202e74 <UART_SetConfig+0xa4>
  202ed2:	2a80      	cmp	r2, #128	; 0x80
  202ed4:	f000 8093 	beq.w	202ffe <UART_SetConfig+0x22e>
  202ed8:	2ac0      	cmp	r2, #192	; 0xc0
  202eda:	e7e6      	b.n	202eaa <UART_SetConfig+0xda>
  202edc:	4a5c      	ldr	r2, [pc, #368]	; (203050 <UART_SetConfig+0x280>)
  202ede:	4295      	cmp	r5, r2
  202ee0:	d110      	bne.n	202f04 <UART_SetConfig+0x134>
  202ee2:	f502 32f4 	add.w	r2, r2, #124928	; 0x1e800
  202ee6:	f8d2 2090 	ldr.w	r2, [r2, #144]	; 0x90
  202eea:	f402 7240 	and.w	r2, r2, #768	; 0x300
  202eee:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
  202ef2:	f000 8090 	beq.w	203016 <UART_SetConfig+0x246>
  202ef6:	d9bd      	bls.n	202e74 <UART_SetConfig+0xa4>
  202ef8:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
  202efc:	d07f      	beq.n	202ffe <UART_SetConfig+0x22e>
  202efe:	f5b2 7f40 	cmp.w	r2, #768	; 0x300
  202f02:	e7d2      	b.n	202eaa <UART_SetConfig+0xda>
  202f04:	4a53      	ldr	r2, [pc, #332]	; (203054 <UART_SetConfig+0x284>)
  202f06:	4295      	cmp	r5, r2
  202f08:	d117      	bne.n	202f3a <UART_SetConfig+0x16a>
  202f0a:	f502 3292 	add.w	r2, r2, #74752	; 0x12400
  202f0e:	f8d2 2090 	ldr.w	r2, [r2, #144]	; 0x90
  202f12:	f402 6240 	and.w	r2, r2, #3072	; 0xc00
  202f16:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
  202f1a:	d07c      	beq.n	203016 <UART_SetConfig+0x246>
  202f1c:	d807      	bhi.n	202f2e <UART_SetConfig+0x15e>
  202f1e:	2a00      	cmp	r2, #0
  202f20:	d1c5      	bne.n	202eae <UART_SetConfig+0xde>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
  202f22:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
  202f26:	d154      	bne.n	202fd2 <UART_SetConfig+0x202>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
  202f28:	f7fe feb0 	bl	201c8c <HAL_RCC_GetPCLK2Freq>
  202f2c:	e7a9      	b.n	202e82 <UART_SetConfig+0xb2>
  UART_GETCLOCKSOURCE(huart, clocksource);
  202f2e:	f5b2 6f00 	cmp.w	r2, #2048	; 0x800
  202f32:	d064      	beq.n	202ffe <UART_SetConfig+0x22e>
  202f34:	f5b2 6f40 	cmp.w	r2, #3072	; 0xc00
  202f38:	e7b7      	b.n	202eaa <UART_SetConfig+0xda>
  202f3a:	4a47      	ldr	r2, [pc, #284]	; (203058 <UART_SetConfig+0x288>)
  202f3c:	4295      	cmp	r5, r2
  202f3e:	d10f      	bne.n	202f60 <UART_SetConfig+0x190>
  202f40:	f502 32e0 	add.w	r2, r2, #114688	; 0x1c000
  202f44:	f8d2 2090 	ldr.w	r2, [r2, #144]	; 0x90
  202f48:	f402 5240 	and.w	r2, r2, #12288	; 0x3000
  202f4c:	f5b2 5f80 	cmp.w	r2, #4096	; 0x1000
  202f50:	d061      	beq.n	203016 <UART_SetConfig+0x246>
  202f52:	d98f      	bls.n	202e74 <UART_SetConfig+0xa4>
  202f54:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
  202f58:	d051      	beq.n	202ffe <UART_SetConfig+0x22e>
  202f5a:	f5b2 5f40 	cmp.w	r2, #12288	; 0x3000
  202f5e:	e7a4      	b.n	202eaa <UART_SetConfig+0xda>
  202f60:	4a3e      	ldr	r2, [pc, #248]	; (20305c <UART_SetConfig+0x28c>)
  202f62:	4295      	cmp	r5, r2
  202f64:	d1a3      	bne.n	202eae <UART_SetConfig+0xde>
  202f66:	f502 32de 	add.w	r2, r2, #113664	; 0x1bc00
  202f6a:	f8d2 2090 	ldr.w	r2, [r2, #144]	; 0x90
  202f6e:	f402 4240 	and.w	r2, r2, #49152	; 0xc000
  202f72:	f5b2 4f80 	cmp.w	r2, #16384	; 0x4000
  202f76:	d04e      	beq.n	203016 <UART_SetConfig+0x246>
  202f78:	f67f af7c 	bls.w	202e74 <UART_SetConfig+0xa4>
  202f7c:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
  202f80:	d03d      	beq.n	202ffe <UART_SetConfig+0x22e>
  202f82:	f5b2 4f40 	cmp.w	r2, #49152	; 0xc000
  202f86:	e790      	b.n	202eaa <UART_SetConfig+0xda>
        ret = HAL_ERROR;
  202f88:	2001      	movs	r0, #1
  uint16_t usartdiv                   = 0x0000U;
  202f8a:	2300      	movs	r3, #0
  202f8c:	e781      	b.n	202e92 <UART_SetConfig+0xc2>
    switch (clocksource)
  202f8e:	2a08      	cmp	r2, #8
  202f90:	d890      	bhi.n	202eb4 <UART_SetConfig+0xe4>
  202f92:	a301      	add	r3, pc, #4	; (adr r3, 202f98 <UART_SetConfig+0x1c8>)
  202f94:	f853 f022 	ldr.w	pc, [r3, r2, lsl #2]
  202f98:	00202fbd 	.word	0x00202fbd
  202f9c:	00202fd3 	.word	0x00202fd3
  202fa0:	00202fd9 	.word	0x00202fd9
  202fa4:	00202eb5 	.word	0x00202eb5
  202fa8:	00202fef 	.word	0x00202fef
  202fac:	00202eb5 	.word	0x00202eb5
  202fb0:	00202eb5 	.word	0x00202eb5
  202fb4:	00202eb5 	.word	0x00202eb5
  202fb8:	00202ff5 	.word	0x00202ff5
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
  202fbc:	f7fe fe56 	bl	201c6c <HAL_RCC_GetPCLK1Freq>
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
  202fc0:	6863      	ldr	r3, [r4, #4]
  202fc2:	eb00 0053 	add.w	r0, r0, r3, lsr #1
  202fc6:	fbb0 f0f3 	udiv	r0, r0, r3
  202fca:	b280      	uxth	r0, r0
  202fcc:	60e8      	str	r0, [r5, #12]
  HAL_StatusTypeDef ret               = HAL_OK;
  202fce:	2000      	movs	r0, #0
      break;
  202fd0:	bd38      	pop	{r3, r4, r5, pc}
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
  202fd2:	f7fe fe5b 	bl	201c8c <HAL_RCC_GetPCLK2Freq>
  202fd6:	e7f3      	b.n	202fc0 <UART_SetConfig+0x1f0>
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HSI_VALUE, huart->Init.BaudRate));
  202fd8:	6862      	ldr	r2, [r4, #4]
  202fda:	0853      	lsrs	r3, r2, #1
  202fdc:	f503 0374 	add.w	r3, r3, #15990784	; 0xf40000
  202fe0:	f503 5310 	add.w	r3, r3, #9216	; 0x2400
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate));
  202fe4:	fbb3 f3f2 	udiv	r3, r3, r2
  202fe8:	b29b      	uxth	r3, r3
  202fea:	60eb      	str	r3, [r5, #12]
  202fec:	e7ef      	b.n	202fce <UART_SetConfig+0x1fe>
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
  202fee:	f7fe fd7d 	bl	201aec <HAL_RCC_GetSysClockFreq>
  202ff2:	e7e5      	b.n	202fc0 <UART_SetConfig+0x1f0>
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate));
  202ff4:	6862      	ldr	r2, [r4, #4]
  202ff6:	0853      	lsrs	r3, r2, #1
  202ff8:	f503 4300 	add.w	r3, r3, #32768	; 0x8000
  202ffc:	e7f2      	b.n	202fe4 <UART_SetConfig+0x214>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
  202ffe:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
  203002:	d1e9      	bne.n	202fd8 <UART_SetConfig+0x208>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSI_VALUE, huart->Init.BaudRate));
  203004:	6860      	ldr	r0, [r4, #4]
  203006:	0843      	lsrs	r3, r0, #1
  203008:	f103 73f4 	add.w	r3, r3, #31981568	; 0x1e80000
  20300c:	f503 4390 	add.w	r3, r3, #18432	; 0x4800
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate));
  203010:	fbb3 f3f0 	udiv	r3, r3, r0
  203014:	e73b      	b.n	202e8e <UART_SetConfig+0xbe>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
  203016:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
  20301a:	d1e8      	bne.n	202fee <UART_SetConfig+0x21e>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
  20301c:	f7fe fd66 	bl	201aec <HAL_RCC_GetSysClockFreq>
  203020:	e72f      	b.n	202e82 <UART_SetConfig+0xb2>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
  203022:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
  203026:	d1e5      	bne.n	202ff4 <UART_SetConfig+0x224>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate));
  203028:	6860      	ldr	r0, [r4, #4]
  20302a:	0843      	lsrs	r3, r0, #1
  20302c:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
  203030:	e7ee      	b.n	203010 <UART_SetConfig+0x240>
  203032:	bf00      	nop
  203034:	efff69f3 	.word	0xefff69f3
  203038:	40011000 	.word	0x40011000
  20303c:	002074b4 	.word	0x002074b4
  203040:	40004400 	.word	0x40004400
  203044:	002074b8 	.word	0x002074b8
  203048:	40004800 	.word	0x40004800
  20304c:	40004c00 	.word	0x40004c00
  203050:	40005000 	.word	0x40005000
  203054:	40011400 	.word	0x40011400
  203058:	40007800 	.word	0x40007800
  20305c:	40007c00 	.word	0x40007c00

00203060 <UART_AdvFeatureConfig>:
{
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure TX pin active level inversion */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
  203060:	6a43      	ldr	r3, [r0, #36]	; 0x24
  203062:	07da      	lsls	r2, r3, #31
{
  203064:	b510      	push	{r4, lr}
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
  203066:	d506      	bpl.n	203076 <UART_AdvFeatureConfig+0x16>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
  203068:	6801      	ldr	r1, [r0, #0]
  20306a:	6a84      	ldr	r4, [r0, #40]	; 0x28
  20306c:	684a      	ldr	r2, [r1, #4]
  20306e:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
  203072:	4322      	orrs	r2, r4
  203074:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX pin active level inversion */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
  203076:	079c      	lsls	r4, r3, #30
  203078:	d506      	bpl.n	203088 <UART_AdvFeatureConfig+0x28>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
  20307a:	6801      	ldr	r1, [r0, #0]
  20307c:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
  20307e:	684a      	ldr	r2, [r1, #4]
  203080:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
  203084:	4322      	orrs	r2, r4
  203086:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure data inversion */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
  203088:	0759      	lsls	r1, r3, #29
  20308a:	d506      	bpl.n	20309a <UART_AdvFeatureConfig+0x3a>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
  20308c:	6801      	ldr	r1, [r0, #0]
  20308e:	6b04      	ldr	r4, [r0, #48]	; 0x30
  203090:	684a      	ldr	r2, [r1, #4]
  203092:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
  203096:	4322      	orrs	r2, r4
  203098:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX/TX pins swap */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
  20309a:	071a      	lsls	r2, r3, #28
  20309c:	d506      	bpl.n	2030ac <UART_AdvFeatureConfig+0x4c>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
  20309e:	6801      	ldr	r1, [r0, #0]
  2030a0:	6b44      	ldr	r4, [r0, #52]	; 0x34
  2030a2:	684a      	ldr	r2, [r1, #4]
  2030a4:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
  2030a8:	4322      	orrs	r2, r4
  2030aa:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
  2030ac:	06dc      	lsls	r4, r3, #27
  2030ae:	d506      	bpl.n	2030be <UART_AdvFeatureConfig+0x5e>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
  2030b0:	6801      	ldr	r1, [r0, #0]
  2030b2:	6b84      	ldr	r4, [r0, #56]	; 0x38
  2030b4:	688a      	ldr	r2, [r1, #8]
  2030b6:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
  2030ba:	4322      	orrs	r2, r4
  2030bc:	608a      	str	r2, [r1, #8]
  }

  /* if required, configure DMA disabling on reception error */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
  2030be:	0699      	lsls	r1, r3, #26
  2030c0:	d506      	bpl.n	2030d0 <UART_AdvFeatureConfig+0x70>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
  2030c2:	6801      	ldr	r1, [r0, #0]
  2030c4:	6bc4      	ldr	r4, [r0, #60]	; 0x3c
  2030c6:	688a      	ldr	r2, [r1, #8]
  2030c8:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
  2030cc:	4322      	orrs	r2, r4
  2030ce:	608a      	str	r2, [r1, #8]
  }

  /* if required, configure auto Baud rate detection scheme */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
  2030d0:	065a      	lsls	r2, r3, #25
  2030d2:	d510      	bpl.n	2030f6 <UART_AdvFeatureConfig+0x96>
  {
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
  2030d4:	6801      	ldr	r1, [r0, #0]
  2030d6:	6c04      	ldr	r4, [r0, #64]	; 0x40
  2030d8:	684a      	ldr	r2, [r1, #4]
    /* set auto Baudrate detection parameters if detection is enabled */
    if(huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
  2030da:	f5b4 1f80 	cmp.w	r4, #1048576	; 0x100000
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
  2030de:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
  2030e2:	ea42 0204 	orr.w	r2, r2, r4
  2030e6:	604a      	str	r2, [r1, #4]
    if(huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
  2030e8:	d105      	bne.n	2030f6 <UART_AdvFeatureConfig+0x96>
    {
      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
  2030ea:	684a      	ldr	r2, [r1, #4]
  2030ec:	6c44      	ldr	r4, [r0, #68]	; 0x44
  2030ee:	f422 02c0 	bic.w	r2, r2, #6291456	; 0x600000
  2030f2:	4322      	orrs	r2, r4
  2030f4:	604a      	str	r2, [r1, #4]
    }
  }

  /* if required, configure MSB first on communication line */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
  2030f6:	061b      	lsls	r3, r3, #24
  2030f8:	d506      	bpl.n	203108 <UART_AdvFeatureConfig+0xa8>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
  2030fa:	6802      	ldr	r2, [r0, #0]
  2030fc:	6c81      	ldr	r1, [r0, #72]	; 0x48
  2030fe:	6853      	ldr	r3, [r2, #4]
  203100:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
  203104:	430b      	orrs	r3, r1
  203106:	6053      	str	r3, [r2, #4]
  203108:	bd10      	pop	{r4, pc}

0020310a <UART_CheckIdleState>:
  * @brief Check the UART Idle State
  * @param huart: uart handle
  * @retval HAL status
  */
HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
{
  20310a:	b537      	push	{r0, r1, r2, r4, r5, lr}
  uint32_t tickstart = 0U;

  /* Initialize the UART ErrorCode */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
  20310c:	2500      	movs	r5, #0
{
  20310e:	4604      	mov	r4, r0
  huart->ErrorCode = HAL_UART_ERROR_NONE;
  203110:	66c5      	str	r5, [r0, #108]	; 0x6c

  /* Init tickstart for timeout managment*/
  tickstart = HAL_GetTick();
  203112:	f7fd fcc1 	bl	200a98 <HAL_GetTick>

  /* Check if the Transmitter is enabled */
  if((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
  203116:	6822      	ldr	r2, [r4, #0]
  tickstart = HAL_GetTick();
  203118:	4603      	mov	r3, r0
  if((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
  20311a:	6812      	ldr	r2, [r2, #0]
  20311c:	0712      	lsls	r2, r2, #28
  20311e:	d409      	bmi.n	203134 <UART_CheckIdleState+0x2a>
      return HAL_TIMEOUT;
    }
  }

  /* Initialize the UART State */
  huart->gState= HAL_UART_STATE_READY;
  203120:	2320      	movs	r3, #32
  huart->RxState= HAL_UART_STATE_READY;

  /* Process Unlocked */
  __HAL_UNLOCK(huart);
  203122:	2000      	movs	r0, #0
  huart->gState= HAL_UART_STATE_READY;
  203124:	f884 3069 	strb.w	r3, [r4, #105]	; 0x69
  __HAL_UNLOCK(huart);
  203128:	f884 0068 	strb.w	r0, [r4, #104]	; 0x68
  huart->RxState= HAL_UART_STATE_READY;
  20312c:	f884 306a 	strb.w	r3, [r4, #106]	; 0x6a

  return HAL_OK;
}
  203130:	b003      	add	sp, #12
  203132:	bd30      	pop	{r4, r5, pc}
    if(UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
  203134:	f06f 427e 	mvn.w	r2, #4261412864	; 0xfe000000
  203138:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
  20313c:	4620      	mov	r0, r4
  20313e:	9200      	str	r2, [sp, #0]
  203140:	462a      	mov	r2, r5
  203142:	f7ff fc7d 	bl	202a40 <UART_WaitOnFlagUntilTimeout>
  203146:	2800      	cmp	r0, #0
  203148:	d0ea      	beq.n	203120 <UART_CheckIdleState+0x16>
      return HAL_TIMEOUT;
  20314a:	2003      	movs	r0, #3
  20314c:	e7f0      	b.n	203130 <UART_CheckIdleState+0x26>

0020314e <HAL_UART_Init>:
{
  20314e:	b510      	push	{r4, lr}
  if(huart == NULL)
  203150:	4604      	mov	r4, r0
  203152:	b360      	cbz	r0, 2031ae <HAL_UART_Init+0x60>
  if(huart->gState == HAL_UART_STATE_RESET)
  203154:	f890 3069 	ldrb.w	r3, [r0, #105]	; 0x69
  203158:	f003 02ff 	and.w	r2, r3, #255	; 0xff
  20315c:	b91b      	cbnz	r3, 203166 <HAL_UART_Init+0x18>
    huart->Lock = HAL_UNLOCKED;
  20315e:	f880 2068 	strb.w	r2, [r0, #104]	; 0x68
    HAL_UART_MspInit(huart);
  203162:	f003 ff69 	bl	207038 <HAL_UART_MspInit>
  __HAL_UART_DISABLE(huart);
  203166:	6822      	ldr	r2, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
  203168:	2324      	movs	r3, #36	; 0x24
  if (UART_SetConfig(huart) == HAL_ERROR)
  20316a:	4620      	mov	r0, r4
  huart->gState = HAL_UART_STATE_BUSY;
  20316c:	f884 3069 	strb.w	r3, [r4, #105]	; 0x69
  __HAL_UART_DISABLE(huart);
  203170:	6813      	ldr	r3, [r2, #0]
  203172:	f023 0301 	bic.w	r3, r3, #1
  203176:	6013      	str	r3, [r2, #0]
  if (UART_SetConfig(huart) == HAL_ERROR)
  203178:	f7ff fe2a 	bl	202dd0 <UART_SetConfig>
  20317c:	2801      	cmp	r0, #1
  20317e:	d016      	beq.n	2031ae <HAL_UART_Init+0x60>
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
  203180:	6a63      	ldr	r3, [r4, #36]	; 0x24
  203182:	b113      	cbz	r3, 20318a <HAL_UART_Init+0x3c>
    UART_AdvFeatureConfig(huart);
  203184:	4620      	mov	r0, r4
  203186:	f7ff ff6b 	bl	203060 <UART_AdvFeatureConfig>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
  20318a:	6823      	ldr	r3, [r4, #0]
  return (UART_CheckIdleState(huart));
  20318c:	4620      	mov	r0, r4
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
  20318e:	685a      	ldr	r2, [r3, #4]
  203190:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
  203194:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
  203196:	689a      	ldr	r2, [r3, #8]
  203198:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
  20319c:	609a      	str	r2, [r3, #8]
  __HAL_UART_ENABLE(huart);
  20319e:	681a      	ldr	r2, [r3, #0]
  2031a0:	f042 0201 	orr.w	r2, r2, #1
}
  2031a4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  __HAL_UART_ENABLE(huart);
  2031a8:	601a      	str	r2, [r3, #0]
  return (UART_CheckIdleState(huart));
  2031aa:	f7ff bfae 	b.w	20310a <UART_CheckIdleState>
}
  2031ae:	2001      	movs	r0, #1
  2031b0:	bd10      	pop	{r4, pc}
	...

002031b4 <JY901_init>:
 */
#include "JY901.h"


void JY901_init(I2C_HandleTypeDef *handler){
	 JY901_I2C = handler;
  2031b4:	4b01      	ldr	r3, [pc, #4]	; (2031bc <JY901_init+0x8>)
  2031b6:	6018      	str	r0, [r3, #0]
  2031b8:	4770      	bx	lr
  2031ba:	bf00      	nop
  2031bc:	20000050 	.word	0x20000050

002031c0 <JY901_calibration>:
 * cmd=4  Save
 */
void JY901_calibration(uint32_t time,uint8_t cmd){
	uint8_t send_cmd[3];
	uint8_t cycletime=0;
	if(time>1000){
  2031c0:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
void JY901_calibration(uint32_t time,uint8_t cmd){
  2031c4:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
		cycletime=time/1000;
  2031c6:	bf88      	it	hi
  2031c8:	f44f 747a 	movhi.w	r4, #1000	; 0x3e8
	}
	switch(cmd){
  2031cc:	f101 31ff 	add.w	r1, r1, #4294967295
void JY901_calibration(uint32_t time,uint8_t cmd){
  2031d0:	4605      	mov	r5, r0
  2031d2:	bf94      	ite	ls
  2031d4:	2400      	movls	r4, #0
		cycletime=time/1000;
  2031d6:	fbb0 f4f4 	udivhi	r4, r0, r4
	switch(cmd){
  2031da:	2903      	cmp	r1, #3
  2031dc:	d82f      	bhi.n	20323e <JY901_calibration+0x7e>
  2031de:	e8df f001 	tbb	[pc, r1]
  2031e2:	1702      	.short	0x1702
  2031e4:	4039      	.short	0x4039
	case 1:
		send_cmd[0]=0x01;
  2031e6:	2301      	movs	r3, #1
  2031e8:	f88d 300c 	strb.w	r3, [sp, #12]
		send_cmd[1]=0x01;
  2031ec:	f88d 300d 	strb.w	r3, [sp, #13]
		send_cmd[2]=0x00;
  2031f0:	2300      	movs	r3, #0
	break;

	case 4:
		send_cmd[0]=0x00;
		send_cmd[1]=0x00;
		send_cmd[2]=0x00;
  2031f2:	f88d 300e 	strb.w	r3, [sp, #14]
		HAL_I2C_Master_Transmit(JY901_I2C,JY901_I2C_ADDRESS,(uint8_t*)send_cmd,3,0xF);
  2031f6:	230f      	movs	r3, #15
  2031f8:	481c      	ldr	r0, [pc, #112]	; (20326c <JY901_calibration+0xac>)
  2031fa:	aa03      	add	r2, sp, #12
  2031fc:	9300      	str	r3, [sp, #0]
  2031fe:	21a0      	movs	r1, #160	; 0xa0
  203200:	2303      	movs	r3, #3
  203202:	6800      	ldr	r0, [r0, #0]
  203204:	f7fe f8d0 	bl	2013a8 <HAL_I2C_Master_Transmit>
		HAL_Delay(time);
  203208:	4628      	mov	r0, r5
  20320a:	f7fd fc4b 	bl	200aa4 <HAL_Delay>
	break;
	}
}
  20320e:	e016      	b.n	20323e <JY901_calibration+0x7e>
		send_cmd[0]=0x01;
  203210:	2301      	movs	r3, #1
		HAL_I2C_Master_Transmit(JY901_I2C,JY901_I2C_ADDRESS,(uint8_t*)send_cmd,3,0xF);
  203212:	4816      	ldr	r0, [pc, #88]	; (20326c <JY901_calibration+0xac>)
		send_cmd[2]=0x00;
  203214:	2500      	movs	r5, #0
		for(uint8_t i=0;i<cycletime;i++){
  203216:	b2e4      	uxtb	r4, r4
		send_cmd[0]=0x01;
  203218:	f88d 300c 	strb.w	r3, [sp, #12]
		send_cmd[1]=0x02;
  20321c:	2302      	movs	r3, #2
			HAL_IWDG_Refresh(&hiwdg);
  20321e:	4e14      	ldr	r6, [pc, #80]	; (203270 <JY901_calibration+0xb0>)
		HAL_I2C_Master_Transmit(JY901_I2C,JY901_I2C_ADDRESS,(uint8_t*)send_cmd,3,0xF);
  203220:	aa03      	add	r2, sp, #12
		send_cmd[1]=0x02;
  203222:	f88d 300d 	strb.w	r3, [sp, #13]
		HAL_I2C_Master_Transmit(JY901_I2C,JY901_I2C_ADDRESS,(uint8_t*)send_cmd,3,0xF);
  203226:	230f      	movs	r3, #15
  203228:	21a0      	movs	r1, #160	; 0xa0
		send_cmd[2]=0x00;
  20322a:	f88d 500e 	strb.w	r5, [sp, #14]
		HAL_I2C_Master_Transmit(JY901_I2C,JY901_I2C_ADDRESS,(uint8_t*)send_cmd,3,0xF);
  20322e:	9300      	str	r3, [sp, #0]
  203230:	2303      	movs	r3, #3
  203232:	6800      	ldr	r0, [r0, #0]
  203234:	f7fe f8b8 	bl	2013a8 <HAL_I2C_Master_Transmit>
		for(uint8_t i=0;i<cycletime;i++){
  203238:	b2eb      	uxtb	r3, r5
  20323a:	429c      	cmp	r4, r3
  20323c:	d801      	bhi.n	203242 <JY901_calibration+0x82>
}
  20323e:	b004      	add	sp, #16
  203240:	bd70      	pop	{r4, r5, r6, pc}
			HAL_Delay(1000);
  203242:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  203246:	3501      	adds	r5, #1
  203248:	f7fd fc2c 	bl	200aa4 <HAL_Delay>
			HAL_IWDG_Refresh(&hiwdg);
  20324c:	4630      	mov	r0, r6
  20324e:	f7fe fa7b 	bl	201748 <HAL_IWDG_Refresh>
  203252:	e7f1      	b.n	203238 <JY901_calibration+0x78>
		send_cmd[0]=0x01;
  203254:	2301      	movs	r3, #1
  203256:	f88d 300c 	strb.w	r3, [sp, #12]
		send_cmd[1]=0x00;
  20325a:	2300      	movs	r3, #0
		send_cmd[1]=0x00;
  20325c:	f88d 300d 	strb.w	r3, [sp, #13]
  203260:	e7c7      	b.n	2031f2 <JY901_calibration+0x32>
		send_cmd[0]=0x00;
  203262:	2300      	movs	r3, #0
  203264:	f88d 300c 	strb.w	r3, [sp, #12]
  203268:	e7f8      	b.n	20325c <JY901_calibration+0x9c>
  20326a:	bf00      	nop
  20326c:	20000050 	.word	0x20000050
  203270:	20000168 	.word	0x20000168

00203274 <JY901_def_set>:

int JY901_def_set(){
  203274:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	    uint8_t yaw[2];
	    uint16_t  def;
	    HAL_I2C_Mem_Read(JY901_I2C,JY901_I2C_ADDRESS,0x3F,I2C_MEMADD_SIZE_8BIT,(uint8_t*)yaw,2,0xFF);
  203276:	23ff      	movs	r3, #255	; 0xff
  203278:	480c      	ldr	r0, [pc, #48]	; (2032ac <JY901_def_set+0x38>)
  20327a:	223f      	movs	r2, #63	; 0x3f
  20327c:	21a0      	movs	r1, #160	; 0xa0
  20327e:	9302      	str	r3, [sp, #8]
  203280:	2302      	movs	r3, #2
  203282:	9301      	str	r3, [sp, #4]
  203284:	ab05      	add	r3, sp, #20
  203286:	9300      	str	r3, [sp, #0]
  203288:	2301      	movs	r3, #1
  20328a:	6800      	ldr	r0, [r0, #0]
  20328c:	f7fe f925 	bl	2014da <HAL_I2C_Mem_Read>
	    uint8_t yawl=yaw[0];
	    uint8_t yawh=yaw[1];
	    def = ((yawh<< 8 ) | yawl ) * 180/ 32768 ;
  203290:	f8bd 3014 	ldrh.w	r3, [sp, #20]
  203294:	20b4      	movs	r0, #180	; 0xb4
  203296:	4358      	muls	r0, r3
  203298:	f3c0 30cf 	ubfx	r0, r0, #15, #16
	    def=(def-359)*(-1);
  20329c:	f5c0 70b3 	rsb	r0, r0, #358	; 0x166
  2032a0:	3001      	adds	r0, #1
	    if(def<0){
	    	def=360+def;
	    }
	    return def;
}
  2032a2:	b280      	uxth	r0, r0
  2032a4:	b007      	add	sp, #28
  2032a6:	f85d fb04 	ldr.w	pc, [sp], #4
  2032aa:	bf00      	nop
  2032ac:	20000050 	.word	0x20000050

002032b0 <JY901_yaw_get>:

int JY901_yaw_get(uint16_t def){
  2032b0:	b510      	push	{r4, lr}
    uint8_t yaw[2];
    uint16_t digree;
    HAL_I2C_Mem_Read(JY901_I2C,JY901_I2C_ADDRESS,0x3F,I2C_MEMADD_SIZE_8BIT,(uint8_t*)yaw,2,0xFF);
  2032b2:	23ff      	movs	r3, #255	; 0xff
int JY901_yaw_get(uint16_t def){
  2032b4:	b086      	sub	sp, #24
  2032b6:	4604      	mov	r4, r0
    HAL_I2C_Mem_Read(JY901_I2C,JY901_I2C_ADDRESS,0x3F,I2C_MEMADD_SIZE_8BIT,(uint8_t*)yaw,2,0xFF);
  2032b8:	480d      	ldr	r0, [pc, #52]	; (2032f0 <JY901_yaw_get+0x40>)
  2032ba:	9302      	str	r3, [sp, #8]
  2032bc:	2302      	movs	r3, #2
  2032be:	223f      	movs	r2, #63	; 0x3f
  2032c0:	21a0      	movs	r1, #160	; 0xa0
  2032c2:	9301      	str	r3, [sp, #4]
  2032c4:	ab05      	add	r3, sp, #20
  2032c6:	9300      	str	r3, [sp, #0]
  2032c8:	2301      	movs	r3, #1
  2032ca:	6800      	ldr	r0, [r0, #0]
  2032cc:	f7fe f905 	bl	2014da <HAL_I2C_Mem_Read>
    uint8_t yawl=yaw[0];
    uint8_t yawh=yaw[1];
    int Hx;
    Hx = ((yawh<< 8 ) | yawl ) * 180/ 32768 ;
  2032d0:	f8bd 3014 	ldrh.w	r3, [sp, #20]
  2032d4:	20b4      	movs	r0, #180	; 0xb4
  2032d6:	4343      	muls	r3, r0
    Hx=(Hx-359)*(-1);
  2032d8:	f240 1067 	movw	r0, #359	; 0x167
  2032dc:	eba0 30e3 	sub.w	r0, r0, r3, asr #15
    Hx = Hx - def;
     if(Hx<0){
  2032e0:	1b00      	subs	r0, r0, r4
     digree=Hx+360;
  2032e2:	bf48      	it	mi
  2032e4:	f500 70b4 	addmi.w	r0, r0, #360	; 0x168
     }
     else{
     digree=Hx;
  2032e8:	b280      	uxth	r0, r0
     }
     return digree;
}
  2032ea:	b006      	add	sp, #24
  2032ec:	bd10      	pop	{r4, pc}
  2032ee:	bf00      	nop
  2032f0:	20000050 	.word	0x20000050

002032f4 <servo>:

uint32_t uwDirectionCounta = 0;
uint32_t uwDirectionCountb = 0;


void servo(int16_t a,int16_t b,int16_t c,int16_t d,int16_t e,int16_t f,int16_t g,int16_t h,int16_t i,int16_t j){
  2032f4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
		a=a;
		b=b-10;
  2032f8:	f1a1 040a 	sub.w	r4, r1, #10
  2032fc:	28b4      	cmp	r0, #180	; 0xb4
		c=c-10;
  2032fe:	f1a2 050a 	sub.w	r5, r2, #10
		HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_4);
		HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_4);
}

long map_a(long x, long in_min, long in_max, long out_min, long out_max) {
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  203302:	f04f 0bb4 	mov.w	fp, #180	; 0xb4
		b=b-10;
  203306:	b224      	sxth	r4, r4
  203308:	bfa8      	it	ge
  20330a:	20b4      	movge	r0, #180	; 0xb4
		c=c-10;
  20330c:	b22d      	sxth	r5, r5
void servo(int16_t a,int16_t b,int16_t c,int16_t d,int16_t e,int16_t f,int16_t g,int16_t h,int16_t i,int16_t j){
  20330e:	f9bd 6028 	ldrsh.w	r6, [sp, #40]	; 0x28
  203312:	2c69      	cmp	r4, #105	; 0x69
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  203314:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
		  sConfigOC.Pulse = map_a(a,0,180,350,1220);
  203318:	f8df 80fc 	ldr.w	r8, [pc, #252]	; 203418 <servo+0x124>
		  HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_1);
  20331c:	f04f 0200 	mov.w	r2, #0
  203320:	bfa8      	it	ge
  203322:	2469      	movge	r4, #105	; 0x69
  203324:	2d69      	cmp	r5, #105	; 0x69
  203326:	f8df 90f4 	ldr.w	r9, [pc, #244]	; 20341c <servo+0x128>
  20332a:	4641      	mov	r1, r8
  20332c:	bfa8      	it	ge
  20332e:	2569      	movge	r5, #105	; 0x69
  203330:	2b64      	cmp	r3, #100	; 0x64
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  203332:	f44f 7a61 	mov.w	sl, #900	; 0x384
  203336:	bfa8      	it	ge
  203338:	2364      	movge	r3, #100	; 0x64
  20333a:	2eaa      	cmp	r6, #170	; 0xaa
  20333c:	461f      	mov	r7, r3
  20333e:	f240 3366 	movw	r3, #870	; 0x366
  203342:	bfa8      	it	ge
  203344:	26aa      	movge	r6, #170	; 0xaa
  203346:	fb10 f003 	smulbb	r0, r0, r3
  20334a:	fb90 f0fb 	sdiv	r0, r0, fp
  20334e:	f500 70af 	add.w	r0, r0, #350	; 0x15e
		  sConfigOC.Pulse = map_a(a,0,180,350,1220);
  203352:	f8c8 0004 	str.w	r0, [r8, #4]
		  HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_1);
  203356:	4648      	mov	r0, r9
  203358:	f7ff fa9a 	bl	202890 <HAL_TIM_PWM_ConfigChannel>
		  HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_1);
  20335c:	2100      	movs	r1, #0
  20335e:	4648      	mov	r0, r9
  203360:	f7ff f9c0 	bl	2026e4 <HAL_TIM_PWM_Start>
		  sConfigOC.Pulse = map_a(b,180,0,250,1150);
  203364:	2c05      	cmp	r4, #5
		  HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_2);
  203366:	f04f 0204 	mov.w	r2, #4
  20336a:	4641      	mov	r1, r8
		  sConfigOC.Pulse = map_a(b,180,0,250,1150);
  20336c:	bfb8      	it	lt
  20336e:	2405      	movlt	r4, #5
		  HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_2);
  203370:	4648      	mov	r0, r9
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  203372:	f1a4 03b4 	sub.w	r3, r4, #180	; 0xb4
  203376:	f06f 04b3 	mvn.w	r4, #179	; 0xb3
  20337a:	fb0a f303 	mul.w	r3, sl, r3
  20337e:	fb93 f3f4 	sdiv	r3, r3, r4
  203382:	33fa      	adds	r3, #250	; 0xfa
		  sConfigOC.Pulse = map_a(b,180,0,250,1150);
  203384:	f8c8 3004 	str.w	r3, [r8, #4]
		  HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_2);
  203388:	f7ff fa82 	bl	202890 <HAL_TIM_PWM_ConfigChannel>
		  HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_2);
  20338c:	2104      	movs	r1, #4
  20338e:	4648      	mov	r0, r9
  203390:	f7ff f9a8 	bl	2026e4 <HAL_TIM_PWM_Start>
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  203394:	2d05      	cmp	r5, #5
		  HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_3);
  203396:	f04f 0208 	mov.w	r2, #8
  20339a:	4641      	mov	r1, r8
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  20339c:	bfb8      	it	lt
  20339e:	2505      	movlt	r5, #5
		  HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_3);
  2033a0:	4648      	mov	r0, r9
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  2033a2:	fb15 f50a 	smulbb	r5, r5, sl
  2033a6:	fb95 f5fb 	sdiv	r5, r5, fp
  2033aa:	35fa      	adds	r5, #250	; 0xfa
		  sConfigOC.Pulse = map_a(c,0,180,250,1150);
  2033ac:	f8c8 5004 	str.w	r5, [r8, #4]
		  HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_3);
  2033b0:	f7ff fa6e 	bl	202890 <HAL_TIM_PWM_ConfigChannel>
		  HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_3);
  2033b4:	2108      	movs	r1, #8
  2033b6:	4648      	mov	r0, r9
  2033b8:	f7ff f994 	bl	2026e4 <HAL_TIM_PWM_Start>
		  sConfigOC.Pulse = map_a(d,180,0,250,1150);
  2033bc:	2f14      	cmp	r7, #20
		  HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_4);
  2033be:	f04f 020c 	mov.w	r2, #12
  2033c2:	4641      	mov	r1, r8
		  sConfigOC.Pulse = map_a(d,180,0,250,1150);
  2033c4:	bfb8      	it	lt
  2033c6:	2714      	movlt	r7, #20
		  HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_4);
  2033c8:	4648      	mov	r0, r9
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  2033ca:	193b      	adds	r3, r7, r4
  2033cc:	fb0a f303 	mul.w	r3, sl, r3
  2033d0:	fb93 f3f4 	sdiv	r3, r3, r4
  2033d4:	33fa      	adds	r3, #250	; 0xfa
		  HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_1) ;
  2033d6:	4c0f      	ldr	r4, [pc, #60]	; (203414 <servo+0x120>)
		  sConfigOC.Pulse = map_a(d,180,0,250,1150);
  2033d8:	f8c8 3004 	str.w	r3, [r8, #4]
		  HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_4);
  2033dc:	f7ff fa58 	bl	202890 <HAL_TIM_PWM_ConfigChannel>
		  HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_4) ;
  2033e0:	210c      	movs	r1, #12
  2033e2:	4648      	mov	r0, r9
  2033e4:	f7ff f97e 	bl	2026e4 <HAL_TIM_PWM_Start>
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  2033e8:	2e0a      	cmp	r6, #10
		  HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_1) ;
  2033ea:	4641      	mov	r1, r8
  2033ec:	4620      	mov	r0, r4
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  2033ee:	bfb8      	it	lt
  2033f0:	260a      	movlt	r6, #10
		  HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_1) ;
  2033f2:	2200      	movs	r2, #0
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  2033f4:	fb16 f60a 	smulbb	r6, r6, sl
  2033f8:	fb96 fbfb 	sdiv	fp, r6, fp
  2033fc:	f10b 06fa 	add.w	r6, fp, #250	; 0xfa
		  sConfigOC.Pulse = map_a(e,0,180,250,1150);
  203400:	f8c8 6004 	str.w	r6, [r8, #4]
		  HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_1) ;
  203404:	f7ff fa44 	bl	202890 <HAL_TIM_PWM_ConfigChannel>
		  HAL_TIM_PWM_Start(&htim4, TIM_CHANNEL_1) ;
  203408:	4620      	mov	r0, r4
  20340a:	2100      	movs	r1, #0
}
  20340c:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
		  HAL_TIM_PWM_Start(&htim4, TIM_CHANNEL_1) ;
  203410:	f7ff b968 	b.w	2026e4 <HAL_TIM_PWM_Start>
  203414:	20000258 	.word	0x20000258
  203418:	20000060 	.word	0x20000060
  20341c:	20000318 	.word	0x20000318

00203420 <encordermotor1>:
int encordermotor1(uint8_t place1){
  203420:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	uwDirectionCounta = TIM5->CNT;
  203424:	4f5b      	ldr	r7, [pc, #364]	; (203594 <encordermotor1+0x174>)
	if(place1==0){
  203426:	4606      	mov	r6, r0
	uwDirectionCounta = TIM5->CNT;
  203428:	f8df 817c 	ldr.w	r8, [pc, #380]	; 2035a8 <encordermotor1+0x188>
  20342c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  20342e:	4d5a      	ldr	r5, [pc, #360]	; (203598 <encordermotor1+0x178>)
  203430:	f8c8 2000 	str.w	r2, [r8]
	if(place1==0){
  203434:	bb18      	cbnz	r0, 20347e <encordermotor1+0x5e>
			if(HAL_GPIO_ReadPin(GPIOD,GPIO_PIN_1)==0){
  203436:	2102      	movs	r1, #2
  203438:	4858      	ldr	r0, [pc, #352]	; (20359c <encordermotor1+0x17c>)
  20343a:	f7fd fe4b 	bl	2010d4 <HAL_GPIO_ReadPin>
  20343e:	4604      	mov	r4, r0
  203440:	b918      	cbnz	r0, 20344a <encordermotor1+0x2a>
				TIM5->CNT = en1min;
  203442:	f247 5330 	movw	r3, #30000	; 0x7530
			TIM5->CNT = en1max;
  203446:	627b      	str	r3, [r7, #36]	; 0x24
  203448:	e050      	b.n	2034ec <encordermotor1+0xcc>
				sConfigOC.Pulse = 700;
  20344a:	f44f 732f 	mov.w	r3, #700	; 0x2bc
				HAL_TIM_PWM_ConfigChannel(&htim12, &sConfigOC, TIM_CHANNEL_1) ;
  20344e:	4632      	mov	r2, r6
  203450:	4629      	mov	r1, r5
  203452:	4853      	ldr	r0, [pc, #332]	; (2035a0 <encordermotor1+0x180>)
				sConfigOC.Pulse = 700;
  203454:	606b      	str	r3, [r5, #4]
				HAL_TIM_PWM_ConfigChannel(&htim12, &sConfigOC, TIM_CHANNEL_1) ;
  203456:	f7ff fa1b 	bl	202890 <HAL_TIM_PWM_ConfigChannel>
				HAL_TIM_PWM_Start(&htim12, TIM_CHANNEL_1);
  20345a:	4631      	mov	r1, r6
  20345c:	4850      	ldr	r0, [pc, #320]	; (2035a0 <encordermotor1+0x180>)
  20345e:	f7ff f941 	bl	2026e4 <HAL_TIM_PWM_Start>
				sConfigOC.Pulse = 0;
  203462:	606e      	str	r6, [r5, #4]
		HAL_TIM_PWM_ConfigChannel(&htim12, &sConfigOC, TIM_CHANNEL_2);
  203464:	2204      	movs	r2, #4
  203466:	4629      	mov	r1, r5
  203468:	484d      	ldr	r0, [pc, #308]	; (2035a0 <encordermotor1+0x180>)
		return 2;
  20346a:	2402      	movs	r4, #2
		HAL_TIM_PWM_ConfigChannel(&htim12, &sConfigOC, TIM_CHANNEL_2);
  20346c:	f7ff fa10 	bl	202890 <HAL_TIM_PWM_ConfigChannel>
		HAL_TIM_PWM_Start(&htim12, TIM_CHANNEL_2);
  203470:	2104      	movs	r1, #4
  203472:	484b      	ldr	r0, [pc, #300]	; (2035a0 <encordermotor1+0x180>)
  203474:	f7ff f936 	bl	2026e4 <HAL_TIM_PWM_Start>
}
  203478:	4620      	mov	r0, r4
  20347a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		else if(place1==250){
  20347e:	28fa      	cmp	r0, #250	; 0xfa
  203480:	d121      	bne.n	2034c6 <encordermotor1+0xa6>
			if(HAL_GPIO_ReadPin(GPIOD,GPIO_PIN_3)==0){
  203482:	2108      	movs	r1, #8
  203484:	4845      	ldr	r0, [pc, #276]	; (20359c <encordermotor1+0x17c>)
  203486:	f7fd fe25 	bl	2010d4 <HAL_GPIO_ReadPin>
  20348a:	4604      	mov	r4, r0
  20348c:	b910      	cbnz	r0, 203494 <encordermotor1+0x74>
			TIM5->CNT = en1max;
  20348e:	f247 4318 	movw	r3, #29720	; 0x7418
  203492:	e7d8      	b.n	203446 <encordermotor1+0x26>
				sConfigOC.Pulse = 0;
  203494:	2400      	movs	r4, #0
				HAL_TIM_PWM_ConfigChannel(&htim12, &sConfigOC, TIM_CHANNEL_1) ;
  203496:	4629      	mov	r1, r5
  203498:	4841      	ldr	r0, [pc, #260]	; (2035a0 <encordermotor1+0x180>)
  20349a:	4622      	mov	r2, r4
				sConfigOC.Pulse = 0;
  20349c:	606c      	str	r4, [r5, #4]
				HAL_TIM_PWM_ConfigChannel(&htim12, &sConfigOC, TIM_CHANNEL_1) ;
  20349e:	f7ff f9f7 	bl	202890 <HAL_TIM_PWM_ConfigChannel>
				HAL_TIM_PWM_Start(&htim12, TIM_CHANNEL_1);
  2034a2:	4621      	mov	r1, r4
  2034a4:	483e      	ldr	r0, [pc, #248]	; (2035a0 <encordermotor1+0x180>)
  2034a6:	f7ff f91d 	bl	2026e4 <HAL_TIM_PWM_Start>
				sConfigOC.Pulse = 700;
  2034aa:	f44f 732f 	mov.w	r3, #700	; 0x2bc
  2034ae:	606b      	str	r3, [r5, #4]
		HAL_TIM_PWM_ConfigChannel(&htim12, &sConfigOC, TIM_CHANNEL_2) ;
  2034b0:	2204      	movs	r2, #4
  2034b2:	4629      	mov	r1, r5
  2034b4:	483a      	ldr	r0, [pc, #232]	; (2035a0 <encordermotor1+0x180>)
		return 1;
  2034b6:	2401      	movs	r4, #1
		HAL_TIM_PWM_ConfigChannel(&htim12, &sConfigOC, TIM_CHANNEL_2) ;
  2034b8:	f7ff f9ea 	bl	202890 <HAL_TIM_PWM_ConfigChannel>
		HAL_TIM_PWM_Start(&htim12, TIM_CHANNEL_2);
  2034bc:	2104      	movs	r1, #4
  2034be:	4838      	ldr	r0, [pc, #224]	; (2035a0 <encordermotor1+0x180>)
  2034c0:	f7ff f910 	bl	2026e4 <HAL_TIM_PWM_Start>
		return 1;
  2034c4:	e7d8      	b.n	203478 <encordermotor1+0x58>
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  2034c6:	4b37      	ldr	r3, [pc, #220]	; (2035a4 <encordermotor1+0x184>)
  2034c8:	f247 5930 	movw	r9, #30000	; 0x7530
  2034cc:	435e      	muls	r6, r3
  2034ce:	23fa      	movs	r3, #250	; 0xfa
  2034d0:	fb96 f6f3 	sdiv	r6, r6, r3
  2034d4:	444e      	add	r6, r9
	if(uwDirectionCounta<(placetemp1-5)){
  2034d6:	1f73      	subs	r3, r6, #5
  2034d8:	429a      	cmp	r2, r3
  2034da:	d235      	bcs.n	203548 <encordermotor1+0x128>
		if(HAL_GPIO_ReadPin(GPIOD,GPIO_PIN_1)==0){
  2034dc:	2102      	movs	r1, #2
  2034de:	482f      	ldr	r0, [pc, #188]	; (20359c <encordermotor1+0x17c>)
  2034e0:	f7fd fdf8 	bl	2010d4 <HAL_GPIO_ReadPin>
  2034e4:	4604      	mov	r4, r0
  2034e6:	b9b0      	cbnz	r0, 203516 <encordermotor1+0xf6>
			TIM5->CNT = en1min;
  2034e8:	f8c7 9024 	str.w	r9, [r7, #36]	; 0x24
		HAL_TIM_PWM_ConfigChannel(&htim12, &sConfigOC, TIM_CHANNEL_1) ;
  2034ec:	4622      	mov	r2, r4
  2034ee:	4629      	mov	r1, r5
  2034f0:	482b      	ldr	r0, [pc, #172]	; (2035a0 <encordermotor1+0x180>)
		sConfigOC.Pulse = 0;
  2034f2:	606c      	str	r4, [r5, #4]
		HAL_TIM_PWM_ConfigChannel(&htim12, &sConfigOC, TIM_CHANNEL_1) ;
  2034f4:	f7ff f9cc 	bl	202890 <HAL_TIM_PWM_ConfigChannel>
		HAL_TIM_PWM_Start(&htim12, TIM_CHANNEL_1);
  2034f8:	4621      	mov	r1, r4
  2034fa:	4829      	ldr	r0, [pc, #164]	; (2035a0 <encordermotor1+0x180>)
  2034fc:	f7ff f8f2 	bl	2026e4 <HAL_TIM_PWM_Start>
		HAL_TIM_PWM_ConfigChannel(&htim12, &sConfigOC, TIM_CHANNEL_2);
  203500:	4629      	mov	r1, r5
  203502:	2204      	movs	r2, #4
  203504:	4826      	ldr	r0, [pc, #152]	; (2035a0 <encordermotor1+0x180>)
		sConfigOC.Pulse = 0;
  203506:	606c      	str	r4, [r5, #4]
		HAL_TIM_PWM_ConfigChannel(&htim12, &sConfigOC, TIM_CHANNEL_2);
  203508:	f7ff f9c2 	bl	202890 <HAL_TIM_PWM_ConfigChannel>
		HAL_TIM_PWM_Start(&htim12, TIM_CHANNEL_2) ;
  20350c:	2104      	movs	r1, #4
  20350e:	4824      	ldr	r0, [pc, #144]	; (2035a0 <encordermotor1+0x180>)
  203510:	f7ff f8e8 	bl	2026e4 <HAL_TIM_PWM_Start>
		return HAL_OK;
  203514:	e7b0      	b.n	203478 <encordermotor1+0x58>
		sConfigOC.Pulse = map_a((placetemp1 - uwDirectionCounta), 0, en1min-en1max, 500, 1000);
  203516:	f8d8 3000 	ldr.w	r3, [r8]
		HAL_TIM_PWM_ConfigChannel(&htim12, &sConfigOC, TIM_CHANNEL_1);
  20351a:	2200      	movs	r2, #0
  20351c:	4629      	mov	r1, r5
  20351e:	4820      	ldr	r0, [pc, #128]	; (2035a0 <encordermotor1+0x180>)
		sConfigOC.Pulse = map_a((placetemp1 - uwDirectionCounta), 0, en1min-en1max, 500, 1000);
  203520:	1af3      	subs	r3, r6, r3
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  203522:	f44f 76fa 	mov.w	r6, #500	; 0x1f4
  203526:	435e      	muls	r6, r3
  203528:	f44f 738c 	mov.w	r3, #280	; 0x118
  20352c:	fb96 f6f3 	sdiv	r6, r6, r3
  203530:	f506 76fa 	add.w	r6, r6, #500	; 0x1f4
		sConfigOC.Pulse = map_a((placetemp1 - uwDirectionCounta), 0, en1min-en1max, 500, 1000);
  203534:	606e      	str	r6, [r5, #4]
		HAL_TIM_PWM_ConfigChannel(&htim12, &sConfigOC, TIM_CHANNEL_1);
  203536:	f7ff f9ab 	bl	202890 <HAL_TIM_PWM_ConfigChannel>
		HAL_TIM_PWM_Start(&htim12, TIM_CHANNEL_1);
  20353a:	2100      	movs	r1, #0
  20353c:	4818      	ldr	r0, [pc, #96]	; (2035a0 <encordermotor1+0x180>)
  20353e:	f7ff f8d1 	bl	2026e4 <HAL_TIM_PWM_Start>
		sConfigOC.Pulse = 0;
  203542:	2300      	movs	r3, #0
  203544:	606b      	str	r3, [r5, #4]
  203546:	e78d      	b.n	203464 <encordermotor1+0x44>
	else if(uwDirectionCounta>=(placetemp1+5)){
  203548:	1d73      	adds	r3, r6, #5
  20354a:	429a      	cmp	r2, r3
  20354c:	d31f      	bcc.n	20358e <encordermotor1+0x16e>
		if(HAL_GPIO_ReadPin(GPIOD,GPIO_PIN_3)==0){
  20354e:	2108      	movs	r1, #8
  203550:	4812      	ldr	r0, [pc, #72]	; (20359c <encordermotor1+0x17c>)
  203552:	f7fd fdbf 	bl	2010d4 <HAL_GPIO_ReadPin>
  203556:	4604      	mov	r4, r0
  203558:	2800      	cmp	r0, #0
  20355a:	d098      	beq.n	20348e <encordermotor1+0x6e>
		sConfigOC.Pulse = 0;
  20355c:	2400      	movs	r4, #0
		HAL_TIM_PWM_ConfigChannel(&htim12, &sConfigOC, TIM_CHANNEL_1);
  20355e:	4629      	mov	r1, r5
  203560:	480f      	ldr	r0, [pc, #60]	; (2035a0 <encordermotor1+0x180>)
  203562:	4622      	mov	r2, r4
		sConfigOC.Pulse = 0;
  203564:	606c      	str	r4, [r5, #4]
		HAL_TIM_PWM_ConfigChannel(&htim12, &sConfigOC, TIM_CHANNEL_1);
  203566:	f7ff f993 	bl	202890 <HAL_TIM_PWM_ConfigChannel>
		HAL_TIM_PWM_Start(&htim12, TIM_CHANNEL_1);
  20356a:	4621      	mov	r1, r4
  20356c:	480c      	ldr	r0, [pc, #48]	; (2035a0 <encordermotor1+0x180>)
  20356e:	f7ff f8b9 	bl	2026e4 <HAL_TIM_PWM_Start>
		sConfigOC.Pulse =map_a((uwDirectionCounta - placetemp1), 0, en1min-en1max, 500, 1000);
  203572:	f8d8 3000 	ldr.w	r3, [r8]
  203576:	1b9b      	subs	r3, r3, r6
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  203578:	f44f 76fa 	mov.w	r6, #500	; 0x1f4
  20357c:	435e      	muls	r6, r3
  20357e:	f44f 738c 	mov.w	r3, #280	; 0x118
  203582:	fb96 f6f3 	sdiv	r6, r6, r3
  203586:	f506 76fa 	add.w	r6, r6, #500	; 0x1f4
		sConfigOC.Pulse =map_a((uwDirectionCounta - placetemp1), 0, en1min-en1max, 500, 1000);
  20358a:	606e      	str	r6, [r5, #4]
  20358c:	e790      	b.n	2034b0 <encordermotor1+0x90>
		sConfigOC.Pulse = 0;
  20358e:	2400      	movs	r4, #0
  203590:	e7ac      	b.n	2034ec <encordermotor1+0xcc>
  203592:	bf00      	nop
  203594:	40000c00 	.word	0x40000c00
  203598:	20000060 	.word	0x20000060
  20359c:	40020c00 	.word	0x40020c00
  2035a0:	20000498 	.word	0x20000498
  2035a4:	fffffee8 	.word	0xfffffee8
  2035a8:	20000034 	.word	0x20000034

002035ac <encordermotor2>:
int encordermotor2(uint8_t place2){
  2035ac:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  2035b0:	f44f 76c8 	mov.w	r6, #400	; 0x190
  2035b4:	22fa      	movs	r2, #250	; 0xfa
  2035b6:	f247 5a30 	movw	sl, #30000	; 0x7530
	uwDirectionCountb = TIM8->CNT;
  2035ba:	f8df 8188 	ldr.w	r8, [pc, #392]	; 203744 <encordermotor2+0x198>
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  2035be:	fb06 f300 	mul.w	r3, r6, r0
	uwDirectionCountb = TIM8->CNT;
  2035c2:	f8df 9184 	ldr.w	r9, [pc, #388]	; 203748 <encordermotor2+0x19c>
int encordermotor2(uint8_t place2){
  2035c6:	4607      	mov	r7, r0
  2035c8:	4d5b      	ldr	r5, [pc, #364]	; (203738 <encordermotor2+0x18c>)
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  2035ca:	fb93 f3f2 	sdiv	r3, r3, r2
  2035ce:	4453      	add	r3, sl
	volatile uint32_t placetemp2 =map_a(place2,0,250,en2min,en2max);
  2035d0:	9301      	str	r3, [sp, #4]
	uwDirectionCountb = TIM8->CNT;
  2035d2:	f8d8 2024 	ldr.w	r2, [r8, #36]	; 0x24
  2035d6:	f8c9 2000 	str.w	r2, [r9]
	if(place2==0){
  2035da:	2800      	cmp	r0, #0
  2035dc:	d138      	bne.n	203650 <encordermotor2+0xa4>
		if(HAL_GPIO_ReadPin(GPIOC,GPIO_PIN_10)==0){
  2035de:	f44f 6180 	mov.w	r1, #1024	; 0x400
  2035e2:	4856      	ldr	r0, [pc, #344]	; (20373c <encordermotor2+0x190>)
  2035e4:	f7fd fd76 	bl	2010d4 <HAL_GPIO_ReadPin>
  2035e8:	4604      	mov	r4, r0
  2035ea:	b9b0      	cbnz	r0, 20361a <encordermotor2+0x6e>
				TIM8->CNT = en2min;
  2035ec:	f8c8 a024 	str.w	sl, [r8, #36]	; 0x24
			HAL_TIM_PWM_ConfigChannel(&htim9, &sConfigOC, TIM_CHANNEL_1);
  2035f0:	4622      	mov	r2, r4
  2035f2:	4629      	mov	r1, r5
  2035f4:	4852      	ldr	r0, [pc, #328]	; (203740 <encordermotor2+0x194>)
			sConfigOC.Pulse = 0;
  2035f6:	606c      	str	r4, [r5, #4]
			HAL_TIM_PWM_ConfigChannel(&htim9, &sConfigOC, TIM_CHANNEL_1);
  2035f8:	f7ff f94a 	bl	202890 <HAL_TIM_PWM_ConfigChannel>
			HAL_TIM_PWM_Start(&htim9, TIM_CHANNEL_1);
  2035fc:	4621      	mov	r1, r4
  2035fe:	4850      	ldr	r0, [pc, #320]	; (203740 <encordermotor2+0x194>)
  203600:	f7ff f870 	bl	2026e4 <HAL_TIM_PWM_Start>
			HAL_TIM_PWM_ConfigChannel(&htim9, &sConfigOC, TIM_CHANNEL_2);
  203604:	4629      	mov	r1, r5
  203606:	2204      	movs	r2, #4
  203608:	484d      	ldr	r0, [pc, #308]	; (203740 <encordermotor2+0x194>)
			sConfigOC.Pulse = 0;
  20360a:	606c      	str	r4, [r5, #4]
			HAL_TIM_PWM_ConfigChannel(&htim9, &sConfigOC, TIM_CHANNEL_2);
  20360c:	f7ff f940 	bl	202890 <HAL_TIM_PWM_ConfigChannel>
			HAL_TIM_PWM_Start(&htim9, TIM_CHANNEL_2);
  203610:	2104      	movs	r1, #4
  203612:	484b      	ldr	r0, [pc, #300]	; (203740 <encordermotor2+0x194>)
  203614:	f7ff f866 	bl	2026e4 <HAL_TIM_PWM_Start>
			return HAL_OK;
  203618:	e016      	b.n	203648 <encordermotor2+0x9c>
			sConfigOC.Pulse = 700;
  20361a:	f44f 732f 	mov.w	r3, #700	; 0x2bc
			HAL_TIM_PWM_ConfigChannel(&htim9, &sConfigOC, TIM_CHANNEL_1);
  20361e:	463a      	mov	r2, r7
  203620:	4629      	mov	r1, r5
  203622:	4847      	ldr	r0, [pc, #284]	; (203740 <encordermotor2+0x194>)
			sConfigOC.Pulse = 700;
  203624:	606b      	str	r3, [r5, #4]
			HAL_TIM_PWM_ConfigChannel(&htim9, &sConfigOC, TIM_CHANNEL_1);
  203626:	f7ff f933 	bl	202890 <HAL_TIM_PWM_ConfigChannel>
			HAL_TIM_PWM_Start(&htim9, TIM_CHANNEL_1);
  20362a:	4639      	mov	r1, r7
  20362c:	4844      	ldr	r0, [pc, #272]	; (203740 <encordermotor2+0x194>)
  20362e:	f7ff f859 	bl	2026e4 <HAL_TIM_PWM_Start>
			sConfigOC.Pulse = 0;
  203632:	606f      	str	r7, [r5, #4]
			HAL_TIM_PWM_ConfigChannel(&htim9, &sConfigOC, TIM_CHANNEL_2);
  203634:	2204      	movs	r2, #4
  203636:	4629      	mov	r1, r5
  203638:	4841      	ldr	r0, [pc, #260]	; (203740 <encordermotor2+0x194>)
			return 2;
  20363a:	2402      	movs	r4, #2
			HAL_TIM_PWM_ConfigChannel(&htim9, &sConfigOC, TIM_CHANNEL_2);
  20363c:	f7ff f928 	bl	202890 <HAL_TIM_PWM_ConfigChannel>
			HAL_TIM_PWM_Start(&htim9, TIM_CHANNEL_2);
  203640:	2104      	movs	r1, #4
  203642:	483f      	ldr	r0, [pc, #252]	; (203740 <encordermotor2+0x194>)
  203644:	f7ff f84e 	bl	2026e4 <HAL_TIM_PWM_Start>
}
  203648:	4620      	mov	r0, r4
  20364a:	b002      	add	sp, #8
  20364c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	else if(place2==250){
  203650:	28fa      	cmp	r0, #250	; 0xfa
  203652:	d124      	bne.n	20369e <encordermotor2+0xf2>
		if(HAL_GPIO_ReadPin(GPIOC,GPIO_PIN_12)==0){
  203654:	f44f 5180 	mov.w	r1, #4096	; 0x1000
  203658:	4838      	ldr	r0, [pc, #224]	; (20373c <encordermotor2+0x190>)
  20365a:	f7fd fd3b 	bl	2010d4 <HAL_GPIO_ReadPin>
  20365e:	4604      	mov	r4, r0
  203660:	b920      	cbnz	r0, 20366c <encordermotor2+0xc0>
			TIM8->CNT = en2max;
  203662:	f247 63c0 	movw	r3, #30400	; 0x76c0
  203666:	f8c8 3024 	str.w	r3, [r8, #36]	; 0x24
  20366a:	e7c1      	b.n	2035f0 <encordermotor2+0x44>
			sConfigOC.Pulse = 0;
  20366c:	2400      	movs	r4, #0
			HAL_TIM_PWM_ConfigChannel(&htim9, &sConfigOC, TIM_CHANNEL_1);
  20366e:	4629      	mov	r1, r5
  203670:	4833      	ldr	r0, [pc, #204]	; (203740 <encordermotor2+0x194>)
  203672:	4622      	mov	r2, r4
			sConfigOC.Pulse = 0;
  203674:	606c      	str	r4, [r5, #4]
			HAL_TIM_PWM_ConfigChannel(&htim9, &sConfigOC, TIM_CHANNEL_1);
  203676:	f7ff f90b 	bl	202890 <HAL_TIM_PWM_ConfigChannel>
			HAL_TIM_PWM_Start(&htim9, TIM_CHANNEL_1);
  20367a:	4621      	mov	r1, r4
  20367c:	4830      	ldr	r0, [pc, #192]	; (203740 <encordermotor2+0x194>)
  20367e:	f7ff f831 	bl	2026e4 <HAL_TIM_PWM_Start>
			sConfigOC.Pulse = 700;
  203682:	f44f 732f 	mov.w	r3, #700	; 0x2bc
			HAL_TIM_PWM_ConfigChannel(&htim9, &sConfigOC, TIM_CHANNEL_2) ;
  203686:	2204      	movs	r2, #4
  203688:	4629      	mov	r1, r5
  20368a:	482d      	ldr	r0, [pc, #180]	; (203740 <encordermotor2+0x194>)
			return 1;
  20368c:	2401      	movs	r4, #1
			sConfigOC.Pulse =0;
  20368e:	606b      	str	r3, [r5, #4]
			HAL_TIM_PWM_ConfigChannel(&htim9, &sConfigOC, TIM_CHANNEL_2) ;
  203690:	f7ff f8fe 	bl	202890 <HAL_TIM_PWM_ConfigChannel>
			HAL_TIM_PWM_Start(&htim9, TIM_CHANNEL_2);
  203694:	2104      	movs	r1, #4
  203696:	482a      	ldr	r0, [pc, #168]	; (203740 <encordermotor2+0x194>)
  203698:	f7ff f824 	bl	2026e4 <HAL_TIM_PWM_Start>
			return 1;
  20369c:	e7d4      	b.n	203648 <encordermotor2+0x9c>
		if(uwDirectionCountb < (placetemp2-10)){
  20369e:	9b01      	ldr	r3, [sp, #4]
  2036a0:	3b0a      	subs	r3, #10
  2036a2:	429a      	cmp	r2, r3
  2036a4:	d223      	bcs.n	2036ee <encordermotor2+0x142>
			if(HAL_GPIO_ReadPin(GPIOC,GPIO_PIN_12)==0){
  2036a6:	f44f 5180 	mov.w	r1, #4096	; 0x1000
  2036aa:	4824      	ldr	r0, [pc, #144]	; (20373c <encordermotor2+0x190>)
  2036ac:	f7fd fd12 	bl	2010d4 <HAL_GPIO_ReadPin>
  2036b0:	4604      	mov	r4, r0
  2036b2:	2800      	cmp	r0, #0
  2036b4:	d09a      	beq.n	2035ec <encordermotor2+0x40>
			sConfigOC.Pulse = 0;
  2036b6:	2400      	movs	r4, #0
			HAL_TIM_PWM_ConfigChannel(&htim9, &sConfigOC, TIM_CHANNEL_1);
  2036b8:	4629      	mov	r1, r5
  2036ba:	4821      	ldr	r0, [pc, #132]	; (203740 <encordermotor2+0x194>)
  2036bc:	4622      	mov	r2, r4
			sConfigOC.Pulse = 0;
  2036be:	606c      	str	r4, [r5, #4]
			HAL_TIM_PWM_ConfigChannel(&htim9, &sConfigOC, TIM_CHANNEL_1);
  2036c0:	f7ff f8e6 	bl	202890 <HAL_TIM_PWM_ConfigChannel>
			HAL_TIM_PWM_Start(&htim9, TIM_CHANNEL_1);
  2036c4:	4621      	mov	r1, r4
  2036c6:	481e      	ldr	r0, [pc, #120]	; (203740 <encordermotor2+0x194>)
  2036c8:	f7ff f80c 	bl	2026e4 <HAL_TIM_PWM_Start>
			sConfigOC.Pulse = map_a(abs(placetemp2 - uwDirectionCountb), 0, (en2max-en2min), 500, 1000);
  2036cc:	f8d9 2000 	ldr.w	r2, [r9]
  2036d0:	9b01      	ldr	r3, [sp, #4]
  2036d2:	1a9b      	subs	r3, r3, r2
  2036d4:	ea83 72e3 	eor.w	r2, r3, r3, asr #31
  2036d8:	eba2 72e3 	sub.w	r2, r2, r3, asr #31
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  2036dc:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
  2036e0:	4353      	muls	r3, r2
  2036e2:	fb93 f3f6 	sdiv	r3, r3, r6
  2036e6:	f503 73fa 	add.w	r3, r3, #500	; 0x1f4
			sConfigOC.Pulse = map_a(abs(placetemp2 - uwDirectionCountb), 0, (en2max-en2min), 500, 1000);
  2036ea:	606b      	str	r3, [r5, #4]
  2036ec:	e7a2      	b.n	203634 <encordermotor2+0x88>
		else if(uwDirectionCountb > (placetemp2+10)){
  2036ee:	9b01      	ldr	r3, [sp, #4]
  2036f0:	330a      	adds	r3, #10
  2036f2:	429a      	cmp	r2, r3
  2036f4:	d91e      	bls.n	203734 <encordermotor2+0x188>
		if(HAL_GPIO_ReadPin(GPIOC,GPIO_PIN_10)==0){
  2036f6:	f44f 6180 	mov.w	r1, #1024	; 0x400
  2036fa:	4810      	ldr	r0, [pc, #64]	; (20373c <encordermotor2+0x190>)
  2036fc:	f7fd fcea 	bl	2010d4 <HAL_GPIO_ReadPin>
  203700:	4604      	mov	r4, r0
  203702:	2800      	cmp	r0, #0
  203704:	d0ad      	beq.n	203662 <encordermotor2+0xb6>
			sConfigOC.Pulse = map_a((uwDirectionCountb - placetemp2), 0, en2max-en2min, 500, 1000);
  203706:	f8d9 3000 	ldr.w	r3, [r9]
			HAL_TIM_PWM_ConfigChannel(&htim9, &sConfigOC, TIM_CHANNEL_1);
  20370a:	4629      	mov	r1, r5
			sConfigOC.Pulse = map_a((uwDirectionCountb - placetemp2), 0, en2max-en2min, 500, 1000);
  20370c:	9a01      	ldr	r2, [sp, #4]
			HAL_TIM_PWM_ConfigChannel(&htim9, &sConfigOC, TIM_CHANNEL_1);
  20370e:	480c      	ldr	r0, [pc, #48]	; (203740 <encordermotor2+0x194>)
			sConfigOC.Pulse = map_a((uwDirectionCountb - placetemp2), 0, en2max-en2min, 500, 1000);
  203710:	1a9a      	subs	r2, r3, r2
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  203712:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
  203716:	4353      	muls	r3, r2
			HAL_TIM_PWM_ConfigChannel(&htim9, &sConfigOC, TIM_CHANNEL_1);
  203718:	2200      	movs	r2, #0
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  20371a:	fb93 f3f6 	sdiv	r3, r3, r6
  20371e:	f503 73fa 	add.w	r3, r3, #500	; 0x1f4
			sConfigOC.Pulse = map_a((uwDirectionCountb - placetemp2), 0, en2max-en2min, 500, 1000);
  203722:	606b      	str	r3, [r5, #4]
			HAL_TIM_PWM_ConfigChannel(&htim9, &sConfigOC, TIM_CHANNEL_1);
  203724:	f7ff f8b4 	bl	202890 <HAL_TIM_PWM_ConfigChannel>
			HAL_TIM_PWM_Start(&htim9, TIM_CHANNEL_1);
  203728:	2100      	movs	r1, #0
  20372a:	4805      	ldr	r0, [pc, #20]	; (203740 <encordermotor2+0x194>)
  20372c:	f7fe ffda 	bl	2026e4 <HAL_TIM_PWM_Start>
			sConfigOC.Pulse =0;
  203730:	2300      	movs	r3, #0
  203732:	e7a8      	b.n	203686 <encordermotor2+0xda>
			sConfigOC.Pulse = 0;
  203734:	2400      	movs	r4, #0
  203736:	e75b      	b.n	2035f0 <encordermotor2+0x44>
  203738:	20000060 	.word	0x20000060
  20373c:	40020800 	.word	0x40020800
  203740:	20000418 	.word	0x20000418
  203744:	40010400 	.word	0x40010400
  203748:	20000038 	.word	0x20000038

0020374c <motor1>:
void motor1(int m1b,int m1a){
  20374c:	b570      	push	{r4, r5, r6, lr}
		sConfigOC.Pulse = m1a;
  20374e:	4d0c      	ldr	r5, [pc, #48]	; (203780 <motor1+0x34>)
void motor1(int m1b,int m1a){
  203750:	4606      	mov	r6, r0
		HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_1);
  203752:	4c0c      	ldr	r4, [pc, #48]	; (203784 <motor1+0x38>)
  203754:	2200      	movs	r2, #0
		sConfigOC.Pulse = m1a;
  203756:	6069      	str	r1, [r5, #4]
		HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_1);
  203758:	4629      	mov	r1, r5
  20375a:	4620      	mov	r0, r4
  20375c:	f7ff f898 	bl	202890 <HAL_TIM_PWM_ConfigChannel>
		HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_1);
  203760:	2100      	movs	r1, #0
  203762:	4620      	mov	r0, r4
  203764:	f7fe ffbe 	bl	2026e4 <HAL_TIM_PWM_Start>
		HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_2);
  203768:	4629      	mov	r1, r5
  20376a:	4620      	mov	r0, r4
  20376c:	2204      	movs	r2, #4
		sConfigOC.Pulse = m1b;
  20376e:	606e      	str	r6, [r5, #4]
		HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_2);
  203770:	f7ff f88e 	bl	202890 <HAL_TIM_PWM_ConfigChannel>
		HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_2);
  203774:	4620      	mov	r0, r4
  203776:	2104      	movs	r1, #4
}
  203778:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_2);
  20377c:	f7fe bfb2 	b.w	2026e4 <HAL_TIM_PWM_Start>
  203780:	20000060 	.word	0x20000060
  203784:	200003d8 	.word	0x200003d8

00203788 <motor2>:
void motor2(int m2a,int m2b){
  203788:	b570      	push	{r4, r5, r6, lr}
		sConfigOC.Pulse = m2a;
  20378a:	4d0c      	ldr	r5, [pc, #48]	; (2037bc <motor2+0x34>)
void motor2(int m2a,int m2b){
  20378c:	460e      	mov	r6, r1
		HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_3);
  20378e:	4c0c      	ldr	r4, [pc, #48]	; (2037c0 <motor2+0x38>)
  203790:	2208      	movs	r2, #8
		sConfigOC.Pulse = m2a;
  203792:	6068      	str	r0, [r5, #4]
		HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_3);
  203794:	4629      	mov	r1, r5
  203796:	4620      	mov	r0, r4
  203798:	f7ff f87a 	bl	202890 <HAL_TIM_PWM_ConfigChannel>
		HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_3);
  20379c:	2108      	movs	r1, #8
  20379e:	4620      	mov	r0, r4
  2037a0:	f7fe ffa0 	bl	2026e4 <HAL_TIM_PWM_Start>
		HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_4);
  2037a4:	4629      	mov	r1, r5
  2037a6:	4620      	mov	r0, r4
  2037a8:	220c      	movs	r2, #12
		sConfigOC.Pulse = m2b;
  2037aa:	606e      	str	r6, [r5, #4]
		HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_4);
  2037ac:	f7ff f870 	bl	202890 <HAL_TIM_PWM_ConfigChannel>
		HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_4) ;
  2037b0:	4620      	mov	r0, r4
  2037b2:	210c      	movs	r1, #12
}
  2037b4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_4) ;
  2037b8:	f7fe bf94 	b.w	2026e4 <HAL_TIM_PWM_Start>
  2037bc:	20000060 	.word	0x20000060
  2037c0:	200003d8 	.word	0x200003d8

002037c4 <motor3>:
void motor3(int m3b,int m3a){
  2037c4:	b570      	push	{r4, r5, r6, lr}
		sConfigOC.Pulse = m3a;
  2037c6:	4d0c      	ldr	r5, [pc, #48]	; (2037f8 <motor3+0x34>)
void motor3(int m3b,int m3a){
  2037c8:	4606      	mov	r6, r0
		HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_1);
  2037ca:	4c0c      	ldr	r4, [pc, #48]	; (2037fc <motor3+0x38>)
  2037cc:	2200      	movs	r2, #0
		sConfigOC.Pulse = m3a;
  2037ce:	6069      	str	r1, [r5, #4]
		HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_1);
  2037d0:	4629      	mov	r1, r5
  2037d2:	4620      	mov	r0, r4
  2037d4:	f7ff f85c 	bl	202890 <HAL_TIM_PWM_ConfigChannel>
		HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_1);
  2037d8:	2100      	movs	r1, #0
  2037da:	4620      	mov	r0, r4
  2037dc:	f7fe ff82 	bl	2026e4 <HAL_TIM_PWM_Start>
		HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_2);
  2037e0:	4629      	mov	r1, r5
  2037e2:	4620      	mov	r0, r4
  2037e4:	2204      	movs	r2, #4
		sConfigOC.Pulse = m3b;
  2037e6:	606e      	str	r6, [r5, #4]
		HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_2);
  2037e8:	f7ff f852 	bl	202890 <HAL_TIM_PWM_ConfigChannel>
		HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_2);
  2037ec:	4620      	mov	r0, r4
  2037ee:	2104      	movs	r1, #4
}
  2037f0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_2);
  2037f4:	f7fe bf76 	b.w	2026e4 <HAL_TIM_PWM_Start>
  2037f8:	20000060 	.word	0x20000060
  2037fc:	20000458 	.word	0x20000458

00203800 <motor4>:
void motor4(int m4a,int m4b){
  203800:	b570      	push	{r4, r5, r6, lr}
		sConfigOC.Pulse = m4a;
  203802:	4d0c      	ldr	r5, [pc, #48]	; (203834 <motor4+0x34>)
void motor4(int m4a,int m4b){
  203804:	460e      	mov	r6, r1
		HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_3);
  203806:	4c0c      	ldr	r4, [pc, #48]	; (203838 <motor4+0x38>)
  203808:	2208      	movs	r2, #8
		sConfigOC.Pulse = m4a;
  20380a:	6068      	str	r0, [r5, #4]
		HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_3);
  20380c:	4629      	mov	r1, r5
  20380e:	4620      	mov	r0, r4
  203810:	f7ff f83e 	bl	202890 <HAL_TIM_PWM_ConfigChannel>
		HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_3);
  203814:	2108      	movs	r1, #8
  203816:	4620      	mov	r0, r4
  203818:	f7fe ff64 	bl	2026e4 <HAL_TIM_PWM_Start>
		HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_4);
  20381c:	4629      	mov	r1, r5
  20381e:	4620      	mov	r0, r4
  203820:	220c      	movs	r2, #12
		sConfigOC.Pulse = m4b;
  203822:	606e      	str	r6, [r5, #4]
		HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_4);
  203824:	f7ff f834 	bl	202890 <HAL_TIM_PWM_ConfigChannel>
		HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_4);
  203828:	4620      	mov	r0, r4
  20382a:	210c      	movs	r1, #12
}
  20382c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_4);
  203830:	f7fe bf58 	b.w	2026e4 <HAL_TIM_PWM_Start>
  203834:	20000060 	.word	0x20000060
  203838:	20000458 	.word	0x20000458

0020383c <beep>:
	}

void beep(uint8_t time,uint16_t on_time,uint16_t off_time){
  20383c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  203840:	4606      	mov	r6, r0
  203842:	460f      	mov	r7, r1
  203844:	4690      	mov	r8, r2
	for(uint8_t fortime=0;fortime<time;fortime++){
  203846:	2400      	movs	r4, #0
	  	HAL_GPIO_WritePin(GPIOE,GPIO_PIN_2,1);
  203848:	4d0b      	ldr	r5, [pc, #44]	; (203878 <beep+0x3c>)
	for(uint8_t fortime=0;fortime<time;fortime++){
  20384a:	42b4      	cmp	r4, r6
  20384c:	d101      	bne.n	203852 <beep+0x16>
		HAL_Delay(on_time);
	  	HAL_GPIO_WritePin(GPIOE,GPIO_PIN_2,0);
		HAL_Delay(off_time);
	}
}
  20384e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	  	HAL_GPIO_WritePin(GPIOE,GPIO_PIN_2,1);
  203852:	2201      	movs	r2, #1
  203854:	2104      	movs	r1, #4
  203856:	4628      	mov	r0, r5
  203858:	3401      	adds	r4, #1
  20385a:	f7fd fc41 	bl	2010e0 <HAL_GPIO_WritePin>
		HAL_Delay(on_time);
  20385e:	4638      	mov	r0, r7
  203860:	f7fd f920 	bl	200aa4 <HAL_Delay>
	  	HAL_GPIO_WritePin(GPIOE,GPIO_PIN_2,0);
  203864:	2200      	movs	r2, #0
  203866:	2104      	movs	r1, #4
  203868:	4628      	mov	r0, r5
  20386a:	f7fd fc39 	bl	2010e0 <HAL_GPIO_WritePin>
		HAL_Delay(off_time);
  20386e:	4640      	mov	r0, r8
  203870:	f7fd f918 	bl	200aa4 <HAL_Delay>
  203874:	e7e9      	b.n	20384a <beep+0xe>
  203876:	bf00      	nop
  203878:	40021000 	.word	0x40021000

0020387c <MX_DMA_Init>:
  * Enable DMA controller clock
  */
void MX_DMA_Init(void) 
{
  /* DMA controller clock enable */
  __HAL_RCC_DMA2_CLK_ENABLE();
  20387c:	4b0a      	ldr	r3, [pc, #40]	; (2038a8 <MX_DMA_Init+0x2c>)
{
  20387e:	b507      	push	{r0, r1, r2, lr}
  __HAL_RCC_DMA2_CLK_ENABLE();
  203880:	6b1a      	ldr	r2, [r3, #48]	; 0x30

  /* DMA interrupt init */
  /* DMA2_Stream2_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA2_Stream2_IRQn, 1, 0);
  203882:	2101      	movs	r1, #1
  203884:	203a      	movs	r0, #58	; 0x3a
  __HAL_RCC_DMA2_CLK_ENABLE();
  203886:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
  20388a:	631a      	str	r2, [r3, #48]	; 0x30
  HAL_NVIC_SetPriority(DMA2_Stream2_IRQn, 1, 0);
  20388c:	2200      	movs	r2, #0
  __HAL_RCC_DMA2_CLK_ENABLE();
  20388e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  203890:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
  203894:	9301      	str	r3, [sp, #4]
  203896:	9b01      	ldr	r3, [sp, #4]
  HAL_NVIC_SetPriority(DMA2_Stream2_IRQn, 1, 0);
  203898:	f7fd f924 	bl	200ae4 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA2_Stream2_IRQn);
  20389c:	203a      	movs	r0, #58	; 0x3a
  20389e:	f7fd f959 	bl	200b54 <HAL_NVIC_EnableIRQ>

}
  2038a2:	b003      	add	sp, #12
  2038a4:	f85d fb04 	ldr.w	pc, [sp], #4
  2038a8:	40023800 	.word	0x40023800

002038ac <MX_GPIO_Init>:
{

  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOE_CLK_ENABLE();
  2038ac:	4b52      	ldr	r3, [pc, #328]	; (2039f8 <MX_GPIO_Init+0x14c>)
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();
  __HAL_RCC_GPIOD_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOE, GPIO_PIN_2|GPIO_PIN_8|GPIO_PIN_10, GPIO_PIN_RESET);
  2038ae:	f240 5104 	movw	r1, #1284	; 0x504
  __HAL_RCC_GPIOE_CLK_ENABLE();
  2038b2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  2038b4:	f042 0210 	orr.w	r2, r2, #16
{
  2038b8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  __HAL_RCC_GPIOE_CLK_ENABLE();
  2038bc:	631a      	str	r2, [r3, #48]	; 0x30
{
  2038be:	b08d      	sub	sp, #52	; 0x34
  __HAL_RCC_GPIOE_CLK_ENABLE();
  2038c0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  HAL_GPIO_WritePin(GPIOD, GPIO_PIN_10, GPIO_PIN_RESET);

  /*Configure GPIO pins : PE2 PE8 PE10 */
  GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_8|GPIO_PIN_10;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  2038c2:	2400      	movs	r4, #0
  HAL_GPIO_WritePin(GPIOE, GPIO_PIN_2|GPIO_PIN_8|GPIO_PIN_10, GPIO_PIN_RESET);
  2038c4:	f8df 913c 	ldr.w	r9, [pc, #316]	; 203a04 <MX_GPIO_Init+0x158>
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  2038c8:	2501      	movs	r5, #1
  __HAL_RCC_GPIOE_CLK_ENABLE();
  2038ca:	f002 0210 	and.w	r2, r2, #16
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14|GPIO_PIN_15|GPIO_PIN_1|GPIO_PIN_4, GPIO_PIN_RESET);
  2038ce:	f8df 8138 	ldr.w	r8, [pc, #312]	; 203a08 <MX_GPIO_Init+0x15c>
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_2|GPIO_PIN_12, GPIO_PIN_RESET);
  2038d2:	4e4a      	ldr	r6, [pc, #296]	; (2039fc <MX_GPIO_Init+0x150>)
  HAL_GPIO_WritePin(GPIOE, GPIO_PIN_2|GPIO_PIN_8|GPIO_PIN_10, GPIO_PIN_RESET);
  2038d4:	4648      	mov	r0, r9
  __HAL_RCC_GPIOE_CLK_ENABLE();
  2038d6:	9201      	str	r2, [sp, #4]
  2038d8:	9a01      	ldr	r2, [sp, #4]
  __HAL_RCC_GPIOC_CLK_ENABLE();
  2038da:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  HAL_GPIO_WritePin(GPIOD, GPIO_PIN_10, GPIO_PIN_RESET);
  2038dc:	4f48      	ldr	r7, [pc, #288]	; (203a00 <MX_GPIO_Init+0x154>)
  __HAL_RCC_GPIOC_CLK_ENABLE();
  2038de:	f042 0204 	orr.w	r2, r2, #4
  2038e2:	631a      	str	r2, [r3, #48]	; 0x30
  2038e4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  2038e6:	f002 0204 	and.w	r2, r2, #4
  2038ea:	9202      	str	r2, [sp, #8]
  2038ec:	9a02      	ldr	r2, [sp, #8]
  __HAL_RCC_GPIOH_CLK_ENABLE();
  2038ee:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  2038f0:	f042 0280 	orr.w	r2, r2, #128	; 0x80
  2038f4:	631a      	str	r2, [r3, #48]	; 0x30
  2038f6:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  2038f8:	f002 0280 	and.w	r2, r2, #128	; 0x80
  2038fc:	9203      	str	r2, [sp, #12]
  2038fe:	9a03      	ldr	r2, [sp, #12]
  __HAL_RCC_GPIOA_CLK_ENABLE();
  203900:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  203902:	f042 0201 	orr.w	r2, r2, #1
  203906:	631a      	str	r2, [r3, #48]	; 0x30
  203908:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  20390a:	f002 0201 	and.w	r2, r2, #1
  20390e:	9204      	str	r2, [sp, #16]
  203910:	9a04      	ldr	r2, [sp, #16]
  __HAL_RCC_GPIOB_CLK_ENABLE();
  203912:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  203914:	f042 0202 	orr.w	r2, r2, #2
  203918:	631a      	str	r2, [r3, #48]	; 0x30
  20391a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  20391c:	f002 0202 	and.w	r2, r2, #2
  203920:	9205      	str	r2, [sp, #20]
  203922:	9a05      	ldr	r2, [sp, #20]
  __HAL_RCC_GPIOD_CLK_ENABLE();
  203924:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  203926:	f042 0208 	orr.w	r2, r2, #8
  20392a:	631a      	str	r2, [r3, #48]	; 0x30
  HAL_GPIO_WritePin(GPIOE, GPIO_PIN_2|GPIO_PIN_8|GPIO_PIN_10, GPIO_PIN_RESET);
  20392c:	2200      	movs	r2, #0
  __HAL_RCC_GPIOD_CLK_ENABLE();
  20392e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  203930:	f003 0308 	and.w	r3, r3, #8
  203934:	9306      	str	r3, [sp, #24]
  203936:	9b06      	ldr	r3, [sp, #24]
  HAL_GPIO_WritePin(GPIOE, GPIO_PIN_2|GPIO_PIN_8|GPIO_PIN_10, GPIO_PIN_RESET);
  203938:	f7fd fbd2 	bl	2010e0 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14|GPIO_PIN_15|GPIO_PIN_1|GPIO_PIN_4, GPIO_PIN_RESET);
  20393c:	4640      	mov	r0, r8
  20393e:	2200      	movs	r2, #0
  203940:	f24c 0112 	movw	r1, #49170	; 0xc012
  203944:	f7fd fbcc 	bl	2010e0 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_2|GPIO_PIN_12, GPIO_PIN_RESET);
  203948:	4630      	mov	r0, r6
  20394a:	2200      	movs	r2, #0
  20394c:	f241 0104 	movw	r1, #4100	; 0x1004
  203950:	f7fd fbc6 	bl	2010e0 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(GPIOD, GPIO_PIN_10, GPIO_PIN_RESET);
  203954:	2200      	movs	r2, #0
  203956:	4638      	mov	r0, r7
  203958:	f44f 6180 	mov.w	r1, #1024	; 0x400
  20395c:	f7fd fbc0 	bl	2010e0 <HAL_GPIO_WritePin>
  GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_8|GPIO_PIN_10;
  203960:	f240 5304 	movw	r3, #1284	; 0x504
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
  203964:	a907      	add	r1, sp, #28
  203966:	4648      	mov	r0, r9
  GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_8|GPIO_PIN_10;
  203968:	9307      	str	r3, [sp, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  20396a:	9508      	str	r5, [sp, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  20396c:	9409      	str	r4, [sp, #36]	; 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  20396e:	940a      	str	r4, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
  203970:	f7fd fac6 	bl	200f00 <HAL_GPIO_Init>

  /*Configure GPIO pins : PE3 PE0 PE1 */
  GPIO_InitStruct.Pin = GPIO_PIN_3|GPIO_PIN_0|GPIO_PIN_1;
  203974:	230b      	movs	r3, #11
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
  203976:	a907      	add	r1, sp, #28
  203978:	4648      	mov	r0, r9
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  20397a:	9408      	str	r4, [sp, #32]
  GPIO_InitStruct.Pin = GPIO_PIN_3|GPIO_PIN_0|GPIO_PIN_1;
  20397c:	9307      	str	r3, [sp, #28]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  20397e:	9409      	str	r4, [sp, #36]	; 0x24
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
  203980:	f7fd fabe 	bl	200f00 <HAL_GPIO_Init>

  /*Configure GPIO pins : PC14 PC15 PC1 PC4 */
  GPIO_InitStruct.Pin = GPIO_PIN_14|GPIO_PIN_15|GPIO_PIN_1|GPIO_PIN_4;
  203984:	f24c 0312 	movw	r3, #49170	; 0xc012
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
  203988:	a907      	add	r1, sp, #28
  20398a:	4640      	mov	r0, r8
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  20398c:	9508      	str	r5, [sp, #32]
  GPIO_InitStruct.Pin = GPIO_PIN_14|GPIO_PIN_15|GPIO_PIN_1|GPIO_PIN_4;
  20398e:	9307      	str	r3, [sp, #28]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  203990:	9409      	str	r4, [sp, #36]	; 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  203992:	940a      	str	r4, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
  203994:	f7fd fab4 	bl	200f00 <HAL_GPIO_Init>

  /*Configure GPIO pins : PB2 PB12 */
  GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_12;
  203998:	f241 0304 	movw	r3, #4100	; 0x1004
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
  20399c:	a907      	add	r1, sp, #28
  20399e:	4630      	mov	r0, r6
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  2039a0:	9508      	str	r5, [sp, #32]
  GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_12;
  2039a2:	9307      	str	r3, [sp, #28]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  2039a4:	9409      	str	r4, [sp, #36]	; 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  2039a6:	940a      	str	r4, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
  2039a8:	f7fd faaa 	bl	200f00 <HAL_GPIO_Init>

  /*Configure GPIO pin : PD10 */
  GPIO_InitStruct.Pin = GPIO_PIN_10;
  2039ac:	f44f 6380 	mov.w	r3, #1024	; 0x400
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
  2039b0:	a907      	add	r1, sp, #28
  2039b2:	4638      	mov	r0, r7
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  2039b4:	9508      	str	r5, [sp, #32]
  GPIO_InitStruct.Pin = GPIO_PIN_10;
  2039b6:	9307      	str	r3, [sp, #28]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  2039b8:	9409      	str	r4, [sp, #36]	; 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  2039ba:	940a      	str	r4, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
  2039bc:	f7fd faa0 	bl	200f00 <HAL_GPIO_Init>

  /*Configure GPIO pins : PC10 PC12 */
  GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_12;
  2039c0:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
  2039c4:	a907      	add	r1, sp, #28
  2039c6:	4640      	mov	r0, r8
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  2039c8:	9408      	str	r4, [sp, #32]
  GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_12;
  2039ca:	9307      	str	r3, [sp, #28]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  2039cc:	9409      	str	r4, [sp, #36]	; 0x24
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
  2039ce:	f7fd fa97 	bl	200f00 <HAL_GPIO_Init>

  /*Configure GPIO pins : PD1 PD3 PD7 */
  GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_3|GPIO_PIN_7;
  2039d2:	238a      	movs	r3, #138	; 0x8a
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
  2039d4:	a907      	add	r1, sp, #28
  2039d6:	4638      	mov	r0, r7
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  2039d8:	9408      	str	r4, [sp, #32]
  GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_3|GPIO_PIN_7;
  2039da:	9307      	str	r3, [sp, #28]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  2039dc:	9409      	str	r4, [sp, #36]	; 0x24
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
  2039de:	f7fd fa8f 	bl	200f00 <HAL_GPIO_Init>

  /*Configure GPIO pins : PB4 PB5 */
  GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_5;
  2039e2:	2330      	movs	r3, #48	; 0x30
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
  2039e4:	a907      	add	r1, sp, #28
  2039e6:	4630      	mov	r0, r6
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  2039e8:	9408      	str	r4, [sp, #32]
  GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_5;
  2039ea:	9307      	str	r3, [sp, #28]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  2039ec:	9409      	str	r4, [sp, #36]	; 0x24
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
  2039ee:	f7fd fa87 	bl	200f00 <HAL_GPIO_Init>

}
  2039f2:	b00d      	add	sp, #52	; 0x34
  2039f4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  2039f8:	40023800 	.word	0x40023800
  2039fc:	40020400 	.word	0x40020400
  203a00:	40020c00 	.word	0x40020c00
  203a04:	40021000 	.word	0x40021000
  203a08:	40020800 	.word	0x40020800

00203a0c <MX_I2C1_Init>:
I2C_HandleTypeDef hi2c1;
I2C_HandleTypeDef hi2c2;

/* I2C1 init function */
void MX_I2C1_Init(void)
{
  203a0c:	b508      	push	{r3, lr}

  hi2c1.Instance = I2C1;
  203a0e:	4817      	ldr	r0, [pc, #92]	; (203a6c <MX_I2C1_Init+0x60>)
  hi2c1.Init.Timing = 0x40D32A31;
  hi2c1.Init.OwnAddress1 = 0;
  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
  203a10:	2201      	movs	r2, #1
  hi2c1.Instance = I2C1;
  203a12:	4b17      	ldr	r3, [pc, #92]	; (203a70 <MX_I2C1_Init+0x64>)
  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
  203a14:	60c2      	str	r2, [r0, #12]
  hi2c1.Instance = I2C1;
  203a16:	6003      	str	r3, [r0, #0]
  hi2c1.Init.Timing = 0x40D32A31;
  203a18:	f503 0352 	add.w	r3, r3, #13762560	; 0xd20000
  203a1c:	f503 4356 	add.w	r3, r3, #54784	; 0xd600
  203a20:	3331      	adds	r3, #49	; 0x31
  203a22:	6043      	str	r3, [r0, #4]
  hi2c1.Init.OwnAddress1 = 0;
  203a24:	2300      	movs	r3, #0
  203a26:	6083      	str	r3, [r0, #8]
  hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  203a28:	6103      	str	r3, [r0, #16]
  hi2c1.Init.OwnAddress2 = 0;
  203a2a:	6143      	str	r3, [r0, #20]
  hi2c1.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
  203a2c:	6183      	str	r3, [r0, #24]
  hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  203a2e:	61c3      	str	r3, [r0, #28]
  hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
  203a30:	6203      	str	r3, [r0, #32]
  if (HAL_I2C_Init(&hi2c1) != HAL_OK)
  203a32:	f7fd fc68 	bl	201306 <HAL_I2C_Init>
  203a36:	b118      	cbz	r0, 203a40 <MX_I2C1_Init+0x34>
  {
    _Error_Handler(__FILE__, __LINE__);
  203a38:	2143      	movs	r1, #67	; 0x43
  203a3a:	480e      	ldr	r0, [pc, #56]	; (203a74 <MX_I2C1_Init+0x68>)
  203a3c:	f001 fa64 	bl	204f08 <_Error_Handler>
  }

    /**Configure Analogue filter 
    */
  if (HAL_I2CEx_ConfigAnalogFilter(&hi2c1, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
  203a40:	2100      	movs	r1, #0
  203a42:	480a      	ldr	r0, [pc, #40]	; (203a6c <MX_I2C1_Init+0x60>)
  203a44:	f7fd fe0e 	bl	201664 <HAL_I2CEx_ConfigAnalogFilter>
  203a48:	b118      	cbz	r0, 203a52 <MX_I2C1_Init+0x46>
  {
    _Error_Handler(__FILE__, __LINE__);
  203a4a:	214a      	movs	r1, #74	; 0x4a
  203a4c:	4809      	ldr	r0, [pc, #36]	; (203a74 <MX_I2C1_Init+0x68>)
  203a4e:	f001 fa5b 	bl	204f08 <_Error_Handler>
  }

    /**Configure Digital filter 
    */
  if (HAL_I2CEx_ConfigDigitalFilter(&hi2c1, 0) != HAL_OK)
  203a52:	2100      	movs	r1, #0
  203a54:	4805      	ldr	r0, [pc, #20]	; (203a6c <MX_I2C1_Init+0x60>)
  203a56:	f7fd fe2b 	bl	2016b0 <HAL_I2CEx_ConfigDigitalFilter>
  203a5a:	b128      	cbz	r0, 203a68 <MX_I2C1_Init+0x5c>
  {
    _Error_Handler(__FILE__, __LINE__);
  203a5c:	2151      	movs	r1, #81	; 0x51
  203a5e:	4805      	ldr	r0, [pc, #20]	; (203a74 <MX_I2C1_Init+0x68>)
  }

}
  203a60:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    _Error_Handler(__FILE__, __LINE__);
  203a64:	f001 ba50 	b.w	204f08 <_Error_Handler>
  203a68:	bd08      	pop	{r3, pc}
  203a6a:	bf00      	nop
  203a6c:	200000cc 	.word	0x200000cc
  203a70:	40005400 	.word	0x40005400
  203a74:	002074c5 	.word	0x002074c5

00203a78 <MX_I2C2_Init>:
/* I2C2 init function */
void MX_I2C2_Init(void)
{
  203a78:	b508      	push	{r3, lr}

  hi2c2.Instance = I2C2;
  203a7a:	4817      	ldr	r0, [pc, #92]	; (203ad8 <MX_I2C2_Init+0x60>)
  hi2c2.Init.Timing = 0x40D32A31;
  hi2c2.Init.OwnAddress1 = 0;
  hi2c2.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
  203a7c:	2201      	movs	r2, #1
  hi2c2.Instance = I2C2;
  203a7e:	4b17      	ldr	r3, [pc, #92]	; (203adc <MX_I2C2_Init+0x64>)
  hi2c2.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
  203a80:	60c2      	str	r2, [r0, #12]
  hi2c2.Instance = I2C2;
  203a82:	6003      	str	r3, [r0, #0]
  hi2c2.Init.Timing = 0x40D32A31;
  203a84:	f503 0352 	add.w	r3, r3, #13762560	; 0xd20000
  203a88:	f503 4352 	add.w	r3, r3, #53760	; 0xd200
  203a8c:	3331      	adds	r3, #49	; 0x31
  203a8e:	6043      	str	r3, [r0, #4]
  hi2c2.Init.OwnAddress1 = 0;
  203a90:	2300      	movs	r3, #0
  203a92:	6083      	str	r3, [r0, #8]
  hi2c2.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  203a94:	6103      	str	r3, [r0, #16]
  hi2c2.Init.OwnAddress2 = 0;
  203a96:	6143      	str	r3, [r0, #20]
  hi2c2.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
  203a98:	6183      	str	r3, [r0, #24]
  hi2c2.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  203a9a:	61c3      	str	r3, [r0, #28]
  hi2c2.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
  203a9c:	6203      	str	r3, [r0, #32]
  if (HAL_I2C_Init(&hi2c2) != HAL_OK)
  203a9e:	f7fd fc32 	bl	201306 <HAL_I2C_Init>
  203aa2:	b118      	cbz	r0, 203aac <MX_I2C2_Init+0x34>
  {
    _Error_Handler(__FILE__, __LINE__);
  203aa4:	2164      	movs	r1, #100	; 0x64
  203aa6:	480e      	ldr	r0, [pc, #56]	; (203ae0 <MX_I2C2_Init+0x68>)
  203aa8:	f001 fa2e 	bl	204f08 <_Error_Handler>
  }

    /**Configure Analogue filter 
    */
  if (HAL_I2CEx_ConfigAnalogFilter(&hi2c2, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
  203aac:	2100      	movs	r1, #0
  203aae:	480a      	ldr	r0, [pc, #40]	; (203ad8 <MX_I2C2_Init+0x60>)
  203ab0:	f7fd fdd8 	bl	201664 <HAL_I2CEx_ConfigAnalogFilter>
  203ab4:	b118      	cbz	r0, 203abe <MX_I2C2_Init+0x46>
  {
    _Error_Handler(__FILE__, __LINE__);
  203ab6:	216b      	movs	r1, #107	; 0x6b
  203ab8:	4809      	ldr	r0, [pc, #36]	; (203ae0 <MX_I2C2_Init+0x68>)
  203aba:	f001 fa25 	bl	204f08 <_Error_Handler>
  }

    /**Configure Digital filter 
    */
  if (HAL_I2CEx_ConfigDigitalFilter(&hi2c2, 0) != HAL_OK)
  203abe:	2100      	movs	r1, #0
  203ac0:	4805      	ldr	r0, [pc, #20]	; (203ad8 <MX_I2C2_Init+0x60>)
  203ac2:	f7fd fdf5 	bl	2016b0 <HAL_I2CEx_ConfigDigitalFilter>
  203ac6:	b128      	cbz	r0, 203ad4 <MX_I2C2_Init+0x5c>
  {
    _Error_Handler(__FILE__, __LINE__);
  203ac8:	2172      	movs	r1, #114	; 0x72
  203aca:	4805      	ldr	r0, [pc, #20]	; (203ae0 <MX_I2C2_Init+0x68>)
  }

}
  203acc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    _Error_Handler(__FILE__, __LINE__);
  203ad0:	f001 ba1a 	b.w	204f08 <_Error_Handler>
  203ad4:	bd08      	pop	{r3, pc}
  203ad6:	bf00      	nop
  203ad8:	20000118 	.word	0x20000118
  203adc:	40005800 	.word	0x40005800
  203ae0:	002074c5 	.word	0x002074c5

00203ae4 <HAL_I2C_MspInit>:

void HAL_I2C_MspInit(I2C_HandleTypeDef* i2cHandle)
{

  GPIO_InitTypeDef GPIO_InitStruct;
  if(i2cHandle->Instance==I2C1)
  203ae4:	6803      	ldr	r3, [r0, #0]
  203ae6:	4a22      	ldr	r2, [pc, #136]	; (203b70 <HAL_I2C_MspInit+0x8c>)
  203ae8:	4293      	cmp	r3, r2
{
  203aea:	b510      	push	{r4, lr}
  203aec:	b088      	sub	sp, #32
  if(i2cHandle->Instance==I2C1)
  203aee:	d119      	bne.n	203b24 <HAL_I2C_MspInit+0x40>
  
    /**I2C1 GPIO Configuration    
    PB6     ------> I2C1_SCL
    PB7     ------> I2C1_SDA 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7;
  203af0:	23c0      	movs	r3, #192	; 0xc0
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C1;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
  203af2:	a903      	add	r1, sp, #12
  203af4:	481f      	ldr	r0, [pc, #124]	; (203b74 <HAL_I2C_MspInit+0x90>)
    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7;
  203af6:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
  203af8:	2312      	movs	r3, #18
  203afa:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
  203afc:	2301      	movs	r3, #1
  203afe:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  203b00:	2303      	movs	r3, #3
  203b02:	9306      	str	r3, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C1;
  203b04:	2304      	movs	r3, #4
  203b06:	9307      	str	r3, [sp, #28]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
  203b08:	f7fd f9fa 	bl	200f00 <HAL_GPIO_Init>

    /* I2C1 clock enable */
    __HAL_RCC_I2C1_CLK_ENABLE();
  203b0c:	4b1a      	ldr	r3, [pc, #104]	; (203b78 <HAL_I2C_MspInit+0x94>)
  203b0e:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  203b10:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
  203b14:	641a      	str	r2, [r3, #64]	; 0x40
  203b16:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  203b18:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
  203b1c:	9301      	str	r3, [sp, #4]
  203b1e:	9b01      	ldr	r3, [sp, #4]
    HAL_NVIC_EnableIRQ(I2C2_EV_IRQn);
  /* USER CODE BEGIN I2C2_MspInit 1 */

  /* USER CODE END I2C2_MspInit 1 */
  }
}
  203b20:	b008      	add	sp, #32
  203b22:	bd10      	pop	{r4, pc}
  else if(i2cHandle->Instance==I2C2)
  203b24:	4a15      	ldr	r2, [pc, #84]	; (203b7c <HAL_I2C_MspInit+0x98>)
  203b26:	4293      	cmp	r3, r2
  203b28:	d1fa      	bne.n	203b20 <HAL_I2C_MspInit+0x3c>
    GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_11;
  203b2a:	f44f 6340 	mov.w	r3, #3072	; 0xc00
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  203b2e:	2403      	movs	r4, #3
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
  203b30:	a903      	add	r1, sp, #12
  203b32:	4810      	ldr	r0, [pc, #64]	; (203b74 <HAL_I2C_MspInit+0x90>)
    GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_11;
  203b34:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
  203b36:	2312      	movs	r3, #18
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  203b38:	9406      	str	r4, [sp, #24]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
  203b3a:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
  203b3c:	2301      	movs	r3, #1
  203b3e:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C2;
  203b40:	2304      	movs	r3, #4
  203b42:	9307      	str	r3, [sp, #28]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
  203b44:	f7fd f9dc 	bl	200f00 <HAL_GPIO_Init>
    __HAL_RCC_I2C2_CLK_ENABLE();
  203b48:	4b0b      	ldr	r3, [pc, #44]	; (203b78 <HAL_I2C_MspInit+0x94>)
    HAL_NVIC_SetPriority(I2C2_EV_IRQn, 3, 0);
  203b4a:	4621      	mov	r1, r4
  203b4c:	2021      	movs	r0, #33	; 0x21
    __HAL_RCC_I2C2_CLK_ENABLE();
  203b4e:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  203b50:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
  203b54:	641a      	str	r2, [r3, #64]	; 0x40
    HAL_NVIC_SetPriority(I2C2_EV_IRQn, 3, 0);
  203b56:	2200      	movs	r2, #0
    __HAL_RCC_I2C2_CLK_ENABLE();
  203b58:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  203b5a:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
  203b5e:	9302      	str	r3, [sp, #8]
  203b60:	9b02      	ldr	r3, [sp, #8]
    HAL_NVIC_SetPriority(I2C2_EV_IRQn, 3, 0);
  203b62:	f7fc ffbf 	bl	200ae4 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(I2C2_EV_IRQn);
  203b66:	2021      	movs	r0, #33	; 0x21
  203b68:	f7fc fff4 	bl	200b54 <HAL_NVIC_EnableIRQ>
}
  203b6c:	e7d8      	b.n	203b20 <HAL_I2C_MspInit+0x3c>
  203b6e:	bf00      	nop
  203b70:	40005400 	.word	0x40005400
  203b74:	40020400 	.word	0x40020400
  203b78:	40023800 	.word	0x40023800
  203b7c:	40005800 	.word	0x40005800

00203b80 <oled_puts>:
	command[0]=0x40;
	command[1]=t_data;
	HAL_I2C_Master_Transmit(oled_I2C,I2C_ADDRESS,(uint8_t*)command,2,200);
}

void oled_puts(char *strings){
  203b80:	b530      	push	{r4, r5, lr}
  203b82:	b089      	sub	sp, #36	; 0x24
  203b84:	4604      	mov	r4, r0
	uint8_t stringsbuf[17] = {0};
  203b86:	2211      	movs	r2, #17
  203b88:	2100      	movs	r1, #0
  203b8a:	ad03      	add	r5, sp, #12
  203b8c:	4628      	mov	r0, r5
  203b8e:	f003 fc79 	bl	207484 <memset>
	int 	count = 1;
	stringsbuf[0] = 0x40;
  203b92:	2340      	movs	r3, #64	; 0x40
  203b94:	1e60      	subs	r0, r4, #1
  203b96:	f88d 300c 	strb.w	r3, [sp, #12]
	int 	count = 1;
  203b9a:	2301      	movs	r3, #1
	while(*strings){
  203b9c:	f810 2f01 	ldrb.w	r2, [r0, #1]!
  203ba0:	b952      	cbnz	r2, 203bb8 <oled_puts+0x38>
		stringsbuf[count] = (uint8_t)*strings++;
		count++;
	}
	HAL_I2C_Master_Transmit(oled_I2C,I2C_ADDRESS,(uint8_t*)stringsbuf,count,200);
  203ba2:	22c8      	movs	r2, #200	; 0xc8
  203ba4:	4806      	ldr	r0, [pc, #24]	; (203bc0 <oled_puts+0x40>)
  203ba6:	b29b      	uxth	r3, r3
  203ba8:	2178      	movs	r1, #120	; 0x78
  203baa:	9200      	str	r2, [sp, #0]
  203bac:	462a      	mov	r2, r5
  203bae:	6800      	ldr	r0, [r0, #0]
  203bb0:	f7fd fbfa 	bl	2013a8 <HAL_I2C_Master_Transmit>
}
  203bb4:	b009      	add	sp, #36	; 0x24
  203bb6:	bd30      	pop	{r4, r5, pc}
		stringsbuf[count] = (uint8_t)*strings++;
  203bb8:	54ea      	strb	r2, [r5, r3]
		count++;
  203bba:	3301      	adds	r3, #1
  203bbc:	e7ee      	b.n	203b9c <oled_puts+0x1c>
  203bbe:	bf00      	nop
  203bc0:	20000164 	.word	0x20000164

00203bc4 <oled_writeCommand>:

void oled_writeCommand(char t_command){
  203bc4:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	uint8_t command[2];
	command[0]=0x00;
  203bc6:	2300      	movs	r3, #0
	command[1]=t_command;
  203bc8:	f88d 000d 	strb.w	r0, [sp, #13]
	HAL_I2C_Master_Transmit(oled_I2C,I2C_ADDRESS,(uint8_t*)command,2,0xF);
  203bcc:	4806      	ldr	r0, [pc, #24]	; (203be8 <oled_writeCommand+0x24>)
  203bce:	aa03      	add	r2, sp, #12
	command[0]=0x00;
  203bd0:	f88d 300c 	strb.w	r3, [sp, #12]
	HAL_I2C_Master_Transmit(oled_I2C,I2C_ADDRESS,(uint8_t*)command,2,0xF);
  203bd4:	230f      	movs	r3, #15
  203bd6:	2178      	movs	r1, #120	; 0x78
  203bd8:	9300      	str	r3, [sp, #0]
  203bda:	2302      	movs	r3, #2
  203bdc:	6800      	ldr	r0, [r0, #0]
  203bde:	f7fd fbe3 	bl	2013a8 <HAL_I2C_Master_Transmit>
}
  203be2:	b005      	add	sp, #20
  203be4:	f85d fb04 	ldr.w	pc, [sp], #4
  203be8:	20000164 	.word	0x20000164

00203bec <oled_contrast>:
	}
}



void oled_contrast(int contrast){
  203bec:	b510      	push	{r4, lr}
  203bee:	4604      	mov	r4, r0
	oled_writeCommand(0x2A);//RE=1
  203bf0:	202a      	movs	r0, #42	; 0x2a
  203bf2:	f7ff ffe7 	bl	203bc4 <oled_writeCommand>
	oled_writeCommand(EnableSD);//SD=1
  203bf6:	2079      	movs	r0, #121	; 0x79
  203bf8:	f7ff ffe4 	bl	203bc4 <oled_writeCommand>
	oled_writeCommand(0x81);//RgXgZbg
  203bfc:	2081      	movs	r0, #129	; 0x81
  203bfe:	f7ff ffe1 	bl	203bc4 <oled_writeCommand>
	oled_writeCommand(contrast);//PxMAX(0x00~0xFF)
  203c02:	b2e0      	uxtb	r0, r4
  203c04:	f7ff ffde 	bl	203bc4 <oled_writeCommand>
	oled_writeCommand(DisableSD);//SD0
  203c08:	2078      	movs	r0, #120	; 0x78
  203c0a:	f7ff ffdb 	bl	203bc4 <oled_writeCommand>
	oled_writeCommand(0x28);//2C= 28=m[}
  203c0e:	2028      	movs	r0, #40	; 0x28
  203c10:	f7ff ffd8 	bl	203bc4 <oled_writeCommand>
	HAL_Delay(100);
  203c14:	2064      	movs	r0, #100	; 0x64
}
  203c16:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	HAL_Delay(100);
  203c1a:	f7fc bf43 	b.w	200aa4 <HAL_Delay>

00203c1e <oled_clear>:
	oled_power(true);
	oled_clear();
}

void oled_clear(){
	oled_writeCommand(ClearDisplay);
  203c1e:	2001      	movs	r0, #1
  203c20:	f7ff bfd0 	b.w	203bc4 <oled_writeCommand>

00203c24 <oled_setcursor>:
  * @param  column	0~1
  * @param  row		0~15
  * @retval none
  */
void oled_setcursor(int column,int row){
	if(column==0 && row<16){
  203c24:	b930      	cbnz	r0, 203c34 <oled_setcursor+0x10>
  203c26:	290f      	cmp	r1, #15
  203c28:	dc0b      	bgt.n	203c42 <oled_setcursor+0x1e>
		oled_writeCommand(0x80+row);
  203c2a:	f1a1 0080 	sub.w	r0, r1, #128	; 0x80
	}
	else if(column==1 && row<16){
		oled_writeCommand(0xA0+row);
  203c2e:	b2c0      	uxtb	r0, r0
	}
	else{
		oled_writeCommand(0x80);
  203c30:	f7ff bfc8 	b.w	203bc4 <oled_writeCommand>
	else if(column==1 && row<16){
  203c34:	2801      	cmp	r0, #1
  203c36:	d104      	bne.n	203c42 <oled_setcursor+0x1e>
  203c38:	290f      	cmp	r1, #15
  203c3a:	dc02      	bgt.n	203c42 <oled_setcursor+0x1e>
		oled_writeCommand(0xA0+row);
  203c3c:	f1a1 0060 	sub.w	r0, r1, #96	; 0x60
  203c40:	e7f5      	b.n	203c2e <oled_setcursor+0xa>
		oled_writeCommand(0x80);
  203c42:	2080      	movs	r0, #128	; 0x80
  203c44:	e7f4      	b.n	203c30 <oled_setcursor+0xc>

00203c46 <oled_returnhome>:
	}
}

void oled_returnhome(){
	oled_writeCommand(ReturnHome);
  203c46:	2002      	movs	r0, #2
  203c48:	f7ff bfbc 	b.w	203bc4 <oled_writeCommand>

00203c4c <oled_init>:
void oled_init(){
  203c4c:	b508      	push	{r3, lr}
	oled_returnhome();
  203c4e:	f7ff fffa 	bl	203c46 <oled_returnhome>
		oled_writeCommand(DisplayON);
  203c52:	200f      	movs	r0, #15
  203c54:	f7ff ffb6 	bl	203bc4 <oled_writeCommand>
		HAL_Delay(10);
  203c58:	200a      	movs	r0, #10
  203c5a:	f7fc ff23 	bl	200aa4 <HAL_Delay>
}
  203c5e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	oled_clear();
  203c62:	f7ff bfdc 	b.w	203c1e <oled_clear>
	...

00203c68 <oled_i2c_to_oled>:
void oled_i2c_to_oled(I2C_HandleTypeDef *handler){
  203c68:	b508      	push	{r3, lr}
	 oled_I2C = handler;
  203c6a:	4b08      	ldr	r3, [pc, #32]	; (203c8c <oled_i2c_to_oled+0x24>)
  203c6c:	6018      	str	r0, [r3, #0]
	 oled_init();
  203c6e:	f7ff ffed 	bl	203c4c <oled_init>
	 oled_contrast(0xFF);
  203c72:	20ff      	movs	r0, #255	; 0xff
  203c74:	f7ff ffba 	bl	203bec <oled_contrast>
	 oled_clear();
  203c78:	f7ff ffd1 	bl	203c1e <oled_clear>
	oled_writeCommand(command[0]);
  203c7c:	200c      	movs	r0, #12
  203c7e:	f7ff ffa1 	bl	203bc4 <oled_writeCommand>
	HAL_Delay(10);
  203c82:	200a      	movs	r0, #10
}
  203c84:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	HAL_Delay(10);
  203c88:	f7fc bf0c 	b.w	200aa4 <HAL_Delay>
  203c8c:	20000164 	.word	0x20000164

00203c90 <MX_IWDG_Init>:

IWDG_HandleTypeDef hiwdg;

/* IWDG init function */
void MX_IWDG_Init(void)
{
  203c90:	b508      	push	{r3, lr}

  hiwdg.Instance = IWDG;
  203c92:	4809      	ldr	r0, [pc, #36]	; (203cb8 <MX_IWDG_Init+0x28>)
  hiwdg.Init.Prescaler = IWDG_PRESCALER_32;
  203c94:	2303      	movs	r3, #3
  203c96:	4a09      	ldr	r2, [pc, #36]	; (203cbc <MX_IWDG_Init+0x2c>)
  203c98:	e880 000c 	stmia.w	r0, {r2, r3}
  hiwdg.Init.Window = 4095;
  203c9c:	f640 73ff 	movw	r3, #4095	; 0xfff
  203ca0:	60c3      	str	r3, [r0, #12]
  hiwdg.Init.Reload = 4095;
  203ca2:	6083      	str	r3, [r0, #8]
  if (HAL_IWDG_Init(&hiwdg) != HAL_OK)
  203ca4:	f7fd fd29 	bl	2016fa <HAL_IWDG_Init>
  203ca8:	b128      	cbz	r0, 203cb6 <MX_IWDG_Init+0x26>
  {
    _Error_Handler(__FILE__, __LINE__);
  203caa:	213b      	movs	r1, #59	; 0x3b
  203cac:	4804      	ldr	r0, [pc, #16]	; (203cc0 <MX_IWDG_Init+0x30>)
  }

}
  203cae:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    _Error_Handler(__FILE__, __LINE__);
  203cb2:	f001 b929 	b.w	204f08 <_Error_Handler>
  203cb6:	bd08      	pop	{r3, pc}
  203cb8:	20000168 	.word	0x20000168
  203cbc:	40003000 	.word	0x40003000
  203cc0:	002074d2 	.word	0x002074d2

00203cc4 <_Error_Handler.constprop.0>:
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  while(1) 
  {
	  HAL_GPIO_WritePin(GPIOB,GPIO_PIN_12,1);
  203cc4:	4c04      	ldr	r4, [pc, #16]	; (203cd8 <_Error_Handler.constprop.0+0x14>)
void _Error_Handler(char * file, int line)
  203cc6:	b508      	push	{r3, lr}
	  HAL_GPIO_WritePin(GPIOB,GPIO_PIN_12,1);
  203cc8:	2201      	movs	r2, #1
  203cca:	f44f 5180 	mov.w	r1, #4096	; 0x1000
  203cce:	4620      	mov	r0, r4
  203cd0:	f7fd fa06 	bl	2010e0 <HAL_GPIO_WritePin>
  203cd4:	e7f8      	b.n	203cc8 <_Error_Handler.constprop.0+0x4>
  203cd6:	bf00      	nop
  203cd8:	40020400 	.word	0x40020400

00203cdc <HAL_TIM_PeriodElapsedCallback>:
{
  203cdc:	b570      	push	{r4, r5, r6, lr}
	 if(Rxdetatemp!=data[Servonumber+8] || HAL_GPIO_ReadPin(GPIOE,GPIO_PIN_1)==0){
  203cde:	4d0f      	ldr	r5, [pc, #60]	; (203d1c <HAL_TIM_PeriodElapsedCallback+0x40>)
  203ce0:	4c0f      	ldr	r4, [pc, #60]	; (203d20 <HAL_TIM_PeriodElapsedCallback+0x44>)
  203ce2:	7b68      	ldrb	r0, [r5, #13]
  203ce4:	7821      	ldrb	r1, [r4, #0]
  203ce6:	4e0f      	ldr	r6, [pc, #60]	; (203d24 <HAL_TIM_PeriodElapsedCallback+0x48>)
  203ce8:	4288      	cmp	r0, r1
  203cea:	d009      	beq.n	203d00 <HAL_TIM_PeriodElapsedCallback+0x24>
		 TPIPConnect=1;
  203cec:	2201      	movs	r2, #1
		 HAL_GPIO_WritePin(GPIOE,GPIO_PIN_8,1);
  203cee:	f44f 7180 	mov.w	r1, #256	; 0x100
  203cf2:	480d      	ldr	r0, [pc, #52]	; (203d28 <HAL_TIM_PeriodElapsedCallback+0x4c>)
		 TPIPConnect=1;
  203cf4:	7032      	strb	r2, [r6, #0]
		 HAL_GPIO_WritePin(GPIOE,GPIO_PIN_8,1);
  203cf6:	f7fd f9f3 	bl	2010e0 <HAL_GPIO_WritePin>
	 Rxdetatemp=data[Servonumber+8];
  203cfa:	7b6b      	ldrb	r3, [r5, #13]
  203cfc:	7023      	strb	r3, [r4, #0]
  203cfe:	bd70      	pop	{r4, r5, r6, pc}
	 if(Rxdetatemp!=data[Servonumber+8] || HAL_GPIO_ReadPin(GPIOE,GPIO_PIN_1)==0){
  203d00:	2102      	movs	r1, #2
  203d02:	4809      	ldr	r0, [pc, #36]	; (203d28 <HAL_TIM_PeriodElapsedCallback+0x4c>)
  203d04:	f7fd f9e6 	bl	2010d4 <HAL_GPIO_ReadPin>
  203d08:	2800      	cmp	r0, #0
  203d0a:	d0ef      	beq.n	203cec <HAL_TIM_PeriodElapsedCallback+0x10>
		 TPIPConnect=0;
  203d0c:	2300      	movs	r3, #0
		 HAL_GPIO_TogglePin(GPIOE,GPIO_PIN_8);
  203d0e:	f44f 7180 	mov.w	r1, #256	; 0x100
  203d12:	4805      	ldr	r0, [pc, #20]	; (203d28 <HAL_TIM_PeriodElapsedCallback+0x4c>)
		 TPIPConnect=0;
  203d14:	7033      	strb	r3, [r6, #0]
		 HAL_GPIO_TogglePin(GPIOE,GPIO_PIN_8);
  203d16:	f7fd f9e8 	bl	2010ea <HAL_GPIO_TogglePin>
  203d1a:	e7ee      	b.n	203cfa <HAL_TIM_PeriodElapsedCallback+0x1e>
  203d1c:	200001ed 	.word	0x200001ed
  203d20:	2000003d 	.word	0x2000003d
  203d24:	2000003e 	.word	0x2000003e
  203d28:	40021000 	.word	0x40021000

00203d2c <SystemClock_Config>:
  __HAL_RCC_PWR_CLK_ENABLE();
  203d2c:	4b30      	ldr	r3, [pc, #192]	; (203df0 <SystemClock_Config+0xc4>)
  203d2e:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  203d30:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
{
  203d34:	b530      	push	{r4, r5, lr}
  __HAL_RCC_PWR_CLK_ENABLE();
  203d36:	641a      	str	r2, [r3, #64]	; 0x40
{
  203d38:	b0b5      	sub	sp, #212	; 0xd4
  __HAL_RCC_PWR_CLK_ENABLE();
  203d3a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  203d3c:	2402      	movs	r4, #2
  RCC_OscInitStruct.PLL.PLLM = 4;
  203d3e:	2504      	movs	r5, #4
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  203d40:	a807      	add	r0, sp, #28
  __HAL_RCC_PWR_CLK_ENABLE();
  203d42:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
  203d46:	9300      	str	r3, [sp, #0]
  203d48:	9b00      	ldr	r3, [sp, #0]
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
  203d4a:	4b2a      	ldr	r3, [pc, #168]	; (203df4 <SystemClock_Config+0xc8>)
  203d4c:	681a      	ldr	r2, [r3, #0]
  203d4e:	f442 4240 	orr.w	r2, r2, #49152	; 0xc000
  203d52:	601a      	str	r2, [r3, #0]
  203d54:	681b      	ldr	r3, [r3, #0]
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  203d56:	940d      	str	r4, [sp, #52]	; 0x34
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
  203d58:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
  RCC_OscInitStruct.PLL.PLLM = 4;
  203d5c:	950f      	str	r5, [sp, #60]	; 0x3c
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  203d5e:	9411      	str	r4, [sp, #68]	; 0x44
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
  203d60:	9301      	str	r3, [sp, #4]
  203d62:	9b01      	ldr	r3, [sp, #4]
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSI|RCC_OSCILLATORTYPE_HSE;
  203d64:	2309      	movs	r3, #9
  RCC_OscInitStruct.PLL.PLLQ = 2;
  203d66:	9412      	str	r4, [sp, #72]	; 0x48
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSI|RCC_OSCILLATORTYPE_HSE;
  203d68:	9307      	str	r3, [sp, #28]
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  203d6a:	f44f 3380 	mov.w	r3, #65536	; 0x10000
  203d6e:	9308      	str	r3, [sp, #32]
  RCC_OscInitStruct.LSIState = RCC_LSI_ON;
  203d70:	2301      	movs	r3, #1
  203d72:	930c      	str	r3, [sp, #48]	; 0x30
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  203d74:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
  203d78:	930e      	str	r3, [sp, #56]	; 0x38
  RCC_OscInitStruct.PLL.PLLN = 216;
  203d7a:	23d8      	movs	r3, #216	; 0xd8
  203d7c:	9310      	str	r3, [sp, #64]	; 0x40
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  203d7e:	f7fd fd21 	bl	2017c4 <HAL_RCC_OscConfig>
  203d82:	b108      	cbz	r0, 203d88 <SystemClock_Config+0x5c>
    _Error_Handler(__FILE__, __LINE__);
  203d84:	f7ff ff9e 	bl	203cc4 <_Error_Handler.constprop.0>
  if (HAL_PWREx_EnableOverDrive() != HAL_OK)
  203d88:	f7fd fce4 	bl	201754 <HAL_PWREx_EnableOverDrive>
  203d8c:	2800      	cmp	r0, #0
  203d8e:	d1f9      	bne.n	203d84 <SystemClock_Config+0x58>
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
  203d90:	230f      	movs	r3, #15
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  203d92:	9004      	str	r0, [sp, #16]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_7) != HAL_OK)
  203d94:	2107      	movs	r1, #7
  203d96:	a802      	add	r0, sp, #8
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
  203d98:	9302      	str	r3, [sp, #8]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
  203d9a:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  203d9e:	9403      	str	r4, [sp, #12]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
  203da0:	9305      	str	r3, [sp, #20]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
  203da2:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  203da6:	9306      	str	r3, [sp, #24]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_7) != HAL_OK)
  203da8:	f7fd feca 	bl	201b40 <HAL_RCC_ClockConfig>
  203dac:	2800      	cmp	r0, #0
  203dae:	d1e9      	bne.n	203d84 <SystemClock_Config+0x58>
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USART1|RCC_PERIPHCLK_USART2
  203db0:	f24c 03c0 	movw	r3, #49344	; 0xc0c0
  PeriphClkInitStruct.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK2;
  203db4:	9024      	str	r0, [sp, #144]	; 0x90
  PeriphClkInitStruct.Usart2ClockSelection = RCC_USART2CLKSOURCE_PCLK1;
  203db6:	9025      	str	r0, [sp, #148]	; 0x94
  PeriphClkInitStruct.I2c1ClockSelection = RCC_I2C1CLKSOURCE_PCLK1;
  203db8:	902c      	str	r0, [sp, #176]	; 0xb0
  PeriphClkInitStruct.I2c2ClockSelection = RCC_I2C2CLKSOURCE_PCLK1;
  203dba:	902d      	str	r0, [sp, #180]	; 0xb4
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
  203dbc:	a813      	add	r0, sp, #76	; 0x4c
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USART1|RCC_PERIPHCLK_USART2
  203dbe:	9313      	str	r3, [sp, #76]	; 0x4c
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
  203dc0:	f7fd ff74 	bl	201cac <HAL_RCCEx_PeriphCLKConfig>
  203dc4:	4604      	mov	r4, r0
  203dc6:	2800      	cmp	r0, #0
  203dc8:	d1dc      	bne.n	203d84 <SystemClock_Config+0x58>
  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
  203dca:	f7fd ff49 	bl	201c60 <HAL_RCC_GetHCLKFreq>
  203dce:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
  203dd2:	fbb0 f0f3 	udiv	r0, r0, r3
  203dd6:	f7fc fec9 	bl	200b6c <HAL_SYSTICK_Config>
  HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
  203dda:	4628      	mov	r0, r5
  203ddc:	f7fc fedc 	bl	200b98 <HAL_SYSTICK_CLKSourceConfig>
  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
  203de0:	4622      	mov	r2, r4
  203de2:	4621      	mov	r1, r4
  203de4:	f04f 30ff 	mov.w	r0, #4294967295
  203de8:	f7fc fe7c 	bl	200ae4 <HAL_NVIC_SetPriority>
}
  203dec:	b035      	add	sp, #212	; 0xd4
  203dee:	bd30      	pop	{r4, r5, pc}
  203df0:	40023800 	.word	0x40023800
  203df4:	40007000 	.word	0x40007000

00203df8 <main_run>:
	HOUI=JY901_yaw_get(HOUI_def);
  203df8:	4b43      	ldr	r3, [pc, #268]	; (203f08 <main_run+0x110>)
void main_run(){
  203dfa:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	motor_move(motor[0],motor[1],motor[2],motor[3],motor[4]);
  203dfe:	4f43      	ldr	r7, [pc, #268]	; (203f0c <main_run+0x114>)
void main_run(){
  203e00:	b086      	sub	sp, #24
	HOUI=JY901_yaw_get(HOUI_def);
  203e02:	8818      	ldrh	r0, [r3, #0]
  203e04:	f7ff fa54 	bl	2032b0 <JY901_yaw_get>
  203e08:	f8df 8150 	ldr.w	r8, [pc, #336]	; 203f5c <main_run+0x164>
	motor_move(motor[0],motor[1],motor[2],motor[3],motor[4]);
  203e0c:	793c      	ldrb	r4, [r7, #4]
	servo(servodata[0],servodata[1],servodata[2],servodata[3],servodata[4]
  203e0e:	4d40      	ldr	r5, [pc, #256]	; (203f10 <main_run+0x118>)
	motor_move(motor[0],motor[1],motor[2],motor[3],motor[4]);
  203e10:	78fb      	ldrb	r3, [r7, #3]
  203e12:	78ba      	ldrb	r2, [r7, #2]
  203e14:	7879      	ldrb	r1, [r7, #1]
	HOUI=JY901_yaw_get(HOUI_def);
  203e16:	f8a8 0000 	strh.w	r0, [r8]
	motor_move(motor[0],motor[1],motor[2],motor[3],motor[4]);
  203e1a:	7838      	ldrb	r0, [r7, #0]
  203e1c:	9400      	str	r4, [sp, #0]
	servo(servodata[0],servodata[1],servodata[2],servodata[3],servodata[4]
  203e1e:	2400      	movs	r4, #0
	motor_move(motor[0],motor[1],motor[2],motor[3],motor[4]);
  203e20:	f001 f87e 	bl	204f20 <motor_move>
	servo(servodata[0],servodata[1],servodata[2],servodata[3],servodata[4]
  203e24:	f9b5 3006 	ldrsh.w	r3, [r5, #6]
  203e28:	f9b5 2004 	ldrsh.w	r2, [r5, #4]
  203e2c:	f9b5 1002 	ldrsh.w	r1, [r5, #2]
  203e30:	f9b5 0000 	ldrsh.w	r0, [r5]
  203e34:	9405      	str	r4, [sp, #20]
  203e36:	9404      	str	r4, [sp, #16]
  203e38:	9403      	str	r4, [sp, #12]
  203e3a:	9402      	str	r4, [sp, #8]
  203e3c:	9401      	str	r4, [sp, #4]
  203e3e:	f9b5 6008 	ldrsh.w	r6, [r5, #8]
  203e42:	9600      	str	r6, [sp, #0]
	solenoid(data[Servonumber+7]);
  203e44:	4e33      	ldr	r6, [pc, #204]	; (203f14 <main_run+0x11c>)
	servo(servodata[0],servodata[1],servodata[2],servodata[3],servodata[4]
  203e46:	f7ff fa55 	bl	2032f4 <servo>
	solenoid(data[Servonumber+7]);
  203e4a:	7b30      	ldrb	r0, [r6, #12]
  203e4c:	f002 fb6c 	bl	206528 <solenoid>
	encordermotor1(data[5]);
  203e50:	7970      	ldrb	r0, [r6, #5]
  203e52:	f7ff fae5 	bl	203420 <encordermotor1>
	encordermotor2(data[6]);
  203e56:	79b0      	ldrb	r0, [r6, #6]
  203e58:	f7ff fba8 	bl	2035ac <encordermotor2>
	servotemp[tempnumber]=servodata[tempnumber];
  203e5c:	4b2e      	ldr	r3, [pc, #184]	; (203f18 <main_run+0x120>)
  203e5e:	f835 2014 	ldrh.w	r2, [r5, r4, lsl #1]
  203e62:	f823 2014 	strh.w	r2, [r3, r4, lsl #1]
	for(int tempnumber=0;tempnumber<Servonumber;tempnumber++){
  203e66:	3401      	adds	r4, #1
  203e68:	2c05      	cmp	r4, #5
  203e6a:	d1f8      	bne.n	203e5e <main_run+0x66>
	if(Flug_Rxdata==1){
  203e6c:	4d2b      	ldr	r5, [pc, #172]	; (203f1c <main_run+0x124>)
  203e6e:	782c      	ldrb	r4, [r5, #0]
  203e70:	2c01      	cmp	r4, #1
  203e72:	d145      	bne.n	203f00 <main_run+0x108>
	oled_clear();
  203e74:	f7ff fed3 	bl	203c1e <oled_clear>
	oled_returnhome();
  203e78:	f7ff fee5 	bl	203c46 <oled_returnhome>
	oled_puts("main_run select");
  203e7c:	4828      	ldr	r0, [pc, #160]	; (203f20 <main_run+0x128>)
  203e7e:	f7ff fe7f 	bl	203b80 <oled_puts>
	oled_setcursor(1,0);
  203e82:	2100      	movs	r1, #0
  203e84:	4620      	mov	r0, r4
  203e86:	f7ff fecd 	bl	203c24 <oled_setcursor>
	switch(motor[0]){
  203e8a:	783b      	ldrb	r3, [r7, #0]
  203e8c:	2b7d      	cmp	r3, #125	; 0x7d
  203e8e:	d012      	beq.n	203eb6 <main_run+0xbe>
  203e90:	d805      	bhi.n	203e9e <main_run+0xa6>
  203e92:	2b32      	cmp	r3, #50	; 0x32
  203e94:	d00f      	beq.n	203eb6 <main_run+0xbe>
  203e96:	2b64      	cmp	r3, #100	; 0x64
  203e98:	d00d      	beq.n	203eb6 <main_run+0xbe>
		oled_puts("Running");
  203e9a:	4822      	ldr	r0, [pc, #136]	; (203f24 <main_run+0x12c>)
  203e9c:	e006      	b.n	203eac <main_run+0xb4>
	switch(motor[0]){
  203e9e:	2bc8      	cmp	r3, #200	; 0xc8
  203ea0:	d007      	beq.n	203eb2 <main_run+0xba>
  203ea2:	2bfa      	cmp	r3, #250	; 0xfa
  203ea4:	d007      	beq.n	203eb6 <main_run+0xbe>
  203ea6:	2b96      	cmp	r3, #150	; 0x96
  203ea8:	d1f7      	bne.n	203e9a <main_run+0xa2>
		oled_puts("Running   LS");
  203eaa:	481f      	ldr	r0, [pc, #124]	; (203f28 <main_run+0x130>)
		oled_puts("Running");
  203eac:	f7ff fe68 	bl	203b80 <oled_puts>
	break;
  203eb0:	e003      	b.n	203eba <main_run+0xc2>
		oled_puts("Running   RS");
  203eb2:	481e      	ldr	r0, [pc, #120]	; (203f2c <main_run+0x134>)
  203eb4:	e7fa      	b.n	203eac <main_run+0xb4>
		printLCD();
  203eb6:	f002 fac5 	bl	206444 <printLCD>
	xprintf(" cmd=%d",motor[0]);
  203eba:	7839      	ldrb	r1, [r7, #0]
  203ebc:	481c      	ldr	r0, [pc, #112]	; (203f30 <main_run+0x138>)
  203ebe:	f003 fa41 	bl	207344 <xprintf>
	xprintf(" dig=%d",digree);
  203ec2:	4b1c      	ldr	r3, [pc, #112]	; (203f34 <main_run+0x13c>)
  203ec4:	481c      	ldr	r0, [pc, #112]	; (203f38 <main_run+0x140>)
  203ec6:	6819      	ldr	r1, [r3, #0]
  203ec8:	f003 fa3c 	bl	207344 <xprintf>
	xprintf(" p=%d",power);
  203ecc:	4b1b      	ldr	r3, [pc, #108]	; (203f3c <main_run+0x144>)
  203ece:	481c      	ldr	r0, [pc, #112]	; (203f40 <main_run+0x148>)
  203ed0:	6819      	ldr	r1, [r3, #0]
  203ed2:	f003 fa37 	bl	207344 <xprintf>
	xprintf(" E1=%d",TIM5->CNT);
  203ed6:	4b1b      	ldr	r3, [pc, #108]	; (203f44 <main_run+0x14c>)
  203ed8:	481b      	ldr	r0, [pc, #108]	; (203f48 <main_run+0x150>)
  203eda:	6a59      	ldr	r1, [r3, #36]	; 0x24
  203edc:	f003 fa32 	bl	207344 <xprintf>
	xprintf(" E2=%d",TIM8->CNT);
  203ee0:	4b1a      	ldr	r3, [pc, #104]	; (203f4c <main_run+0x154>)
  203ee2:	481b      	ldr	r0, [pc, #108]	; (203f50 <main_run+0x158>)
  203ee4:	6a59      	ldr	r1, [r3, #36]	; 0x24
  203ee6:	f003 fa2d 	bl	207344 <xprintf>
	xprintf(" D=%d",data[Servonumber+8]);
  203eea:	7b71      	ldrb	r1, [r6, #13]
  203eec:	4819      	ldr	r0, [pc, #100]	; (203f54 <main_run+0x15c>)
  203eee:	f003 fa29 	bl	207344 <xprintf>
	xprintf(" H=%d\r\n",HOUI);
  203ef2:	f8b8 1000 	ldrh.w	r1, [r8]
  203ef6:	4818      	ldr	r0, [pc, #96]	; (203f58 <main_run+0x160>)
  203ef8:	f003 fa24 	bl	207344 <xprintf>
	Flug_Rxdata=0;
  203efc:	2300      	movs	r3, #0
  203efe:	702b      	strb	r3, [r5, #0]
}
  203f00:	b006      	add	sp, #24
  203f02:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  203f06:	bf00      	nop
  203f08:	20000178 	.word	0x20000178
  203f0c:	20000205 	.word	0x20000205
  203f10:	20000000 	.word	0x20000000
  203f14:	200001ed 	.word	0x200001ed
  203f18:	2000000a 	.word	0x2000000a
  203f1c:	2000003c 	.word	0x2000003c
  203f20:	00207741 	.word	0x00207741
  203f24:	0020776b 	.word	0x0020776b
  203f28:	00207751 	.word	0x00207751
  203f2c:	0020775e 	.word	0x0020775e
  203f30:	00207773 	.word	0x00207773
  203f34:	200001b8 	.word	0x200001b8
  203f38:	0020777b 	.word	0x0020777b
  203f3c:	20000184 	.word	0x20000184
  203f40:	00207783 	.word	0x00207783
  203f44:	40000c00 	.word	0x40000c00
  203f48:	00207789 	.word	0x00207789
  203f4c:	40010400 	.word	0x40010400
  203f50:	002077ad 	.word	0x002077ad
  203f54:	00207790 	.word	0x00207790
  203f58:	00207796 	.word	0x00207796
  203f5c:	200001bc 	.word	0x200001bc

00203f60 <sens_test>:
void sens_test(){
  203f60:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		HAL_GPIO_WritePin(GPIOC,GPIO_PIN_1,0);
  203f64:	4d31      	ldr	r5, [pc, #196]	; (20402c <sens_test+0xcc>)
void sens_test(){
  203f66:	b086      	sub	sp, #24
		motor_move(0,0,0,0,0);
  203f68:	2400      	movs	r4, #0
		HAL_GPIO_WritePin(GPIOC,GPIO_PIN_1,0);
  203f6a:	2200      	movs	r2, #0
  203f6c:	4628      	mov	r0, r5
  203f6e:	2102      	movs	r1, #2
  203f70:	f7fd f8b6 	bl	2010e0 <HAL_GPIO_WritePin>
		motor_move(0,0,0,0,0);
  203f74:	9400      	str	r4, [sp, #0]
  203f76:	4623      	mov	r3, r4
  203f78:	4622      	mov	r2, r4
  203f7a:	4621      	mov	r1, r4
  203f7c:	4620      	mov	r0, r4
  203f7e:	f000 ffcf 	bl	204f20 <motor_move>
		servo(90,90,90,90,90,0,0,0,0,0);
  203f82:	235a      	movs	r3, #90	; 0x5a
		HOUI=JY901_yaw_get(HOUI_def);
  203f84:	4e2a      	ldr	r6, [pc, #168]	; (204030 <sens_test+0xd0>)
		servo(90,90,90,90,90,0,0,0,0,0);
  203f86:	461a      	mov	r2, r3
  203f88:	9300      	str	r3, [sp, #0]
  203f8a:	4619      	mov	r1, r3
  203f8c:	4618      	mov	r0, r3
  203f8e:	9405      	str	r4, [sp, #20]
  203f90:	9404      	str	r4, [sp, #16]
  203f92:	9403      	str	r4, [sp, #12]
  203f94:	9402      	str	r4, [sp, #8]
  203f96:	9401      	str	r4, [sp, #4]
  203f98:	f7ff f9ac 	bl	2032f4 <servo>
		HOUI=JY901_yaw_get(HOUI_def);
  203f9c:	8830      	ldrh	r0, [r6, #0]
  203f9e:	f7ff f987 	bl	2032b0 <JY901_yaw_get>
		uwDirectionCount1 = TIM5->CNT;
  203fa2:	4b24      	ldr	r3, [pc, #144]	; (204034 <sens_test+0xd4>)
  203fa4:	4f24      	ldr	r7, [pc, #144]	; (204038 <sens_test+0xd8>)
		xprintf(" jack=%d",HAL_GPIO_ReadPin(GPIOE,GPIO_PIN_3));
  203fa6:	2108      	movs	r1, #8
		uwDirectionCount1 = TIM5->CNT;
  203fa8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
		HOUI=JY901_yaw_get(HOUI_def);
  203faa:	4c24      	ldr	r4, [pc, #144]	; (20403c <sens_test+0xdc>)
		uwDirectionCount1 = TIM5->CNT;
  203fac:	603b      	str	r3, [r7, #0]
		uwDirectionCount2 = TIM8->CNT;
  203fae:	4b24      	ldr	r3, [pc, #144]	; (204040 <sens_test+0xe0>)
  203fb0:	f8df 80b0 	ldr.w	r8, [pc, #176]	; 204064 <sens_test+0x104>
  203fb4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
		HOUI=JY901_yaw_get(HOUI_def);
  203fb6:	8020      	strh	r0, [r4, #0]
		xprintf(" jack=%d",HAL_GPIO_ReadPin(GPIOE,GPIO_PIN_3));
  203fb8:	4822      	ldr	r0, [pc, #136]	; (204044 <sens_test+0xe4>)
		uwDirectionCount2 = TIM8->CNT;
  203fba:	f8c8 3000 	str.w	r3, [r8]
		xprintf(" jack=%d",HAL_GPIO_ReadPin(GPIOE,GPIO_PIN_3));
  203fbe:	f7fd f889 	bl	2010d4 <HAL_GPIO_ReadPin>
  203fc2:	4601      	mov	r1, r0
  203fc4:	4820      	ldr	r0, [pc, #128]	; (204048 <sens_test+0xe8>)
  203fc6:	f003 f9bd 	bl	207344 <xprintf>
		xprintf(" E1=%d E2=%d",(int)uwDirectionCount1,(int)uwDirectionCount2);
  203fca:	6839      	ldr	r1, [r7, #0]
		xprintf(" SW_E1=%d%d",HAL_GPIO_ReadPin(GPIOD,GPIO_PIN_3),HAL_GPIO_ReadPin(GPIOD,GPIO_PIN_1));
  203fcc:	4f1f      	ldr	r7, [pc, #124]	; (20404c <sens_test+0xec>)
		xprintf(" E1=%d E2=%d",(int)uwDirectionCount1,(int)uwDirectionCount2);
  203fce:	f8d8 2000 	ldr.w	r2, [r8]
  203fd2:	481f      	ldr	r0, [pc, #124]	; (204050 <sens_test+0xf0>)
  203fd4:	f003 f9b6 	bl	207344 <xprintf>
		xprintf(" SW_E1=%d%d",HAL_GPIO_ReadPin(GPIOD,GPIO_PIN_3),HAL_GPIO_ReadPin(GPIOD,GPIO_PIN_1));
  203fd8:	2108      	movs	r1, #8
  203fda:	4638      	mov	r0, r7
  203fdc:	f7fd f87a 	bl	2010d4 <HAL_GPIO_ReadPin>
  203fe0:	4680      	mov	r8, r0
  203fe2:	2102      	movs	r1, #2
  203fe4:	4638      	mov	r0, r7
  203fe6:	f7fd f875 	bl	2010d4 <HAL_GPIO_ReadPin>
  203fea:	4641      	mov	r1, r8
  203fec:	4602      	mov	r2, r0
  203fee:	4819      	ldr	r0, [pc, #100]	; (204054 <sens_test+0xf4>)
  203ff0:	f003 f9a8 	bl	207344 <xprintf>
		xprintf(" SW_E2=%d%d",HAL_GPIO_ReadPin(GPIOC,GPIO_PIN_12),HAL_GPIO_ReadPin(GPIOC,GPIO_PIN_10));
  203ff4:	f44f 5180 	mov.w	r1, #4096	; 0x1000
  203ff8:	4628      	mov	r0, r5
  203ffa:	f7fd f86b 	bl	2010d4 <HAL_GPIO_ReadPin>
  203ffe:	4607      	mov	r7, r0
  204000:	f44f 6180 	mov.w	r1, #1024	; 0x400
  204004:	4628      	mov	r0, r5
  204006:	f7fd f865 	bl	2010d4 <HAL_GPIO_ReadPin>
  20400a:	4639      	mov	r1, r7
  20400c:	4602      	mov	r2, r0
  20400e:	4812      	ldr	r0, [pc, #72]	; (204058 <sens_test+0xf8>)
  204010:	f003 f998 	bl	207344 <xprintf>
		xprintf(" HOUIdef=%d",HOUI_def);
  204014:	8831      	ldrh	r1, [r6, #0]
  204016:	4811      	ldr	r0, [pc, #68]	; (20405c <sens_test+0xfc>)
  204018:	f003 f994 	bl	207344 <xprintf>
		xprintf(" HOUI=%d\r\n",HOUI);
  20401c:	8821      	ldrh	r1, [r4, #0]
  20401e:	4810      	ldr	r0, [pc, #64]	; (204060 <sens_test+0x100>)
}
  204020:	b006      	add	sp, #24
  204022:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		xprintf(" HOUI=%d\r\n",HOUI);
  204026:	f003 b98d 	b.w	207344 <xprintf>
  20402a:	bf00      	nop
  20402c:	40020800 	.word	0x40020800
  204030:	20000178 	.word	0x20000178
  204034:	40000c00 	.word	0x40000c00
  204038:	20000040 	.word	0x20000040
  20403c:	200001bc 	.word	0x200001bc
  204040:	40010400 	.word	0x40010400
  204044:	40021000 	.word	0x40021000
  204048:	0020779e 	.word	0x0020779e
  20404c:	40020c00 	.word	0x40020c00
  204050:	002077a7 	.word	0x002077a7
  204054:	002077b4 	.word	0x002077b4
  204058:	002077c0 	.word	0x002077c0
  20405c:	002077cc 	.word	0x002077cc
  204060:	002077d8 	.word	0x002077d8
  204064:	20000044 	.word	0x20000044

00204068 <comu_test>:
void comu_test(){
  204068:	b570      	push	{r4, r5, r6, lr}
		motor_move(0,0,0,0,0);
  20406a:	2400      	movs	r4, #0
void comu_test(){
  20406c:	b086      	sub	sp, #24
		HAL_GPIO_WritePin(GPIOC,GPIO_PIN_1,0);
  20406e:	2200      	movs	r2, #0
  204070:	2102      	movs	r1, #2
  204072:	481c      	ldr	r0, [pc, #112]	; (2040e4 <comu_test+0x7c>)
  204074:	f7fd f834 	bl	2010e0 <HAL_GPIO_WritePin>
		motor_move(0,0,0,0,0);
  204078:	4623      	mov	r3, r4
  20407a:	4622      	mov	r2, r4
  20407c:	4621      	mov	r1, r4
  20407e:	4620      	mov	r0, r4
  204080:	9400      	str	r4, [sp, #0]
  204082:	f000 ff4d 	bl	204f20 <motor_move>
		servo(90,90,90,90,90,0,0,0,0,0);
  204086:	235a      	movs	r3, #90	; 0x5a
			xprintf(" data%d)%d",i,data[i]);
  204088:	4d17      	ldr	r5, [pc, #92]	; (2040e8 <comu_test+0x80>)
  20408a:	4e18      	ldr	r6, [pc, #96]	; (2040ec <comu_test+0x84>)
		servo(90,90,90,90,90,0,0,0,0,0);
  20408c:	461a      	mov	r2, r3
  20408e:	9405      	str	r4, [sp, #20]
  204090:	4619      	mov	r1, r3
  204092:	9404      	str	r4, [sp, #16]
  204094:	4618      	mov	r0, r3
  204096:	9403      	str	r4, [sp, #12]
  204098:	9402      	str	r4, [sp, #8]
  20409a:	9401      	str	r4, [sp, #4]
  20409c:	9300      	str	r3, [sp, #0]
  20409e:	f7ff f929 	bl	2032f4 <servo>
			xprintf(" data%d)%d",i,data[i]);
  2040a2:	5d2a      	ldrb	r2, [r5, r4]
  2040a4:	4621      	mov	r1, r4
		for(int i=0;i<(Servonumber+9);i++){
  2040a6:	3401      	adds	r4, #1
			xprintf(" data%d)%d",i,data[i]);
  2040a8:	4630      	mov	r0, r6
  2040aa:	f003 f94b 	bl	207344 <xprintf>
		for(int i=0;i<(Servonumber+9);i++){
  2040ae:	2c0e      	cmp	r4, #14
  2040b0:	d1f7      	bne.n	2040a2 <comu_test+0x3a>
		tempbuf=(data[Servonumber+7] & 0b00000010)>>1;
  2040b2:	7b29      	ldrb	r1, [r5, #12]
		xprintf(" Solenoid=%d",tempbuf);
  2040b4:	480e      	ldr	r0, [pc, #56]	; (2040f0 <comu_test+0x88>)
  2040b6:	f3c1 0140 	ubfx	r1, r1, #1, #1
  2040ba:	f003 f943 	bl	207344 <xprintf>
		tempbuf=(data[Servonumber+7] & 0b00000100)>>2;
  2040be:	7b2c      	ldrb	r4, [r5, #12]
  2040c0:	f3c4 0480 	ubfx	r4, r4, #2, #1
		if(tempbuf==1){HAL_GPIO_WritePin(GPIOC,GPIO_PIN_15,1);}
  2040c4:	b164      	cbz	r4, 2040e0 <comu_test+0x78>
  2040c6:	2201      	movs	r2, #1
		else{HAL_GPIO_WritePin(GPIOC,GPIO_PIN_15,0);}
  2040c8:	f44f 4100 	mov.w	r1, #32768	; 0x8000
  2040cc:	4805      	ldr	r0, [pc, #20]	; (2040e4 <comu_test+0x7c>)
  2040ce:	f7fd f807 	bl	2010e0 <HAL_GPIO_WritePin>
		xprintf(" writedata=%d\r\n",tempbuf);
  2040d2:	4621      	mov	r1, r4
  2040d4:	4807      	ldr	r0, [pc, #28]	; (2040f4 <comu_test+0x8c>)
}
  2040d6:	b006      	add	sp, #24
  2040d8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		xprintf(" writedata=%d\r\n",tempbuf);
  2040dc:	f003 b932 	b.w	207344 <xprintf>
		else{HAL_GPIO_WritePin(GPIOC,GPIO_PIN_15,0);}
  2040e0:	4622      	mov	r2, r4
  2040e2:	e7f1      	b.n	2040c8 <comu_test+0x60>
  2040e4:	40020800 	.word	0x40020800
  2040e8:	200001ed 	.word	0x200001ed
  2040ec:	0020757c 	.word	0x0020757c
  2040f0:	00207587 	.word	0x00207587
  2040f4:	00207594 	.word	0x00207594

002040f8 <test_mode>:
void test_mode(){
  2040f8:	b513      	push	{r0, r1, r4, lr}
	motor_move(250,232,3,251,5);
  2040fa:	2405      	movs	r4, #5
	HAL_GPIO_WritePin(GPIOC,GPIO_PIN_1,1);
  2040fc:	2201      	movs	r2, #1
  2040fe:	2102      	movs	r1, #2
  204100:	480d      	ldr	r0, [pc, #52]	; (204138 <test_mode+0x40>)
  204102:	f7fc ffed 	bl	2010e0 <HAL_GPIO_WritePin>
	motor_move(250,232,3,251,5);
  204106:	23fb      	movs	r3, #251	; 0xfb
  204108:	2203      	movs	r2, #3
  20410a:	21e8      	movs	r1, #232	; 0xe8
  20410c:	9400      	str	r4, [sp, #0]
  20410e:	20fa      	movs	r0, #250	; 0xfa
  204110:	f000 ff06 	bl	204f20 <motor_move>
	HAL_Delay(1000);
  204114:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  204118:	f7fc fcc4 	bl	200aa4 <HAL_Delay>
	motor_move(250,156,4,251,5);
  20411c:	9400      	str	r4, [sp, #0]
  20411e:	23fb      	movs	r3, #251	; 0xfb
  204120:	2204      	movs	r2, #4
  204122:	219c      	movs	r1, #156	; 0x9c
  204124:	20fa      	movs	r0, #250	; 0xfa
  204126:	f000 fefb 	bl	204f20 <motor_move>
	HAL_Delay(1000);
  20412a:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
}
  20412e:	b002      	add	sp, #8
  204130:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	HAL_Delay(1000);
  204134:	f7fc bcb6 	b.w	200aa4 <HAL_Delay>
  204138:	40020800 	.word	0x40020800

0020413c <demo_mode>:
void demo_mode(){
  20413c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	HAL_GPIO_WritePin(GPIOC,GPIO_PIN_1,1);
  204140:	2201      	movs	r2, #1
void demo_mode(){
  204142:	b086      	sub	sp, #24
	HAL_GPIO_WritePin(GPIOC,GPIO_PIN_1,1);
  204144:	2102      	movs	r1, #2
  204146:	4882      	ldr	r0, [pc, #520]	; (204350 <demo_mode+0x214>)
  204148:	f7fc ffca 	bl	2010e0 <HAL_GPIO_WritePin>
	servo(90,90,90,90,90,0,0,0,0,0);
  20414c:	2600      	movs	r6, #0
  20414e:	235a      	movs	r3, #90	; 0x5a
	HOUI=JY901_yaw_get(HOUI_def);
  204150:	4d80      	ldr	r5, [pc, #512]	; (204354 <demo_mode+0x218>)
	servo(90,90,90,90,90,0,0,0,0,0);
  204152:	9605      	str	r6, [sp, #20]
  204154:	4618      	mov	r0, r3
  204156:	9300      	str	r3, [sp, #0]
  204158:	461a      	mov	r2, r3
  20415a:	4619      	mov	r1, r3
  20415c:	9604      	str	r6, [sp, #16]
  20415e:	9603      	str	r6, [sp, #12]
  204160:	9602      	str	r6, [sp, #8]
  204162:	9601      	str	r6, [sp, #4]
  204164:	f7ff f8c6 	bl	2032f4 <servo>
	HOUI=JY901_yaw_get(HOUI_def);
  204168:	8828      	ldrh	r0, [r5, #0]
  20416a:	f7ff f8a1 	bl	2032b0 <JY901_yaw_get>
  20416e:	4c7a      	ldr	r4, [pc, #488]	; (204358 <demo_mode+0x21c>)
  204170:	b280      	uxth	r0, r0
  204172:	8020      	strh	r0, [r4, #0]
	if(HOUI>= 5 && HOUI<=355){
  204174:	3805      	subs	r0, #5
  204176:	f5b0 7faf 	cmp.w	r0, #350	; 0x15e
  20417a:	d838      	bhi.n	2041ee <demo_mode+0xb2>
		motor1(0,0);
  20417c:	4631      	mov	r1, r6
  20417e:	4630      	mov	r0, r6
  204180:	f7ff fae4 	bl	20374c <motor1>
		motor2(0,0);
  204184:	4631      	mov	r1, r6
  204186:	4630      	mov	r0, r6
			xprintf("RS now");
  204188:	f8df 81f8 	ldr.w	r8, [pc, #504]	; 204384 <demo_mode+0x248>
		motor2(0,0);
  20418c:	f7ff fafc 	bl	203788 <motor2>
		motor3(0,0);
  204190:	4631      	mov	r1, r6
  204192:	4630      	mov	r0, r6
			xprintf(" speed= %d\r\n",(int)map(HOUI,359,180,70,300));
  204194:	4f71      	ldr	r7, [pc, #452]	; (20435c <demo_mode+0x220>)
		motor3(0,0);
  204196:	f7ff fb15 	bl	2037c4 <motor3>
		motor4(0,0);
  20419a:	4631      	mov	r1, r6
  20419c:	4630      	mov	r0, r6
			HAL_GPIO_WritePin(GPIOE,GPIO_PIN_10,1);
  20419e:	f106 4680 	add.w	r6, r6, #1073741824	; 0x40000000
		motor4(0,0);
  2041a2:	f7ff fb2d 	bl	203800 <motor4>
		HAL_Delay(50);
  2041a6:	2032      	movs	r0, #50	; 0x32
			HAL_GPIO_WritePin(GPIOE,GPIO_PIN_10,1);
  2041a8:	f506 3604 	add.w	r6, r6, #135168	; 0x21000
		HAL_Delay(50);
  2041ac:	f7fc fc7a 	bl	200aa4 <HAL_Delay>
		while(HOUI>=5 && HOUI<=355){
  2041b0:	8823      	ldrh	r3, [r4, #0]
  2041b2:	3b05      	subs	r3, #5
  2041b4:	b29b      	uxth	r3, r3
  2041b6:	f5b3 7faf 	cmp.w	r3, #350	; 0x15e
  2041ba:	d940      	bls.n	20423e <demo_mode+0x102>
		motor1(0,0);
  2041bc:	2100      	movs	r1, #0
  2041be:	4608      	mov	r0, r1
  2041c0:	f7ff fac4 	bl	20374c <motor1>
		motor2(0,0);
  2041c4:	2100      	movs	r1, #0
  2041c6:	4608      	mov	r0, r1
  2041c8:	f7ff fade 	bl	203788 <motor2>
		motor3(0,0);
  2041cc:	2100      	movs	r1, #0
  2041ce:	4608      	mov	r0, r1
  2041d0:	f7ff faf8 	bl	2037c4 <motor3>
		motor4(0,0);
  2041d4:	2100      	movs	r1, #0
  2041d6:	4608      	mov	r0, r1
  2041d8:	f7ff fb12 	bl	203800 <motor4>
		HAL_GPIO_WritePin(GPIOE,GPIO_PIN_10,0);
  2041dc:	4860      	ldr	r0, [pc, #384]	; (204360 <demo_mode+0x224>)
  2041de:	2200      	movs	r2, #0
  2041e0:	f44f 6180 	mov.w	r1, #1024	; 0x400
  2041e4:	f7fc ff7c 	bl	2010e0 <HAL_GPIO_WritePin>
		HAL_Delay(50);
  2041e8:	2032      	movs	r0, #50	; 0x32
  2041ea:	f7fc fc5b 	bl	200aa4 <HAL_Delay>
	motor1(0,0);
  2041ee:	2100      	movs	r1, #0
  2041f0:	4608      	mov	r0, r1
  2041f2:	f7ff faab 	bl	20374c <motor1>
	motor2(0,0);
  2041f6:	2100      	movs	r1, #0
  2041f8:	4608      	mov	r0, r1
  2041fa:	f7ff fac5 	bl	203788 <motor2>
	motor3(0,0);
  2041fe:	2100      	movs	r1, #0
  204200:	4608      	mov	r0, r1
  204202:	f7ff fadf 	bl	2037c4 <motor3>
	motor4(0,0);
  204206:	2100      	movs	r1, #0
  204208:	4608      	mov	r0, r1
  20420a:	f7ff faf9 	bl	203800 <motor4>
	HAL_GPIO_WritePin(GPIOE,GPIO_PIN_10,0);
  20420e:	2200      	movs	r2, #0
  204210:	f44f 6180 	mov.w	r1, #1024	; 0x400
  204214:	4852      	ldr	r0, [pc, #328]	; (204360 <demo_mode+0x224>)
  204216:	f7fc ff63 	bl	2010e0 <HAL_GPIO_WritePin>
	uwDirectionCount1 = TIM5->CNT;
  20421a:	4b52      	ldr	r3, [pc, #328]	; (204364 <demo_mode+0x228>)
	xprintf("E1=%d E2=%d",(int)uwDirectionCount1,(int)uwDirectionCount2);
  20421c:	4852      	ldr	r0, [pc, #328]	; (204368 <demo_mode+0x22c>)
	uwDirectionCount1 = TIM5->CNT;
  20421e:	6a59      	ldr	r1, [r3, #36]	; 0x24
  204220:	4b52      	ldr	r3, [pc, #328]	; (20436c <demo_mode+0x230>)
  204222:	6019      	str	r1, [r3, #0]
	uwDirectionCount2 = TIM8->CNT;
  204224:	4b52      	ldr	r3, [pc, #328]	; (204370 <demo_mode+0x234>)
  204226:	6a5a      	ldr	r2, [r3, #36]	; 0x24
  204228:	4b52      	ldr	r3, [pc, #328]	; (204374 <demo_mode+0x238>)
  20422a:	601a      	str	r2, [r3, #0]
	xprintf("E1=%d E2=%d",(int)uwDirectionCount1,(int)uwDirectionCount2);
  20422c:	f003 f88a 	bl	207344 <xprintf>
	xprintf(" HOUI=%d\r\n",HOUI);
  204230:	8821      	ldrh	r1, [r4, #0]
  204232:	4851      	ldr	r0, [pc, #324]	; (204378 <demo_mode+0x23c>)
}
  204234:	b006      	add	sp, #24
  204236:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	xprintf(" HOUI=%d\r\n",HOUI);
  20423a:	f003 b883 	b.w	207344 <xprintf>
		HOUI=JY901_yaw_get(HOUI_def);
  20423e:	8828      	ldrh	r0, [r5, #0]
  204240:	f44f 7996 	mov.w	r9, #300	; 0x12c
  204244:	f7ff f834 	bl	2032b0 <JY901_yaw_get>
  204248:	b283      	uxth	r3, r0
		if(HOUI<180){
  20424a:	2bb3      	cmp	r3, #179	; 0xb3
		HOUI=JY901_yaw_get(HOUI_def);
  20424c:	8023      	strh	r3, [r4, #0]
  20424e:	4618      	mov	r0, r3
		if(HOUI<180){
  204250:	d83a      	bhi.n	2042c8 <demo_mode+0x18c>
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  204252:	fb09 f003 	mul.w	r0, r9, r3
  204256:	f04f 0ab4 	mov.w	sl, #180	; 0xb4
  20425a:	fb90 f1fa 	sdiv	r1, r0, sl
		motor1(0,(int)map(HOUI,0,180,300,600));
  20425e:	2000      	movs	r0, #0
  204260:	4449      	add	r1, r9
  204262:	f7ff fa73 	bl	20374c <motor1>
		motor2(0,(int)map(HOUI,0,180,300,600));
  204266:	8821      	ldrh	r1, [r4, #0]
  204268:	2000      	movs	r0, #0
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  20426a:	fb09 f101 	mul.w	r1, r9, r1
  20426e:	fb91 f1fa 	sdiv	r1, r1, sl
		motor2(0,(int)map(HOUI,0,180,300,600));
  204272:	4449      	add	r1, r9
  204274:	f7ff fa88 	bl	203788 <motor2>
		motor3((int)map(HOUI,0,180,300,600),0);
  204278:	8820      	ldrh	r0, [r4, #0]
  20427a:	2100      	movs	r1, #0
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  20427c:	fb09 f000 	mul.w	r0, r9, r0
  204280:	fb90 f0fa 	sdiv	r0, r0, sl
		motor3((int)map(HOUI,0,180,300,600),0);
  204284:	4448      	add	r0, r9
  204286:	f7ff fa9d 	bl	2037c4 <motor3>
		motor4((int)map(HOUI,0,180,300,600),0);
  20428a:	8820      	ldrh	r0, [r4, #0]
  20428c:	2100      	movs	r1, #0
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  20428e:	fb09 f000 	mul.w	r0, r9, r0
  204292:	fb90 f0fa 	sdiv	r0, r0, sl
		motor4((int)map(HOUI,0,180,300,600),0);
  204296:	4448      	add	r0, r9
  204298:	f7ff fab2 	bl	203800 <motor4>
		HAL_GPIO_WritePin(GPIOE,GPIO_PIN_10,1);
  20429c:	2201      	movs	r2, #1
  20429e:	f44f 6180 	mov.w	r1, #1024	; 0x400
  2042a2:	4630      	mov	r0, r6
  2042a4:	f7fc ff1c 	bl	2010e0 <HAL_GPIO_WritePin>
		xprintf("LS now");
  2042a8:	4834      	ldr	r0, [pc, #208]	; (20437c <demo_mode+0x240>)
  2042aa:	f003 f84b 	bl	207344 <xprintf>
		xprintf(" speed= %d\r\n",(int)map(HOUI,0,180,70,300));
  2042ae:	8823      	ldrh	r3, [r4, #0]
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  2042b0:	21e6      	movs	r1, #230	; 0xe6
			xprintf(" speed= %d\r\n",(int)map(HOUI,359,180,70,300));
  2042b2:	4638      	mov	r0, r7
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  2042b4:	4359      	muls	r1, r3
  2042b6:	fb91 f1fa 	sdiv	r1, r1, sl
			xprintf(" speed= %d\r\n",(int)map(HOUI,359,180,70,300));
  2042ba:	3146      	adds	r1, #70	; 0x46
  2042bc:	f003 f842 	bl	207344 <xprintf>
		  HAL_IWDG_Refresh(&hiwdg);
  2042c0:	482f      	ldr	r0, [pc, #188]	; (204380 <demo_mode+0x244>)
  2042c2:	f7fd fa41 	bl	201748 <HAL_IWDG_Refresh>
  2042c6:	e773      	b.n	2041b0 <demo_mode+0x74>
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  2042c8:	f46f 73b3 	mvn.w	r3, #358	; 0x166
  2042cc:	f06f 0ab2 	mvn.w	sl, #178	; 0xb2
			motor1((int)map(HOUI,359,180,300,600),0);
  2042d0:	2100      	movs	r1, #0
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  2042d2:	4418      	add	r0, r3
  2042d4:	fb09 f000 	mul.w	r0, r9, r0
  2042d8:	fb90 f0fa 	sdiv	r0, r0, sl
			motor1((int)map(HOUI,359,180,300,600),0);
  2042dc:	f500 7096 	add.w	r0, r0, #300	; 0x12c
  2042e0:	f7ff fa34 	bl	20374c <motor1>
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  2042e4:	f46f 72b3 	mvn.w	r2, #358	; 0x166
			motor2((int)map(HOUI,359,180,300,600),0);
  2042e8:	8820      	ldrh	r0, [r4, #0]
  2042ea:	2100      	movs	r1, #0
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  2042ec:	4410      	add	r0, r2
  2042ee:	fb09 f000 	mul.w	r0, r9, r0
  2042f2:	fb90 f0fa 	sdiv	r0, r0, sl
			motor2((int)map(HOUI,359,180,300,600),0);
  2042f6:	f500 7096 	add.w	r0, r0, #300	; 0x12c
  2042fa:	f7ff fa45 	bl	203788 <motor2>
			motor3(0,(int)map(HOUI,359,180,300,600));
  2042fe:	8821      	ldrh	r1, [r4, #0]
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  204300:	f46f 70b3 	mvn.w	r0, #358	; 0x166
  204304:	4401      	add	r1, r0
			motor3(0,(int)map(HOUI,359,180,300,600));
  204306:	2000      	movs	r0, #0
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  204308:	fb09 f101 	mul.w	r1, r9, r1
  20430c:	fb91 f1fa 	sdiv	r1, r1, sl
			motor3(0,(int)map(HOUI,359,180,300,600));
  204310:	f501 7196 	add.w	r1, r1, #300	; 0x12c
  204314:	f7ff fa56 	bl	2037c4 <motor3>
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  204318:	f46f 7eb3 	mvn.w	lr, #358	; 0x166
			motor4(0,(int)map(HOUI,359,180,300,600));
  20431c:	8821      	ldrh	r1, [r4, #0]
  20431e:	2000      	movs	r0, #0
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  204320:	4471      	add	r1, lr
  204322:	fb09 f101 	mul.w	r1, r9, r1
  204326:	fb91 f1fa 	sdiv	r1, r1, sl
			motor4(0,(int)map(HOUI,359,180,300,600));
  20432a:	f501 7196 	add.w	r1, r1, #300	; 0x12c
  20432e:	f7ff fa67 	bl	203800 <motor4>
			HAL_GPIO_WritePin(GPIOE,GPIO_PIN_10,1);
  204332:	f44f 6180 	mov.w	r1, #1024	; 0x400
  204336:	2201      	movs	r2, #1
  204338:	4630      	mov	r0, r6
  20433a:	f7fc fed1 	bl	2010e0 <HAL_GPIO_WritePin>
			xprintf("RS now");
  20433e:	4640      	mov	r0, r8
  204340:	f003 f800 	bl	207344 <xprintf>
			xprintf(" speed= %d\r\n",(int)map(HOUI,359,180,70,300));
  204344:	8821      	ldrh	r1, [r4, #0]
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  204346:	f46f 7cb3 	mvn.w	ip, #358	; 0x166
  20434a:	eb01 030c 	add.w	r3, r1, ip
  20434e:	e7af      	b.n	2042b0 <demo_mode+0x174>
  204350:	40020800 	.word	0x40020800
  204354:	20000178 	.word	0x20000178
  204358:	200001bc 	.word	0x200001bc
  20435c:	002075ab 	.word	0x002075ab
  204360:	40021000 	.word	0x40021000
  204364:	40000c00 	.word	0x40000c00
  204368:	002077a8 	.word	0x002077a8
  20436c:	20000040 	.word	0x20000040
  204370:	40010400 	.word	0x40010400
  204374:	20000044 	.word	0x20000044
  204378:	002077d8 	.word	0x002077d8
  20437c:	002075a4 	.word	0x002075a4
  204380:	20000168 	.word	0x20000168
  204384:	002075b8 	.word	0x002075b8

00204388 <calib_mode>:
void calib_mode(){
  204388:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
	HAL_GPIO_WritePin(GPIOC,GPIO_PIN_1,1);
  20438c:	2201      	movs	r2, #1
  20438e:	2102      	movs	r1, #2
  204390:	485c      	ldr	r0, [pc, #368]	; (204504 <calib_mode+0x17c>)
  204392:	f7fc fea5 	bl	2010e0 <HAL_GPIO_WritePin>
	motor_move(0,0,0,0,0);
  204396:	2300      	movs	r3, #0
	while(HAL_GPIO_ReadPin(GPIOD,GPIO_PIN_7)==1){
  204398:	4f5b      	ldr	r7, [pc, #364]	; (204508 <calib_mode+0x180>)
	if(HAL_GPIO_ReadPin(GPIOE,GPIO_PIN_1)==0){	//press RS
  20439a:	4e5c      	ldr	r6, [pc, #368]	; (20450c <calib_mode+0x184>)
	motor_move(0,0,0,0,0);
  20439c:	461a      	mov	r2, r3
		HAL_GPIO_WritePin(GPIOB,GPIO_PIN_2,1);
  20439e:	f8df 81a0 	ldr.w	r8, [pc, #416]	; 204540 <calib_mode+0x1b8>
	motor_move(0,0,0,0,0);
  2043a2:	4619      	mov	r1, r3
  2043a4:	9300      	str	r3, [sp, #0]
  2043a6:	4618      	mov	r0, r3
  2043a8:	f000 fdba 	bl	204f20 <motor_move>
	while(HAL_GPIO_ReadPin(GPIOD,GPIO_PIN_7)==1){
  2043ac:	2180      	movs	r1, #128	; 0x80
  2043ae:	4638      	mov	r0, r7
  2043b0:	f7fc fe90 	bl	2010d4 <HAL_GPIO_ReadPin>
  2043b4:	2801      	cmp	r0, #1
  2043b6:	4605      	mov	r5, r0
  2043b8:	d002      	beq.n	2043c0 <calib_mode+0x38>
}
  2043ba:	b003      	add	sp, #12
  2043bc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		oled_returnhome();
  2043c0:	f7ff fc41 	bl	203c46 <oled_returnhome>
		oled_puts("Calib select    ");
  2043c4:	4852      	ldr	r0, [pc, #328]	; (204510 <calib_mode+0x188>)
  2043c6:	f7ff fbdb 	bl	203b80 <oled_puts>
		oled_setcursor(1,0);
  2043ca:	2100      	movs	r1, #0
  2043cc:	4628      	mov	r0, r5
  2043ce:	f7ff fc29 	bl	203c24 <oled_setcursor>
		oled_puts("Running Press SW");
  2043d2:	4850      	ldr	r0, [pc, #320]	; (204514 <calib_mode+0x18c>)
  2043d4:	f7ff fbd4 	bl	203b80 <oled_puts>
		HAL_Delay(5);
  2043d8:	2005      	movs	r0, #5
  2043da:	f7fc fb63 	bl	200aa4 <HAL_Delay>
	if(HAL_GPIO_ReadPin(GPIOE,GPIO_PIN_1)==0){	//press RS
  2043de:	2102      	movs	r1, #2
  2043e0:	484a      	ldr	r0, [pc, #296]	; (20450c <calib_mode+0x184>)
  2043e2:	f7fc fe77 	bl	2010d4 <HAL_GPIO_ReadPin>
  2043e6:	4604      	mov	r4, r0
  2043e8:	2800      	cmp	r0, #0
  2043ea:	f040 8081 	bne.w	2044f0 <calib_mode+0x168>
		HAL_GPIO_WritePin(GPIOB,GPIO_PIN_2,1);
  2043ee:	462a      	mov	r2, r5
  2043f0:	2104      	movs	r1, #4
  2043f2:	4640      	mov	r0, r8
		motor_move(200,0,0,201,3);
  2043f4:	f04f 0903 	mov.w	r9, #3
		HAL_GPIO_WritePin(GPIOB,GPIO_PIN_2,1);
  2043f8:	f7fc fe72 	bl	2010e0 <HAL_GPIO_WritePin>
		oled_clear();
  2043fc:	f7ff fc0f 	bl	203c1e <oled_clear>
		oled_returnhome();
  204400:	f7ff fc21 	bl	203c46 <oled_returnhome>
		oled_puts("Angular velocity");
  204404:	4844      	ldr	r0, [pc, #272]	; (204518 <calib_mode+0x190>)
  204406:	f7ff fbbb 	bl	203b80 <oled_puts>
		oled_setcursor(1,0);
  20440a:	4621      	mov	r1, r4
  20440c:	4628      	mov	r0, r5
  20440e:	f7ff fc09 	bl	203c24 <oled_setcursor>
		oled_puts("    Calibration ");
  204412:	4842      	ldr	r0, [pc, #264]	; (20451c <calib_mode+0x194>)
  204414:	f7ff fbb4 	bl	203b80 <oled_puts>
		JY901_calibration(1000,1);
  204418:	4629      	mov	r1, r5
  20441a:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  20441e:	f7fe fecf 	bl	2031c0 <JY901_calibration>
		oled_clear();
  204422:	f7ff fbfc 	bl	203c1e <oled_clear>
		oled_returnhome();
  204426:	f7ff fc0e 	bl	203c46 <oled_returnhome>
		oled_puts("Magnetic");
  20442a:	483d      	ldr	r0, [pc, #244]	; (204520 <calib_mode+0x198>)
  20442c:	f7ff fba8 	bl	203b80 <oled_puts>
		oled_setcursor(1,0);
  204430:	4621      	mov	r1, r4
  204432:	4628      	mov	r0, r5
  204434:	f7ff fbf6 	bl	203c24 <oled_setcursor>
		oled_puts(" Calibration  RS");
  204438:	483a      	ldr	r0, [pc, #232]	; (204524 <calib_mode+0x19c>)
  20443a:	f7ff fba1 	bl	203b80 <oled_puts>
		xprintf("houi cab\r\n");
  20443e:	483a      	ldr	r0, [pc, #232]	; (204528 <calib_mode+0x1a0>)
  204440:	f002 ff80 	bl	207344 <xprintf>
		motor_move(200,0,0,201,3);
  204444:	23c9      	movs	r3, #201	; 0xc9
  204446:	4622      	mov	r2, r4
  204448:	4621      	mov	r1, r4
  20444a:	20c8      	movs	r0, #200	; 0xc8
  20444c:	f8cd 9000 	str.w	r9, [sp]
  204450:	f000 fd66 	bl	204f20 <motor_move>
		JY901_calibration(10000,2);
  204454:	2102      	movs	r1, #2
  204456:	f242 7010 	movw	r0, #10000	; 0x2710
  20445a:	f7fe feb1 	bl	2031c0 <JY901_calibration>
		oled_clear();
  20445e:	f7ff fbde 	bl	203c1e <oled_clear>
		oled_returnhome();
  204462:	f7ff fbf0 	bl	203c46 <oled_returnhome>
		oled_puts("Calibration End ");
  204466:	4831      	ldr	r0, [pc, #196]	; (20452c <calib_mode+0x1a4>)
  204468:	f7ff fb8a 	bl	203b80 <oled_puts>
		oled_setcursor(1,0);
  20446c:	4621      	mov	r1, r4
  20446e:	4628      	mov	r0, r5
  204470:	f7ff fbd8 	bl	203c24 <oled_setcursor>
		oled_puts("                ");
  204474:	482e      	ldr	r0, [pc, #184]	; (204530 <calib_mode+0x1a8>)
  204476:	f7ff fb83 	bl	203b80 <oled_puts>
		motor_move(0,0,0,0,0);
  20447a:	4623      	mov	r3, r4
  20447c:	4622      	mov	r2, r4
  20447e:	4621      	mov	r1, r4
  204480:	4620      	mov	r0, r4
  204482:	9400      	str	r4, [sp, #0]
  204484:	f000 fd4c 	bl	204f20 <motor_move>
		xprintf("cab end\r\n");
  204488:	482a      	ldr	r0, [pc, #168]	; (204534 <calib_mode+0x1ac>)
  20448a:	f002 ff5b 	bl	207344 <xprintf>
		JY901_calibration(100,3);
  20448e:	4649      	mov	r1, r9
  204490:	2064      	movs	r0, #100	; 0x64
  204492:	f7fe fe95 	bl	2031c0 <JY901_calibration>
		xprintf("save\r\n");
  204496:	4828      	ldr	r0, [pc, #160]	; (204538 <calib_mode+0x1b0>)
  204498:	f002 ff54 	bl	207344 <xprintf>
		JY901_calibration(100,4);
  20449c:	2104      	movs	r1, #4
  20449e:	2064      	movs	r0, #100	; 0x64
  2044a0:	f7fe fe8e 	bl	2031c0 <JY901_calibration>
		HAL_GPIO_WritePin(GPIOB,GPIO_PIN_2,0);
  2044a4:	4622      	mov	r2, r4
  2044a6:	2104      	movs	r1, #4
  2044a8:	4640      	mov	r0, r8
  2044aa:	f7fc fe19 	bl	2010e0 <HAL_GPIO_WritePin>
	  	HAL_GPIO_WritePin(GPIOE,GPIO_PIN_2,1);
  2044ae:	462a      	mov	r2, r5
  2044b0:	2104      	movs	r1, #4
  2044b2:	4630      	mov	r0, r6
  2044b4:	f7fc fe14 	bl	2010e0 <HAL_GPIO_WritePin>
	  	HAL_Delay(200);
  2044b8:	20c8      	movs	r0, #200	; 0xc8
  2044ba:	f7fc faf3 	bl	200aa4 <HAL_Delay>
	  	HAL_GPIO_WritePin(GPIOE,GPIO_PIN_2,0);
  2044be:	4622      	mov	r2, r4
  2044c0:	2104      	movs	r1, #4
  2044c2:	4630      	mov	r0, r6
  2044c4:	f7fc fe0c 	bl	2010e0 <HAL_GPIO_WritePin>
	  	HAL_Delay(70);
  2044c8:	2046      	movs	r0, #70	; 0x46
  2044ca:	f7fc faeb 	bl	200aa4 <HAL_Delay>
	  	HAL_GPIO_WritePin(GPIOE,GPIO_PIN_2,1);
  2044ce:	462a      	mov	r2, r5
  2044d0:	2104      	movs	r1, #4
  2044d2:	4630      	mov	r0, r6
  2044d4:	f7fc fe04 	bl	2010e0 <HAL_GPIO_WritePin>
	  	HAL_Delay(200);
  2044d8:	20c8      	movs	r0, #200	; 0xc8
  2044da:	f7fc fae3 	bl	200aa4 <HAL_Delay>
	  	HAL_GPIO_WritePin(GPIOE,GPIO_PIN_2,0);
  2044de:	4630      	mov	r0, r6
  2044e0:	4622      	mov	r2, r4
  2044e2:	2104      	movs	r1, #4
  2044e4:	f7fc fdfc 	bl	2010e0 <HAL_GPIO_WritePin>
	  	HAL_Delay(400);
  2044e8:	f44f 70c8 	mov.w	r0, #400	; 0x190
  2044ec:	f7fc fada 	bl	200aa4 <HAL_Delay>
	HAL_GPIO_TogglePin(GPIOD,GPIO_PIN_10);
  2044f0:	4638      	mov	r0, r7
  2044f2:	f44f 6180 	mov.w	r1, #1024	; 0x400
  2044f6:	f7fc fdf8 	bl	2010ea <HAL_GPIO_TogglePin>
    HAL_IWDG_Refresh(&hiwdg);
  2044fa:	4810      	ldr	r0, [pc, #64]	; (20453c <calib_mode+0x1b4>)
  2044fc:	f7fd f924 	bl	201748 <HAL_IWDG_Refresh>
  204500:	e754      	b.n	2043ac <calib_mode+0x24>
  204502:	bf00      	nop
  204504:	40020800 	.word	0x40020800
  204508:	40020c00 	.word	0x40020c00
  20450c:	40021000 	.word	0x40021000
  204510:	002074e0 	.word	0x002074e0
  204514:	002074f1 	.word	0x002074f1
  204518:	00207502 	.word	0x00207502
  20451c:	00207513 	.word	0x00207513
  204520:	00207524 	.word	0x00207524
  204524:	0020752d 	.word	0x0020752d
  204528:	0020753e 	.word	0x0020753e
  20452c:	00207549 	.word	0x00207549
  204530:	0020755a 	.word	0x0020755a
  204534:	0020756b 	.word	0x0020756b
  204538:	00207575 	.word	0x00207575
  20453c:	20000168 	.word	0x20000168
  204540:	40020400 	.word	0x40020400

00204544 <main>:
{
  204544:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  204548:	b087      	sub	sp, #28
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
  20454a:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  20454e:	f3bf 8f6f 	isb	sy
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
  204552:	4bca      	ldr	r3, [pc, #808]	; (20487c <main+0x338>)
  204554:	2100      	movs	r1, #0
  204556:	f8c3 1250 	str.w	r1, [r3, #592]	; 0x250
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
  20455a:	695a      	ldr	r2, [r3, #20]
  20455c:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
  204560:	615a      	str	r2, [r3, #20]
  __ASM volatile ("dsb 0xF":::"memory");
  204562:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  204566:	f3bf 8f6f 	isb	sy
    SCB->CSSELR = (0U << 1U) | 0U;          /* Level 1 data cache */
  20456a:	f8c3 1084 	str.w	r1, [r3, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
  20456e:	f3bf 8f4f 	dsb	sy
    ccsidr = SCB->CCSIDR;
  204572:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
  204576:	f643 76e0 	movw	r6, #16352	; 0x3fe0
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
  20457a:	f3c2 04c9 	ubfx	r4, r2, #3, #10
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
  20457e:	f3c2 324e 	ubfx	r2, r2, #13, #15
  204582:	07a5      	lsls	r5, r4, #30
  204584:	0152      	lsls	r2, r2, #5
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
  204586:	ea02 0e06 	and.w	lr, r2, r6
  20458a:	4628      	mov	r0, r5
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
  20458c:	4621      	mov	r1, r4
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
  20458e:	ea40 070e 	orr.w	r7, r0, lr
      } while (ways--);
  204592:	3901      	subs	r1, #1
  204594:	f100 4040 	add.w	r0, r0, #3221225472	; 0xc0000000
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
  204598:	f8c3 7260 	str.w	r7, [r3, #608]	; 0x260
      } while (ways--);
  20459c:	1c4f      	adds	r7, r1, #1
  20459e:	d1f6      	bne.n	20458e <main+0x4a>
  2045a0:	3a20      	subs	r2, #32
    } while(sets--);
  2045a2:	f112 0f20 	cmn.w	r2, #32
  2045a6:	d1ee      	bne.n	204586 <main+0x42>
  2045a8:	f3bf 8f4f 	dsb	sy
    SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;  /* enable D-Cache */
  2045ac:	695a      	ldr	r2, [r3, #20]
  2045ae:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
  2045b2:	615a      	str	r2, [r3, #20]
  2045b4:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  2045b8:	f3bf 8f6f 	isb	sy
  HAL_Init();
  2045bc:	f7fc fa52 	bl	200a64 <HAL_Init>
  SystemClock_Config();
  2045c0:	f7ff fbb4 	bl	203d2c <SystemClock_Config>
  MX_GPIO_Init();
  2045c4:	f7ff f972 	bl	2038ac <MX_GPIO_Init>
  MX_DMA_Init();
  2045c8:	f7ff f958 	bl	20387c <MX_DMA_Init>
  MX_I2C2_Init();
  2045cc:	f7ff fa54 	bl	203a78 <MX_I2C2_Init>
  MX_TIM1_Init();
  2045d0:	f002 fa66 	bl	206aa0 <MX_TIM1_Init>
  MX_TIM3_Init();
  2045d4:	f002 fb3c 	bl	206c50 <MX_TIM3_Init>
  MX_TIM2_Init();
  2045d8:	f002 fade 	bl	206b98 <MX_TIM2_Init>
  MX_TIM4_Init();
  2045dc:	f002 fb94 	bl	206d08 <MX_TIM4_Init>
  MX_TIM8_Init();
  2045e0:	f002 f8a6 	bl	206730 <MX_TIM8_Init>
  MX_USART1_UART_Init();
  2045e4:	f002 fce4 	bl	206fb0 <MX_USART1_UART_Init>
  MX_USART2_UART_Init();
  2045e8:	f002 fd04 	bl	206ff4 <MX_USART2_UART_Init>
  MX_TIM6_Init();
  2045ec:	f002 f872 	bl	2066d4 <MX_TIM6_Init>
  MX_TIM9_Init();
  2045f0:	f002 fbea 	bl	206dc8 <MX_TIM9_Init>
  MX_TIM5_Init();
  2045f4:	f002 f834 	bl	206660 <MX_TIM5_Init>
  MX_TIM12_Init();
  2045f8:	f002 fc9c 	bl	206f34 <MX_TIM12_Init>
  MX_TIM11_Init();
  2045fc:	f002 fc5e 	bl	206ebc <MX_TIM11_Init>
  MX_TIM10_Init();
  204600:	f002 fc20 	bl	206e44 <MX_TIM10_Init>
  MX_I2C1_Init();
  204604:	f7ff fa02 	bl	203a0c <MX_I2C1_Init>
  xdev_out(uart_putc);
  204608:	4a9d      	ldr	r2, [pc, #628]	; (204880 <main+0x33c>)
  20460a:	4b9e      	ldr	r3, [pc, #632]	; (204884 <main+0x340>)
  if(HAL_GPIO_ReadPin(GPIOE,GPIO_PIN_1)==1){
  20460c:	2102      	movs	r1, #2
  20460e:	489e      	ldr	r0, [pc, #632]	; (204888 <main+0x344>)
  xdev_out(uart_putc);
  204610:	601a      	str	r2, [r3, #0]
  if(HAL_GPIO_ReadPin(GPIOE,GPIO_PIN_1)==1){
  204612:	f7fc fd5f 	bl	2010d4 <HAL_GPIO_ReadPin>
  204616:	2801      	cmp	r0, #1
  204618:	d144      	bne.n	2046a4 <main+0x160>
  	  MX_IWDG_Init();
  20461a:	f7ff fb39 	bl	203c90 <MX_IWDG_Init>
  servo(90,90,90,90,90,90,90,90,90,90);
  20461e:	235a      	movs	r3, #90	; 0x5a
  204620:	461a      	mov	r2, r3
  204622:	4619      	mov	r1, r3
  204624:	4618      	mov	r0, r3
  204626:	9305      	str	r3, [sp, #20]
  204628:	9304      	str	r3, [sp, #16]
  20462a:	9303      	str	r3, [sp, #12]
  20462c:	9302      	str	r3, [sp, #8]
  20462e:	9301      	str	r3, [sp, #4]
  204630:	9300      	str	r3, [sp, #0]
  204632:	f7fe fe5f 	bl	2032f4 <servo>
  HAL_GPIO_WritePin(GPIOC,GPIO_PIN_1,1);
  204636:	2201      	movs	r2, #1
  204638:	2102      	movs	r1, #2
  20463a:	4894      	ldr	r0, [pc, #592]	; (20488c <main+0x348>)
  20463c:	f7fc fd50 	bl	2010e0 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(GPIOC,GPIO_PIN_15,0);
  204640:	2200      	movs	r2, #0
  204642:	f44f 4100 	mov.w	r1, #32768	; 0x8000
  204646:	4891      	ldr	r0, [pc, #580]	; (20488c <main+0x348>)
  204648:	f7fc fd4a 	bl	2010e0 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(GPIOE,GPIO_PIN_2,0);
  20464c:	2200      	movs	r2, #0
  20464e:	2104      	movs	r1, #4
  204650:	488d      	ldr	r0, [pc, #564]	; (204888 <main+0x344>)
  204652:	f7fc fd45 	bl	2010e0 <HAL_GPIO_WritePin>
  oled_i2c_to_oled(&hi2c2);
  204656:	488e      	ldr	r0, [pc, #568]	; (204890 <main+0x34c>)
  204658:	f7ff fb06 	bl	203c68 <oled_i2c_to_oled>
  JY901_init(&hi2c2);
  20465c:	488c      	ldr	r0, [pc, #560]	; (204890 <main+0x34c>)
  20465e:	f7fe fda9 	bl	2031b4 <JY901_init>
  init_xprintf(&huart2);
  204662:	488c      	ldr	r0, [pc, #560]	; (204894 <main+0x350>)
  204664:	f002 fd5e 	bl	207124 <init_xprintf>
  oled_returnhome();
  204668:	f7ff faed 	bl	203c46 <oled_returnhome>
  oled_puts("Is The Order a");
  20466c:	488a      	ldr	r0, [pc, #552]	; (204898 <main+0x354>)
  20466e:	f7ff fa87 	bl	203b80 <oled_puts>
  oled_setcursor(1,2);
  204672:	2102      	movs	r1, #2
  204674:	2001      	movs	r0, #1
  204676:	f7ff fad5 	bl	203c24 <oled_setcursor>
  oled_puts("Rescue Robot?");
  20467a:	4888      	ldr	r0, [pc, #544]	; (20489c <main+0x358>)
  20467c:	f7ff fa80 	bl	203b80 <oled_puts>
  HAL_Delay(1000);
  204680:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  204684:	f7fc fa0e 	bl	200aa4 <HAL_Delay>
  HAL_IWDG_Refresh(&hiwdg);
  204688:	4885      	ldr	r0, [pc, #532]	; (2048a0 <main+0x35c>)
  20468a:	f7fd f85d 	bl	201748 <HAL_IWDG_Refresh>
  HAL_TIM_Base_Start_IT(&htim6);
  20468e:	4885      	ldr	r0, [pc, #532]	; (2048a4 <main+0x360>)
  204690:	f7fd fd96 	bl	2021c0 <HAL_TIM_Base_Start_IT>
  if (HAL_UART_Receive_DMA(&huart1, (uint8_t *)Rxbuf,(Servonumber+7+3)) != HAL_OK)
  204694:	220f      	movs	r2, #15
  204696:	4984      	ldr	r1, [pc, #528]	; (2048a8 <main+0x364>)
  204698:	4884      	ldr	r0, [pc, #528]	; (2048ac <main+0x368>)
  20469a:	f7fe f98d 	bl	2029b8 <HAL_UART_Receive_DMA>
  20469e:	b138      	cbz	r0, 2046b0 <main+0x16c>
       Error_Handler();
  2046a0:	f7ff fb10 	bl	203cc4 <_Error_Handler.constprop.0>
  		beep(10,30,30);
  2046a4:	221e      	movs	r2, #30
  2046a6:	200a      	movs	r0, #10
  2046a8:	4611      	mov	r1, r2
  2046aa:	f7ff f8c7 	bl	20383c <beep>
  2046ae:	e7b6      	b.n	20461e <main+0xda>
    if(HAL_TIM_Encoder_Init(&htim5, &sConfig) != HAL_OK)
  2046b0:	497f      	ldr	r1, [pc, #508]	; (2048b0 <main+0x36c>)
  2046b2:	4880      	ldr	r0, [pc, #512]	; (2048b4 <main+0x370>)
  2046b4:	f7fd ff02 	bl	2024bc <HAL_TIM_Encoder_Init>
  2046b8:	2800      	cmp	r0, #0
  2046ba:	d1f1      	bne.n	2046a0 <main+0x15c>
    HAL_TIM_Encoder_Start(&htim5, TIM_CHANNEL_ALL);
  2046bc:	213c      	movs	r1, #60	; 0x3c
  2046be:	487d      	ldr	r0, [pc, #500]	; (2048b4 <main+0x370>)
  2046c0:	f7fd fd89 	bl	2021d6 <HAL_TIM_Encoder_Start>
    TIM5->CNT=3000;
  2046c4:	f640 34b8 	movw	r4, #3000	; 0xbb8
  2046c8:	4b7b      	ldr	r3, [pc, #492]	; (2048b8 <main+0x374>)
    if(HAL_TIM_Encoder_Init(&htim8, &sConfig) != HAL_OK)
  2046ca:	4979      	ldr	r1, [pc, #484]	; (2048b0 <main+0x36c>)
    TIM5->CNT=3000;
  2046cc:	625c      	str	r4, [r3, #36]	; 0x24
    if(HAL_TIM_Encoder_Init(&htim8, &sConfig) != HAL_OK)
  2046ce:	487b      	ldr	r0, [pc, #492]	; (2048bc <main+0x378>)
  2046d0:	f7fd fef4 	bl	2024bc <HAL_TIM_Encoder_Init>
  2046d4:	2800      	cmp	r0, #0
  2046d6:	d1e3      	bne.n	2046a0 <main+0x15c>
    TIM8->CNT=3000;
  2046d8:	4e79      	ldr	r6, [pc, #484]	; (2048c0 <main+0x37c>)
    HAL_TIM_Encoder_Start(&htim8, TIM_CHANNEL_ALL);
  2046da:	213c      	movs	r1, #60	; 0x3c
  2046dc:	4877      	ldr	r0, [pc, #476]	; (2048bc <main+0x378>)
  2046de:	f7fd fd7a 	bl	2021d6 <HAL_TIM_Encoder_Start>
	  mode=HAL_GPIO_ReadPin(GPIOE,GPIO_PIN_0)+(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_5)*2)
  2046e2:	4d69      	ldr	r5, [pc, #420]	; (204888 <main+0x344>)
    TIM8->CNT=3000;
  2046e4:	6274      	str	r4, [r6, #36]	; 0x24
			  +(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_4)*4);
  2046e6:	f8df 81f4 	ldr.w	r8, [pc, #500]	; 2048dc <main+0x398>
    oled_clear();
  2046ea:	f7ff fa98 	bl	203c1e <oled_clear>
				HAL_GPIO_WritePin(GPIOC,GPIO_PIN_1,1);
  2046ee:	4f67      	ldr	r7, [pc, #412]	; (20488c <main+0x348>)
	HAL_IWDG_Refresh(&hiwdg);
  2046f0:	486b      	ldr	r0, [pc, #428]	; (2048a0 <main+0x35c>)
  2046f2:	f7fd f829 	bl	201748 <HAL_IWDG_Refresh>
	  mode=HAL_GPIO_ReadPin(GPIOE,GPIO_PIN_0)+(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_5)*2)
  2046f6:	2101      	movs	r1, #1
  2046f8:	4628      	mov	r0, r5
  2046fa:	f7fc fceb 	bl	2010d4 <HAL_GPIO_ReadPin>
			  +(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_4)*4);
  2046fe:	2110      	movs	r1, #16
	  mode=HAL_GPIO_ReadPin(GPIOE,GPIO_PIN_0)+(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_5)*2)
  204700:	4604      	mov	r4, r0
			  +(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_4)*4);
  204702:	4640      	mov	r0, r8
  204704:	f7fc fce6 	bl	2010d4 <HAL_GPIO_ReadPin>
  204708:	4681      	mov	r9, r0
	  mode=HAL_GPIO_ReadPin(GPIOE,GPIO_PIN_0)+(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_5)*2)
  20470a:	2120      	movs	r1, #32
  20470c:	4640      	mov	r0, r8
  20470e:	f7fc fce1 	bl	2010d4 <HAL_GPIO_ReadPin>
  204712:	4b6c      	ldr	r3, [pc, #432]	; (2048c4 <main+0x380>)
			  +(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_4)*4);
  204714:	eb00 0049 	add.w	r0, r0, r9, lsl #1
  204718:	eb04 0040 	add.w	r0, r4, r0, lsl #1
  20471c:	b2c0      	uxtb	r0, r0
	  mode=HAL_GPIO_ReadPin(GPIOE,GPIO_PIN_0)+(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_5)*2)
  20471e:	7018      	strb	r0, [r3, #0]
	  switch(mode){
  204720:	3801      	subs	r0, #1
  204722:	2805      	cmp	r0, #5
  204724:	f200 8355 	bhi.w	204dd2 <main+0x88e>
  204728:	e8df f010 	tbh	[pc, r0, lsl #1]
  20472c:	01e20006 	.word	0x01e20006
  204730:	02be0240 	.word	0x02be0240
  204734:	033702f9 	.word	0x033702f9
		  if(HAL_GPIO_ReadPin(GPIOD,GPIO_PIN_7)==1){
  204738:	2180      	movs	r1, #128	; 0x80
  20473a:	4863      	ldr	r0, [pc, #396]	; (2048c8 <main+0x384>)
  20473c:	f7fc fcca 	bl	2010d4 <HAL_GPIO_ReadPin>
  204740:	2801      	cmp	r0, #1
  204742:	4604      	mov	r4, r0
  204744:	f040 81b9 	bne.w	204aba <main+0x576>
			    oled_returnhome();
  204748:	f7ff fa7d 	bl	203c46 <oled_returnhome>
			    oled_puts("main_run select ");
  20474c:	485f      	ldr	r0, [pc, #380]	; (2048cc <main+0x388>)
  20474e:	f7ff fa17 	bl	203b80 <oled_puts>
			    oled_setcursor(1,0);
  204752:	2100      	movs	r1, #0
  204754:	4620      	mov	r0, r4
			    HAL_IWDG_Refresh(&hiwdg);
  204756:	f8df 9148 	ldr.w	r9, [pc, #328]	; 2048a0 <main+0x35c>
			    oled_setcursor(1,0);
  20475a:	f7ff fa63 	bl	203c24 <oled_setcursor>
			    oled_puts("start setting   ");
  20475e:	485c      	ldr	r0, [pc, #368]	; (2048d0 <main+0x38c>)
  204760:	f7ff fa0e 	bl	203b80 <oled_puts>
			    while(encordermotor1(0) && timeout<5000000){
  204764:	4c5b      	ldr	r4, [pc, #364]	; (2048d4 <main+0x390>)
			  HOUI_def=JY901_def_set();
  204766:	f7fe fd85 	bl	203274 <JY901_def_set>
  20476a:	4b5b      	ldr	r3, [pc, #364]	; (2048d8 <main+0x394>)
			    TIM5->CNT=30000;
  20476c:	4a52      	ldr	r2, [pc, #328]	; (2048b8 <main+0x374>)
			  HOUI_def=JY901_def_set();
  20476e:	8018      	strh	r0, [r3, #0]
			    TIM5->CNT=30000;
  204770:	f247 5330 	movw	r3, #30000	; 0x7530
  204774:	6253      	str	r3, [r2, #36]	; 0x24
			    TIM8->CNT=30000;
  204776:	6273      	str	r3, [r6, #36]	; 0x24
			    while(encordermotor1(0) && timeout<5000000){
  204778:	2000      	movs	r0, #0
  20477a:	f7fe fe51 	bl	203420 <encordermotor1>
  20477e:	b108      	cbz	r0, 204784 <main+0x240>
  204780:	3c01      	subs	r4, #1
  204782:	d16d      	bne.n	204860 <main+0x31c>
  204784:	4c53      	ldr	r4, [pc, #332]	; (2048d4 <main+0x390>)
			    HAL_IWDG_Refresh(&hiwdg);
  204786:	f8df 9118 	ldr.w	r9, [pc, #280]	; 2048a0 <main+0x35c>
			    while(encordermotor2(0) && timeout<5000000){
  20478a:	2000      	movs	r0, #0
  20478c:	f7fe ff0e 	bl	2035ac <encordermotor2>
  204790:	b108      	cbz	r0, 204796 <main+0x252>
  204792:	3c01      	subs	r4, #1
  204794:	d16b      	bne.n	20486e <main+0x32a>
			  while(TPIPConnect==0){
  204796:	f8df a148 	ldr.w	sl, [pc, #328]	; 2048e0 <main+0x39c>
				HAL_GPIO_WritePin(GPIOC,GPIO_PIN_15,0);
  20479a:	2200      	movs	r2, #0
  20479c:	f44f 4100 	mov.w	r1, #32768	; 0x8000
  2047a0:	4638      	mov	r0, r7
  2047a2:	46d1      	mov	r9, sl
  2047a4:	f7fc fc9c 	bl	2010e0 <HAL_GPIO_WritePin>
			  while(TPIPConnect==0){
  2047a8:	f89a 4000 	ldrb.w	r4, [sl]
  2047ac:	2c00      	cmp	r4, #0
  2047ae:	f000 809b 	beq.w	2048e8 <main+0x3a4>
			  	HAL_GPIO_WritePin(GPIOE,GPIO_PIN_2,1);
  2047b2:	2201      	movs	r2, #1
  2047b4:	2104      	movs	r1, #4
  2047b6:	4628      	mov	r0, r5
  2047b8:	f7fc fc92 	bl	2010e0 <HAL_GPIO_WritePin>
			  	HAL_Delay(50);
  2047bc:	2032      	movs	r0, #50	; 0x32
  2047be:	f7fc f971 	bl	200aa4 <HAL_Delay>
			  	HAL_GPIO_WritePin(GPIOE,GPIO_PIN_2,0);
  2047c2:	2200      	movs	r2, #0
  2047c4:	2104      	movs	r1, #4
  2047c6:	4628      	mov	r0, r5
  2047c8:	f7fc fc8a 	bl	2010e0 <HAL_GPIO_WritePin>
			  	HAL_Delay(50);
  2047cc:	2032      	movs	r0, #50	; 0x32
  2047ce:	f7fc f969 	bl	200aa4 <HAL_Delay>
			  	HAL_GPIO_WritePin(GPIOE,GPIO_PIN_2,1);
  2047d2:	2201      	movs	r2, #1
  2047d4:	2104      	movs	r1, #4
  2047d6:	4628      	mov	r0, r5
  2047d8:	f7fc fc82 	bl	2010e0 <HAL_GPIO_WritePin>
			  	HAL_Delay(50);
  2047dc:	2032      	movs	r0, #50	; 0x32
  2047de:	f7fc f961 	bl	200aa4 <HAL_Delay>
			  	HAL_GPIO_WritePin(GPIOE,GPIO_PIN_2,0);
  2047e2:	2200      	movs	r2, #0
  2047e4:	2104      	movs	r1, #4
  2047e6:	4628      	mov	r0, r5
  2047e8:	f7fc fc7a 	bl	2010e0 <HAL_GPIO_WritePin>
			  	HAL_Delay(50);
  2047ec:	2032      	movs	r0, #50	; 0x32
  2047ee:	f7fc f959 	bl	200aa4 <HAL_Delay>
			  	HAL_GPIO_WritePin(GPIOE,GPIO_PIN_2,1);
  2047f2:	2201      	movs	r2, #1
  2047f4:	2104      	movs	r1, #4
  2047f6:	4628      	mov	r0, r5
  2047f8:	f7fc fc72 	bl	2010e0 <HAL_GPIO_WritePin>
			  	HAL_Delay(50);
  2047fc:	2032      	movs	r0, #50	; 0x32
  2047fe:	f7fc f951 	bl	200aa4 <HAL_Delay>
			  	HAL_GPIO_WritePin(GPIOE,GPIO_PIN_2,0);
  204802:	2200      	movs	r2, #0
  204804:	2104      	movs	r1, #4
  204806:	4628      	mov	r0, r5
  204808:	f7fc fc6a 	bl	2010e0 <HAL_GPIO_WritePin>
			  	while(HAL_GPIO_ReadPin(GPIOD,GPIO_PIN_7)==1){
  20480c:	2180      	movs	r1, #128	; 0x80
  20480e:	482e      	ldr	r0, [pc, #184]	; (2048c8 <main+0x384>)
  204810:	f7fc fc60 	bl	2010d4 <HAL_GPIO_ReadPin>
  204814:	2801      	cmp	r0, #1
  204816:	4682      	mov	sl, r0
  204818:	f000 80cb 	beq.w	2049b2 <main+0x46e>
	  			motor_move(0,0,0,0,0);
  20481c:	2400      	movs	r4, #0
		  		HAL_GPIO_WritePin(GPIOB,GPIO_PIN_2,0);
  20481e:	2200      	movs	r2, #0
  204820:	2104      	movs	r1, #4
  204822:	4640      	mov	r0, r8
  204824:	f7fc fc5c 	bl	2010e0 <HAL_GPIO_WritePin>
	  			motor_move(0,0,0,0,0);
  204828:	4623      	mov	r3, r4
  20482a:	4622      	mov	r2, r4
  20482c:	4621      	mov	r1, r4
  20482e:	4620      	mov	r0, r4
  204830:	9400      	str	r4, [sp, #0]
  204832:	f000 fb75 	bl	204f20 <motor_move>
	  			servo(servotemp[0],servotemp[1],servotemp[2],servotemp[3],servotemp[4],
  204836:	f8df e0ac 	ldr.w	lr, [pc, #172]	; 2048e4 <main+0x3a0>
  20483a:	f9be 3006 	ldrsh.w	r3, [lr, #6]
  20483e:	f9be 2004 	ldrsh.w	r2, [lr, #4]
  204842:	f9be 1002 	ldrsh.w	r1, [lr, #2]
  204846:	f9be 0000 	ldrsh.w	r0, [lr]
  20484a:	9405      	str	r4, [sp, #20]
  20484c:	9404      	str	r4, [sp, #16]
  20484e:	9403      	str	r4, [sp, #12]
  204850:	9402      	str	r4, [sp, #8]
  204852:	9401      	str	r4, [sp, #4]
  204854:	f9be 4008 	ldrsh.w	r4, [lr, #8]
  204858:	9400      	str	r4, [sp, #0]
				servo(90,90,90,90,90,90,0,0,0,0);
  20485a:	f7fe fd4b 	bl	2032f4 <servo>
  20485e:	e13e      	b.n	204ade <main+0x59a>
			    	delayUs(1);
  204860:	2001      	movs	r0, #1
  204862:	f001 fe53 	bl	20650c <delayUs>
			    HAL_IWDG_Refresh(&hiwdg);
  204866:	4648      	mov	r0, r9
  204868:	f7fc ff6e 	bl	201748 <HAL_IWDG_Refresh>
  20486c:	e784      	b.n	204778 <main+0x234>
			    	delayUs(1);
  20486e:	2001      	movs	r0, #1
  204870:	f001 fe4c 	bl	20650c <delayUs>
			    HAL_IWDG_Refresh(&hiwdg);
  204874:	4648      	mov	r0, r9
  204876:	f7fc ff67 	bl	201748 <HAL_IWDG_Refresh>
  20487a:	e786      	b.n	20478a <main+0x246>
  20487c:	e000ed00 	.word	0xe000ed00
  204880:	00207131 	.word	0x00207131
  204884:	2000061c 	.word	0x2000061c
  204888:	40021000 	.word	0x40021000
  20488c:	40020800 	.word	0x40020800
  204890:	20000118 	.word	0x20000118
  204894:	200005a8 	.word	0x200005a8
  204898:	002075bf 	.word	0x002075bf
  20489c:	002075ce 	.word	0x002075ce
  2048a0:	20000168 	.word	0x20000168
  2048a4:	20000398 	.word	0x20000398
  2048a8:	2000019c 	.word	0x2000019c
  2048ac:	20000538 	.word	0x20000538
  2048b0:	200000a8 	.word	0x200000a8
  2048b4:	200002d8 	.word	0x200002d8
  2048b8:	40000c00 	.word	0x40000c00
  2048bc:	20000218 	.word	0x20000218
  2048c0:	40010400 	.word	0x40010400
  2048c4:	200001b4 	.word	0x200001b4
  2048c8:	40020c00 	.word	0x40020c00
  2048cc:	002075dc 	.word	0x002075dc
  2048d0:	002075ed 	.word	0x002075ed
  2048d4:	004c4b41 	.word	0x004c4b41
  2048d8:	20000178 	.word	0x20000178
  2048dc:	40020400 	.word	0x40020400
  2048e0:	2000003e 	.word	0x2000003e
  2048e4:	2000000a 	.word	0x2000000a
			  	motor_move(0,0,0,0,0);
  2048e8:	4623      	mov	r3, r4
  2048ea:	4622      	mov	r2, r4
  2048ec:	4621      	mov	r1, r4
  2048ee:	4620      	mov	r0, r4
  2048f0:	9400      	str	r4, [sp, #0]
  2048f2:	f000 fb15 	bl	204f20 <motor_move>
			    oled_returnhome();
  2048f6:	f7ff f9a6 	bl	203c46 <oled_returnhome>
			    oled_puts("main_run select ");
  2048fa:	48ca      	ldr	r0, [pc, #808]	; (204c24 <main+0x6e0>)
  2048fc:	f7ff f940 	bl	203b80 <oled_puts>
			    oled_setcursor(1,0);
  204900:	4621      	mov	r1, r4
  204902:	2001      	movs	r0, #1
				xprintf(" 0=%d",Rxbuf[0]);
  204904:	4cc8      	ldr	r4, [pc, #800]	; (204c28 <main+0x6e4>)
			    oled_setcursor(1,0);
  204906:	f7ff f98d 	bl	203c24 <oled_setcursor>
			    oled_puts("waiting for TPIP");
  20490a:	48c8      	ldr	r0, [pc, #800]	; (204c2c <main+0x6e8>)
  20490c:	f7ff f938 	bl	203b80 <oled_puts>
				xprintf(" 0=%d",Rxbuf[0]);
  204910:	7821      	ldrb	r1, [r4, #0]
  204912:	48c7      	ldr	r0, [pc, #796]	; (204c30 <main+0x6ec>)
  204914:	f002 fd16 	bl	207344 <xprintf>
				xprintf(" 1=%d",Rxbuf[1]);
  204918:	7861      	ldrb	r1, [r4, #1]
  20491a:	48c6      	ldr	r0, [pc, #792]	; (204c34 <main+0x6f0>)
  20491c:	f002 fd12 	bl	207344 <xprintf>
				xprintf(" 2=%d",Rxbuf[2]);
  204920:	78a1      	ldrb	r1, [r4, #2]
  204922:	48c5      	ldr	r0, [pc, #788]	; (204c38 <main+0x6f4>)
  204924:	f002 fd0e 	bl	207344 <xprintf>
				xprintf(" 3=%d",Rxbuf[3]);
  204928:	78e1      	ldrb	r1, [r4, #3]
  20492a:	48c4      	ldr	r0, [pc, #784]	; (204c3c <main+0x6f8>)
  20492c:	f002 fd0a 	bl	207344 <xprintf>
				xprintf(" 4=%d",Rxbuf[4]);
  204930:	7921      	ldrb	r1, [r4, #4]
  204932:	48c3      	ldr	r0, [pc, #780]	; (204c40 <main+0x6fc>)
  204934:	f002 fd06 	bl	207344 <xprintf>
				xprintf(" 5=%d",Rxbuf[5]);
  204938:	7961      	ldrb	r1, [r4, #5]
  20493a:	48c2      	ldr	r0, [pc, #776]	; (204c44 <main+0x700>)
  20493c:	f002 fd02 	bl	207344 <xprintf>
				xprintf(" 6=%d",Rxbuf[6]);
  204940:	79a1      	ldrb	r1, [r4, #6]
  204942:	48c1      	ldr	r0, [pc, #772]	; (204c48 <main+0x704>)
  204944:	f002 fcfe 	bl	207344 <xprintf>
				xprintf(" 7=%d",Rxbuf[7]);
  204948:	79e1      	ldrb	r1, [r4, #7]
  20494a:	48c0      	ldr	r0, [pc, #768]	; (204c4c <main+0x708>)
  20494c:	f002 fcfa 	bl	207344 <xprintf>
				xprintf(" 8=%d",Rxbuf[8]);
  204950:	7a21      	ldrb	r1, [r4, #8]
  204952:	48bf      	ldr	r0, [pc, #764]	; (204c50 <main+0x70c>)
  204954:	f002 fcf6 	bl	207344 <xprintf>
				xprintf(" 9=%d",Rxbuf[9]);
  204958:	7a61      	ldrb	r1, [r4, #9]
  20495a:	48be      	ldr	r0, [pc, #760]	; (204c54 <main+0x710>)
  20495c:	f002 fcf2 	bl	207344 <xprintf>
				xprintf(" 10=%d",Rxbuf[10]);
  204960:	7aa1      	ldrb	r1, [r4, #10]
  204962:	48bd      	ldr	r0, [pc, #756]	; (204c58 <main+0x714>)
  204964:	f002 fcee 	bl	207344 <xprintf>
				xprintf(" 11=%d",Rxbuf[11]);
  204968:	7ae1      	ldrb	r1, [r4, #11]
  20496a:	48bc      	ldr	r0, [pc, #752]	; (204c5c <main+0x718>)
  20496c:	f002 fcea 	bl	207344 <xprintf>
				xprintf(" 12=%d",Rxbuf[12]);
  204970:	7b21      	ldrb	r1, [r4, #12]
  204972:	48bb      	ldr	r0, [pc, #748]	; (204c60 <main+0x71c>)
  204974:	f002 fce6 	bl	207344 <xprintf>
				xprintf(" 13=%d",Rxbuf[13]);
  204978:	7b61      	ldrb	r1, [r4, #13]
  20497a:	48ba      	ldr	r0, [pc, #744]	; (204c64 <main+0x720>)
  20497c:	f002 fce2 	bl	207344 <xprintf>
				xprintf(" 14=%d\r\n",Rxbuf[14]);
  204980:	7ba1      	ldrb	r1, [r4, #14]
  204982:	48b9      	ldr	r0, [pc, #740]	; (204c68 <main+0x724>)
  204984:	f002 fcde 	bl	207344 <xprintf>
			  	if(HAL_GPIO_ReadPin(GPIOD,GPIO_PIN_7)==0){goto mofu;}
  204988:	2180      	movs	r1, #128	; 0x80
  20498a:	48b8      	ldr	r0, [pc, #736]	; (204c6c <main+0x728>)
  20498c:	f7fc fba2 	bl	2010d4 <HAL_GPIO_ReadPin>
  204990:	2800      	cmp	r0, #0
  204992:	f43f aeb0 	beq.w	2046f6 <main+0x1b2>
			  	HAL_GPIO_WritePin(GPIOC,GPIO_PIN_1,1);
  204996:	2201      	movs	r2, #1
  204998:	2102      	movs	r1, #2
  20499a:	4638      	mov	r0, r7
  20499c:	f7fc fba0 	bl	2010e0 <HAL_GPIO_WritePin>
			    HAL_IWDG_Refresh(&hiwdg);
  2049a0:	48b3      	ldr	r0, [pc, #716]	; (204c70 <main+0x72c>)
  2049a2:	f7fc fed1 	bl	201748 <HAL_IWDG_Refresh>
			  	HAL_GPIO_TogglePin(GPIOD,GPIO_PIN_10);
  2049a6:	f44f 6180 	mov.w	r1, #1024	; 0x400
  2049aa:	48b0      	ldr	r0, [pc, #704]	; (204c6c <main+0x728>)
  2049ac:	f7fc fb9d 	bl	2010ea <HAL_GPIO_TogglePin>
  2049b0:	e6fa      	b.n	2047a8 <main+0x264>
			  		if(TPIPConnect==1){
  2049b2:	f899 4000 	ldrb.w	r4, [r9]
  2049b6:	2c01      	cmp	r4, #1
  2049b8:	d12f      	bne.n	204a1a <main+0x4d6>
			  		if(data[Servonumber+8]%11==0){
  2049ba:	f8df a2d8 	ldr.w	sl, [pc, #728]	; 204c94 <main+0x750>
			  		HAL_GPIO_WritePin(GPIOC,GPIO_PIN_1,1);
  2049be:	4622      	mov	r2, r4
  2049c0:	2102      	movs	r1, #2
  2049c2:	4638      	mov	r0, r7
  2049c4:	f7fc fb8c 	bl	2010e0 <HAL_GPIO_WritePin>
			  		main_run();
  2049c8:	f7ff fa16 	bl	203df8 <main_run>
			  		if(data[Servonumber+8]%11==0){
  2049cc:	f89a 100d 	ldrb.w	r1, [sl, #13]
  2049d0:	220b      	movs	r2, #11
  2049d2:	fbb1 f3f2 	udiv	r3, r1, r2
  2049d6:	fb02 1313 	mls	r3, r2, r3, r1
  2049da:	f013 0fff 	tst.w	r3, #255	; 0xff
  2049de:	d104      	bne.n	2049ea <main+0x4a6>
			  		HAL_GPIO_WritePin(GPIOB,GPIO_PIN_2,1);
  2049e0:	4622      	mov	r2, r4
  2049e2:	2104      	movs	r1, #4
  2049e4:	4640      	mov	r0, r8
  2049e6:	f7fc fb7b 	bl	2010e0 <HAL_GPIO_WritePin>
			  		if(data[Servonumber+8]%11==5){
  2049ea:	f89a 100d 	ldrb.w	r1, [sl, #13]
  2049ee:	220b      	movs	r2, #11
  2049f0:	fbb1 f3f2 	udiv	r3, r1, r2
  2049f4:	fb02 1313 	mls	r3, r2, r3, r1
  2049f8:	b2db      	uxtb	r3, r3
  2049fa:	2b05      	cmp	r3, #5
  2049fc:	d104      	bne.n	204a08 <main+0x4c4>
			  		HAL_GPIO_WritePin(GPIOB,GPIO_PIN_2,0);
  2049fe:	2200      	movs	r2, #0
  204a00:	2104      	movs	r1, #4
  204a02:	4640      	mov	r0, r8
  204a04:	f7fc fb6c 	bl	2010e0 <HAL_GPIO_WritePin>
			  	  HAL_IWDG_Refresh(&hiwdg);
  204a08:	4899      	ldr	r0, [pc, #612]	; (204c70 <main+0x72c>)
  204a0a:	f7fc fe9d 	bl	201748 <HAL_IWDG_Refresh>
			  	  HAL_GPIO_TogglePin(GPIOD,GPIO_PIN_10);
  204a0e:	f44f 6180 	mov.w	r1, #1024	; 0x400
  204a12:	4896      	ldr	r0, [pc, #600]	; (204c6c <main+0x728>)
  204a14:	f7fc fb69 	bl	2010ea <HAL_GPIO_TogglePin>
  204a18:	e6f8      	b.n	20480c <main+0x2c8>
			  			motor_move(0,0,0,0,0);
  204a1a:	2400      	movs	r4, #0
			  			HAL_GPIO_WritePin(GPIOC,GPIO_PIN_1,0);
  204a1c:	2200      	movs	r2, #0
  204a1e:	2102      	movs	r1, #2
  204a20:	4638      	mov	r0, r7
  204a22:	f7fc fb5d 	bl	2010e0 <HAL_GPIO_WritePin>
			  			motor_move(0,0,0,0,0);
  204a26:	4623      	mov	r3, r4
  204a28:	4622      	mov	r2, r4
  204a2a:	4621      	mov	r1, r4
  204a2c:	4620      	mov	r0, r4
  204a2e:	9400      	str	r4, [sp, #0]
  204a30:	f000 fa76 	bl	204f20 <motor_move>
			  			servo(servotemp[0],servotemp[1],servotemp[2],servotemp[3],servotemp[4],
  204a34:	f8df e260 	ldr.w	lr, [pc, #608]	; 204c98 <main+0x754>
			  				xprintf(" %d)%d",i,Rxbuf[i]);
  204a38:	f8df b1ec 	ldr.w	fp, [pc, #492]	; 204c28 <main+0x6e4>
			  			servo(servotemp[0],servotemp[1],servotemp[2],servotemp[3],servotemp[4],
  204a3c:	f9be 3006 	ldrsh.w	r3, [lr, #6]
  204a40:	f9be 2004 	ldrsh.w	r2, [lr, #4]
  204a44:	f9be 1002 	ldrsh.w	r1, [lr, #2]
  204a48:	f9be 0000 	ldrsh.w	r0, [lr]
  204a4c:	9405      	str	r4, [sp, #20]
  204a4e:	9404      	str	r4, [sp, #16]
  204a50:	9403      	str	r4, [sp, #12]
  204a52:	9402      	str	r4, [sp, #8]
  204a54:	9401      	str	r4, [sp, #4]
  204a56:	f9be e008 	ldrsh.w	lr, [lr, #8]
  204a5a:	f8cd e000 	str.w	lr, [sp]
  204a5e:	f7fe fc49 	bl	2032f4 <servo>
			  			oled_returnhome();
  204a62:	f7ff f8f0 	bl	203c46 <oled_returnhome>
			  			oled_puts("main_run select");
  204a66:	4883      	ldr	r0, [pc, #524]	; (204c74 <main+0x730>)
  204a68:	f7ff f88a 	bl	203b80 <oled_puts>
			  			oled_setcursor(1,0);
  204a6c:	4650      	mov	r0, sl
  204a6e:	4621      	mov	r1, r4
			  				xprintf(" %d)%d",i,Rxbuf[i]);
  204a70:	f8df a228 	ldr.w	sl, [pc, #552]	; 204c9c <main+0x758>
			  			oled_setcursor(1,0);
  204a74:	f7ff f8d6 	bl	203c24 <oled_setcursor>
			  			oled_puts("lost connection!");
  204a78:	487f      	ldr	r0, [pc, #508]	; (204c78 <main+0x734>)
  204a7a:	f7ff f881 	bl	203b80 <oled_puts>
			  				xprintf(" %d)%d",i,Rxbuf[i]);
  204a7e:	f81b 2004 	ldrb.w	r2, [fp, r4]
  204a82:	4621      	mov	r1, r4
			  			for(int i=0;i<(Servonumber+10);i++){
  204a84:	3401      	adds	r4, #1
			  				xprintf(" %d)%d",i,Rxbuf[i]);
  204a86:	4650      	mov	r0, sl
  204a88:	f002 fc5c 	bl	207344 <xprintf>
			  			for(int i=0;i<(Servonumber+10);i++){
  204a8c:	2c0f      	cmp	r4, #15
  204a8e:	d1f6      	bne.n	204a7e <main+0x53a>
			  			xprintf("\r\n");
  204a90:	487a      	ldr	r0, [pc, #488]	; (204c7c <main+0x738>)
  204a92:	f002 fc57 	bl	207344 <xprintf>
			  		 HAL_GPIO_WritePin(GPIOE,GPIO_PIN_2,1);
  204a96:	2201      	movs	r2, #1
  204a98:	2104      	movs	r1, #4
  204a9a:	4628      	mov	r0, r5
  204a9c:	f7fc fb20 	bl	2010e0 <HAL_GPIO_WritePin>
			  		 HAL_Delay(300);
  204aa0:	f44f 7096 	mov.w	r0, #300	; 0x12c
  204aa4:	f7fb fffe 	bl	200aa4 <HAL_Delay>
			  		 HAL_GPIO_WritePin(GPIOE,GPIO_PIN_2,0);
  204aa8:	4628      	mov	r0, r5
  204aaa:	2200      	movs	r2, #0
  204aac:	2104      	movs	r1, #4
  204aae:	f7fc fb17 	bl	2010e0 <HAL_GPIO_WritePin>
			  		 HAL_Delay(100);
  204ab2:	2064      	movs	r0, #100	; 0x64
  204ab4:	f7fb fff6 	bl	200aa4 <HAL_Delay>
  204ab8:	e7a6      	b.n	204a08 <main+0x4c4>
			  oled_returnhome();
  204aba:	f7ff f8c4 	bl	203c46 <oled_returnhome>
			  oled_puts("main_run select");
  204abe:	486d      	ldr	r0, [pc, #436]	; (204c74 <main+0x730>)
  204ac0:	f7ff f85e 	bl	203b80 <oled_puts>
			  oled_setcursor(1,0);
  204ac4:	2100      	movs	r1, #0
  204ac6:	2001      	movs	r0, #1
  204ac8:	f7ff f8ac 	bl	203c24 <oled_setcursor>
			  oled_puts("OK?     waiting ");
  204acc:	486c      	ldr	r0, [pc, #432]	; (204c80 <main+0x73c>)
  204ace:	f7ff f857 	bl	203b80 <oled_puts>
			  HAL_Delay(5);
  204ad2:	2005      	movs	r0, #5
  204ad4:	f7fb ffe6 	bl	200aa4 <HAL_Delay>
			  HAL_IWDG_Refresh(&hiwdg);
  204ad8:	4865      	ldr	r0, [pc, #404]	; (204c70 <main+0x72c>)
  204ada:	f7fc fe35 	bl	201748 <HAL_IWDG_Refresh>
	  HAL_IWDG_Refresh(&hiwdg);
  204ade:	4864      	ldr	r0, [pc, #400]	; (204c70 <main+0x72c>)
  204ae0:	f7fc fe32 	bl	201748 <HAL_IWDG_Refresh>
	  HAL_GPIO_TogglePin(GPIOD,GPIO_PIN_10);
  204ae4:	f44f 6180 	mov.w	r1, #1024	; 0x400
  204ae8:	4860      	ldr	r0, [pc, #384]	; (204c6c <main+0x728>)
  204aea:	f7fc fafe 	bl	2010ea <HAL_GPIO_TogglePin>
	  mofu:
  204aee:	e602      	b.n	2046f6 <main+0x1b2>
			if(HAL_GPIO_ReadPin(GPIOD,GPIO_PIN_7)==1){
  204af0:	2180      	movs	r1, #128	; 0x80
  204af2:	485e      	ldr	r0, [pc, #376]	; (204c6c <main+0x728>)
  204af4:	f7fc faee 	bl	2010d4 <HAL_GPIO_ReadPin>
  204af8:	2801      	cmp	r0, #1
  204afa:	d144      	bne.n	204b86 <main+0x642>
				HOUI_def=JY901_def_set();
  204afc:	f7fe fbba 	bl	203274 <JY901_def_set>
  204b00:	4b60      	ldr	r3, [pc, #384]	; (204c84 <main+0x740>)
			    TIM5->CNT=30000;
  204b02:	4a61      	ldr	r2, [pc, #388]	; (204c88 <main+0x744>)
				HAL_GPIO_WritePin(GPIOC,GPIO_PIN_1,0);
  204b04:	2102      	movs	r1, #2
				HOUI_def=JY901_def_set();
  204b06:	8018      	strh	r0, [r3, #0]
			    TIM5->CNT=30000;
  204b08:	f247 5330 	movw	r3, #30000	; 0x7530
				while(HAL_GPIO_ReadPin(GPIOD,GPIO_PIN_7)==1){
  204b0c:	f8df 915c 	ldr.w	r9, [pc, #348]	; 204c6c <main+0x728>
				HAL_GPIO_WritePin(GPIOC,GPIO_PIN_1,0);
  204b10:	4638      	mov	r0, r7
				oled_puts("Comu test select");
  204b12:	f8df a178 	ldr.w	sl, [pc, #376]	; 204c8c <main+0x748>
				oled_puts("Runnning         ");
  204b16:	f8df b188 	ldr.w	fp, [pc, #392]	; 204ca0 <main+0x75c>
			    TIM5->CNT=30000;
  204b1a:	6253      	str	r3, [r2, #36]	; 0x24
				HAL_GPIO_WritePin(GPIOC,GPIO_PIN_1,0);
  204b1c:	2200      	movs	r2, #0
			    TIM8->CNT=30000;
  204b1e:	6273      	str	r3, [r6, #36]	; 0x24
				HAL_GPIO_WritePin(GPIOC,GPIO_PIN_1,0);
  204b20:	f7fc fade 	bl	2010e0 <HAL_GPIO_WritePin>
				while(HAL_GPIO_ReadPin(GPIOD,GPIO_PIN_7)==1){
  204b24:	2180      	movs	r1, #128	; 0x80
  204b26:	4648      	mov	r0, r9
  204b28:	f7fc fad4 	bl	2010d4 <HAL_GPIO_ReadPin>
  204b2c:	2801      	cmp	r0, #1
  204b2e:	4604      	mov	r4, r0
  204b30:	d012      	beq.n	204b58 <main+0x614>
				motor_move(0,0,0,0,0);
  204b32:	2400      	movs	r4, #0
  204b34:	4623      	mov	r3, r4
  204b36:	4622      	mov	r2, r4
  204b38:	4621      	mov	r1, r4
  204b3a:	4620      	mov	r0, r4
  204b3c:	9400      	str	r4, [sp, #0]
  204b3e:	f000 f9ef 	bl	204f20 <motor_move>
				servo(90,90,90,90,90,90,0,0,0,0);
  204b42:	235a      	movs	r3, #90	; 0x5a
  204b44:	9405      	str	r4, [sp, #20]
  204b46:	9404      	str	r4, [sp, #16]
  204b48:	461a      	mov	r2, r3
  204b4a:	9403      	str	r4, [sp, #12]
  204b4c:	4619      	mov	r1, r3
  204b4e:	9402      	str	r4, [sp, #8]
  204b50:	4618      	mov	r0, r3
  204b52:	9301      	str	r3, [sp, #4]
  204b54:	9300      	str	r3, [sp, #0]
  204b56:	e680      	b.n	20485a <main+0x316>
				oled_returnhome();
  204b58:	f7ff f875 	bl	203c46 <oled_returnhome>
				oled_puts("Comu test select");
  204b5c:	4650      	mov	r0, sl
  204b5e:	f7ff f80f 	bl	203b80 <oled_puts>
				oled_setcursor(1,0);
  204b62:	2100      	movs	r1, #0
  204b64:	4620      	mov	r0, r4
  204b66:	f7ff f85d 	bl	203c24 <oled_setcursor>
				oled_puts("Runnning         ");
  204b6a:	4658      	mov	r0, fp
  204b6c:	f7ff f808 	bl	203b80 <oled_puts>
				comu_test();
  204b70:	f7ff fa7a 	bl	204068 <comu_test>
				HAL_IWDG_Refresh(&hiwdg);
  204b74:	483e      	ldr	r0, [pc, #248]	; (204c70 <main+0x72c>)
  204b76:	f7fc fde7 	bl	201748 <HAL_IWDG_Refresh>
				HAL_GPIO_TogglePin(GPIOD,GPIO_PIN_10);
  204b7a:	f44f 6180 	mov.w	r1, #1024	; 0x400
  204b7e:	4648      	mov	r0, r9
  204b80:	f7fc fab3 	bl	2010ea <HAL_GPIO_TogglePin>
  204b84:	e7ce      	b.n	204b24 <main+0x5e0>
				oled_returnhome();
  204b86:	f7ff f85e 	bl	203c46 <oled_returnhome>
				oled_puts("Comu test select");
  204b8a:	4840      	ldr	r0, [pc, #256]	; (204c8c <main+0x748>)
				oled_puts("demo mode select");
  204b8c:	f7fe fff8 	bl	203b80 <oled_puts>
				oled_setcursor(1,0);
  204b90:	2001      	movs	r0, #1
  204b92:	2100      	movs	r1, #0
  204b94:	f7ff f846 	bl	203c24 <oled_setcursor>
				oled_puts("OK?     waiting ");
  204b98:	4839      	ldr	r0, [pc, #228]	; (204c80 <main+0x73c>)
  204b9a:	f7fe fff1 	bl	203b80 <oled_puts>
			  HAL_IWDG_Refresh(&hiwdg);
  204b9e:	4834      	ldr	r0, [pc, #208]	; (204c70 <main+0x72c>)
  204ba0:	f7fc fdd2 	bl	201748 <HAL_IWDG_Refresh>
		   HAL_Delay(5);
  204ba4:	2005      	movs	r0, #5
  204ba6:	f7fb ff7d 	bl	200aa4 <HAL_Delay>
	  break;
  204baa:	e798      	b.n	204ade <main+0x59a>
		  if(HAL_GPIO_ReadPin(GPIOD,GPIO_PIN_7)==1){
  204bac:	2180      	movs	r1, #128	; 0x80
  204bae:	482f      	ldr	r0, [pc, #188]	; (204c6c <main+0x728>)
  204bb0:	f7fc fa90 	bl	2010d4 <HAL_GPIO_ReadPin>
  204bb4:	2801      	cmp	r0, #1
  204bb6:	d131      	bne.n	204c1c <main+0x6d8>
			  HOUI_def=JY901_def_set();
  204bb8:	f7fe fb5c 	bl	203274 <JY901_def_set>
  204bbc:	4b31      	ldr	r3, [pc, #196]	; (204c84 <main+0x740>)
			    TIM5->CNT=30000;
  204bbe:	4a32      	ldr	r2, [pc, #200]	; (204c88 <main+0x744>)
			  HAL_GPIO_WritePin(GPIOC,GPIO_PIN_1,0);
  204bc0:	2102      	movs	r1, #2
			  HOUI_def=JY901_def_set();
  204bc2:	8018      	strh	r0, [r3, #0]
			    TIM5->CNT=30000;
  204bc4:	f247 5330 	movw	r3, #30000	; 0x7530
			  	while(HAL_GPIO_ReadPin(GPIOD,GPIO_PIN_7)==1){
  204bc8:	f8df 90a0 	ldr.w	r9, [pc, #160]	; 204c6c <main+0x728>
			  HAL_GPIO_WritePin(GPIOC,GPIO_PIN_1,0);
  204bcc:	4638      	mov	r0, r7
			  	oled_puts("sens_test select");
  204bce:	f8df a0c0 	ldr.w	sl, [pc, #192]	; 204c90 <main+0x74c>
			  	oled_puts("Running          ");
  204bd2:	f8df b0d0 	ldr.w	fp, [pc, #208]	; 204ca4 <main+0x760>
			    TIM5->CNT=30000;
  204bd6:	6253      	str	r3, [r2, #36]	; 0x24
			  HAL_GPIO_WritePin(GPIOC,GPIO_PIN_1,0);
  204bd8:	2200      	movs	r2, #0
			    TIM8->CNT=30000;
  204bda:	6273      	str	r3, [r6, #36]	; 0x24
			  HAL_GPIO_WritePin(GPIOC,GPIO_PIN_1,0);
  204bdc:	f7fc fa80 	bl	2010e0 <HAL_GPIO_WritePin>
			  	while(HAL_GPIO_ReadPin(GPIOD,GPIO_PIN_7)==1){
  204be0:	2180      	movs	r1, #128	; 0x80
  204be2:	4648      	mov	r0, r9
  204be4:	f7fc fa76 	bl	2010d4 <HAL_GPIO_ReadPin>
  204be8:	2801      	cmp	r0, #1
  204bea:	4604      	mov	r4, r0
  204bec:	d1a1      	bne.n	204b32 <main+0x5ee>
			  	oled_returnhome();
  204bee:	f7ff f82a 	bl	203c46 <oled_returnhome>
			  	oled_puts("sens_test select");
  204bf2:	4650      	mov	r0, sl
  204bf4:	f7fe ffc4 	bl	203b80 <oled_puts>
			  	oled_setcursor(1,0);
  204bf8:	2100      	movs	r1, #0
  204bfa:	4620      	mov	r0, r4
  204bfc:	f7ff f812 	bl	203c24 <oled_setcursor>
			  	oled_puts("Running          ");
  204c00:	4658      	mov	r0, fp
  204c02:	f7fe ffbd 	bl	203b80 <oled_puts>
				sens_test();
  204c06:	f7ff f9ab 	bl	203f60 <sens_test>
				  HAL_IWDG_Refresh(&hiwdg);
  204c0a:	4819      	ldr	r0, [pc, #100]	; (204c70 <main+0x72c>)
  204c0c:	f7fc fd9c 	bl	201748 <HAL_IWDG_Refresh>
			  HAL_GPIO_TogglePin(GPIOD,GPIO_PIN_10);
  204c10:	f44f 6180 	mov.w	r1, #1024	; 0x400
  204c14:	4648      	mov	r0, r9
  204c16:	f7fc fa68 	bl	2010ea <HAL_GPIO_TogglePin>
  204c1a:	e7e1      	b.n	204be0 <main+0x69c>
				oled_returnhome();
  204c1c:	f7ff f813 	bl	203c46 <oled_returnhome>
				oled_puts("sens_test select");
  204c20:	481b      	ldr	r0, [pc, #108]	; (204c90 <main+0x74c>)
  204c22:	e7b3      	b.n	204b8c <main+0x648>
  204c24:	002075dc 	.word	0x002075dc
  204c28:	2000019c 	.word	0x2000019c
  204c2c:	002075fe 	.word	0x002075fe
  204c30:	0020760f 	.word	0x0020760f
  204c34:	00207615 	.word	0x00207615
  204c38:	0020761b 	.word	0x0020761b
  204c3c:	00207621 	.word	0x00207621
  204c40:	00207627 	.word	0x00207627
  204c44:	0020762d 	.word	0x0020762d
  204c48:	00207633 	.word	0x00207633
  204c4c:	00207639 	.word	0x00207639
  204c50:	0020763f 	.word	0x0020763f
  204c54:	00207645 	.word	0x00207645
  204c58:	0020764b 	.word	0x0020764b
  204c5c:	00207652 	.word	0x00207652
  204c60:	00207659 	.word	0x00207659
  204c64:	00207660 	.word	0x00207660
  204c68:	00207667 	.word	0x00207667
  204c6c:	40020c00 	.word	0x40020c00
  204c70:	20000168 	.word	0x20000168
  204c74:	00207741 	.word	0x00207741
  204c78:	00207670 	.word	0x00207670
  204c7c:	00207546 	.word	0x00207546
  204c80:	00207688 	.word	0x00207688
  204c84:	20000178 	.word	0x20000178
  204c88:	40000c00 	.word	0x40000c00
  204c8c:	00207699 	.word	0x00207699
  204c90:	002076bc 	.word	0x002076bc
  204c94:	200001ed 	.word	0x200001ed
  204c98:	2000000a 	.word	0x2000000a
  204c9c:	00207681 	.word	0x00207681
  204ca0:	002076aa 	.word	0x002076aa
  204ca4:	002076cd 	.word	0x002076cd
		  if(HAL_GPIO_ReadPin(GPIOD,GPIO_PIN_7)==1){
  204ca8:	2180      	movs	r1, #128	; 0x80
  204caa:	485a      	ldr	r0, [pc, #360]	; (204e14 <main+0x8d0>)
  204cac:	f7fc fa12 	bl	2010d4 <HAL_GPIO_ReadPin>
  204cb0:	2801      	cmp	r0, #1
  204cb2:	d130      	bne.n	204d16 <main+0x7d2>
			  HOUI_def=JY901_def_set();
  204cb4:	f7fe fade 	bl	203274 <JY901_def_set>
  204cb8:	4b57      	ldr	r3, [pc, #348]	; (204e18 <main+0x8d4>)
			    TIM5->CNT=30000;
  204cba:	4a58      	ldr	r2, [pc, #352]	; (204e1c <main+0x8d8>)
			  HOUI_def=JY901_def_set();
  204cbc:	8018      	strh	r0, [r3, #0]
			    TIM5->CNT=30000;
  204cbe:	f247 5330 	movw	r3, #30000	; 0x7530
			    while(HAL_GPIO_ReadPin(GPIOD,GPIO_PIN_7)==1){
  204cc2:	f8df 9150 	ldr.w	r9, [pc, #336]	; 204e14 <main+0x8d0>
			    	oled_puts("test mode select");
  204cc6:	f8df a160 	ldr.w	sl, [pc, #352]	; 204e28 <main+0x8e4>
			    TIM5->CNT=30000;
  204cca:	6253      	str	r3, [r2, #36]	; 0x24
			    TIM8->CNT=30000;
  204ccc:	6273      	str	r3, [r6, #36]	; 0x24
			    while(HAL_GPIO_ReadPin(GPIOD,GPIO_PIN_7)==1){
  204cce:	2180      	movs	r1, #128	; 0x80
  204cd0:	4648      	mov	r0, r9
  204cd2:	f7fc f9ff 	bl	2010d4 <HAL_GPIO_ReadPin>
  204cd6:	2801      	cmp	r0, #1
  204cd8:	4604      	mov	r4, r0
  204cda:	f47f af2a 	bne.w	204b32 <main+0x5ee>
			    	HAL_GPIO_WritePin(GPIOC,GPIO_PIN_1,1);
  204cde:	4622      	mov	r2, r4
  204ce0:	2102      	movs	r1, #2
  204ce2:	4638      	mov	r0, r7
  204ce4:	f7fc f9fc 	bl	2010e0 <HAL_GPIO_WritePin>
			    	oled_returnhome();
  204ce8:	f7fe ffad 	bl	203c46 <oled_returnhome>
			    	oled_puts("test mode select");
  204cec:	4650      	mov	r0, sl
  204cee:	f7fe ff47 	bl	203b80 <oled_puts>
			    	oled_setcursor(1,0);
  204cf2:	2100      	movs	r1, #0
  204cf4:	4620      	mov	r0, r4
  204cf6:	f7fe ff95 	bl	203c24 <oled_setcursor>
			    	oled_puts("Ruuning         ");
  204cfa:	4849      	ldr	r0, [pc, #292]	; (204e20 <main+0x8dc>)
  204cfc:	f7fe ff40 	bl	203b80 <oled_puts>
			    	  HAL_IWDG_Refresh(&hiwdg);
  204d00:	4848      	ldr	r0, [pc, #288]	; (204e24 <main+0x8e0>)
  204d02:	f7fc fd21 	bl	201748 <HAL_IWDG_Refresh>
					HAL_GPIO_TogglePin(GPIOD,GPIO_PIN_10);
  204d06:	f44f 6180 	mov.w	r1, #1024	; 0x400
  204d0a:	4648      	mov	r0, r9
  204d0c:	f7fc f9ed 	bl	2010ea <HAL_GPIO_TogglePin>
					test_mode();
  204d10:	f7ff f9f2 	bl	2040f8 <test_mode>
  204d14:	e7db      	b.n	204cce <main+0x78a>
			oled_returnhome();
  204d16:	f7fe ff96 	bl	203c46 <oled_returnhome>
			oled_puts("test mode select");
  204d1a:	4843      	ldr	r0, [pc, #268]	; (204e28 <main+0x8e4>)
  204d1c:	e736      	b.n	204b8c <main+0x648>
		  if(HAL_GPIO_ReadPin(GPIOD,GPIO_PIN_7)==1){
  204d1e:	2180      	movs	r1, #128	; 0x80
  204d20:	483c      	ldr	r0, [pc, #240]	; (204e14 <main+0x8d0>)
  204d22:	f7fc f9d7 	bl	2010d4 <HAL_GPIO_ReadPin>
  204d26:	2801      	cmp	r0, #1
  204d28:	4604      	mov	r4, r0
  204d2a:	d132      	bne.n	204d92 <main+0x84e>
			  HOUI_def=JY901_def_set();
  204d2c:	f7fe faa2 	bl	203274 <JY901_def_set>
  204d30:	4b39      	ldr	r3, [pc, #228]	; (204e18 <main+0x8d4>)
			    TIM5->CNT=30000;
  204d32:	4a3a      	ldr	r2, [pc, #232]	; (204e1c <main+0x8d8>)
				HAL_GPIO_WritePin(GPIOC,GPIO_PIN_1,1);
  204d34:	2102      	movs	r1, #2
			  HOUI_def=JY901_def_set();
  204d36:	8018      	strh	r0, [r3, #0]
			    TIM5->CNT=30000;
  204d38:	f247 5330 	movw	r3, #30000	; 0x7530
				while(HAL_GPIO_ReadPin(GPIOD,GPIO_PIN_7)==1){
  204d3c:	f8df 90d4 	ldr.w	r9, [pc, #212]	; 204e14 <main+0x8d0>
				HAL_GPIO_WritePin(GPIOC,GPIO_PIN_1,1);
  204d40:	4638      	mov	r0, r7
				oled_puts("demo mode select");
  204d42:	f8df a0e8 	ldr.w	sl, [pc, #232]	; 204e2c <main+0x8e8>
				oled_puts("Runnning         ");
  204d46:	f8df b0f8 	ldr.w	fp, [pc, #248]	; 204e40 <main+0x8fc>
			    TIM5->CNT=30000;
  204d4a:	6253      	str	r3, [r2, #36]	; 0x24
				HAL_GPIO_WritePin(GPIOC,GPIO_PIN_1,1);
  204d4c:	4622      	mov	r2, r4
			    TIM8->CNT=30000;
  204d4e:	6273      	str	r3, [r6, #36]	; 0x24
				HAL_GPIO_WritePin(GPIOC,GPIO_PIN_1,1);
  204d50:	f7fc f9c6 	bl	2010e0 <HAL_GPIO_WritePin>
				while(HAL_GPIO_ReadPin(GPIOD,GPIO_PIN_7)==1){
  204d54:	2180      	movs	r1, #128	; 0x80
  204d56:	4648      	mov	r0, r9
  204d58:	f7fc f9bc 	bl	2010d4 <HAL_GPIO_ReadPin>
  204d5c:	2801      	cmp	r0, #1
  204d5e:	4604      	mov	r4, r0
  204d60:	f47f aee7 	bne.w	204b32 <main+0x5ee>
				oled_returnhome();
  204d64:	f7fe ff6f 	bl	203c46 <oled_returnhome>
				oled_puts("demo mode select");
  204d68:	4650      	mov	r0, sl
  204d6a:	f7fe ff09 	bl	203b80 <oled_puts>
				oled_setcursor(1,0);
  204d6e:	2100      	movs	r1, #0
  204d70:	4620      	mov	r0, r4
  204d72:	f7fe ff57 	bl	203c24 <oled_setcursor>
				oled_puts("Runnning         ");
  204d76:	4658      	mov	r0, fp
  204d78:	f7fe ff02 	bl	203b80 <oled_puts>
				HAL_IWDG_Refresh(&hiwdg);
  204d7c:	4829      	ldr	r0, [pc, #164]	; (204e24 <main+0x8e0>)
  204d7e:	f7fc fce3 	bl	201748 <HAL_IWDG_Refresh>
				HAL_GPIO_TogglePin(GPIOD,GPIO_PIN_10);
  204d82:	f44f 6180 	mov.w	r1, #1024	; 0x400
  204d86:	4648      	mov	r0, r9
  204d88:	f7fc f9af 	bl	2010ea <HAL_GPIO_TogglePin>
				demo_mode();
  204d8c:	f7ff f9d6 	bl	20413c <demo_mode>
  204d90:	e7e0      	b.n	204d54 <main+0x810>
				oled_returnhome();
  204d92:	f7fe ff58 	bl	203c46 <oled_returnhome>
				oled_puts("demo mode select");
  204d96:	4825      	ldr	r0, [pc, #148]	; (204e2c <main+0x8e8>)
  204d98:	e6f8      	b.n	204b8c <main+0x648>
			oled_returnhome();
  204d9a:	f7fe ff54 	bl	203c46 <oled_returnhome>
			oled_puts("Calib select");
  204d9e:	4824      	ldr	r0, [pc, #144]	; (204e30 <main+0x8ec>)
  204da0:	f7fe feee 	bl	203b80 <oled_puts>
			oled_setcursor(1,0);
  204da4:	2100      	movs	r1, #0
  204da6:	2001      	movs	r0, #1
  204da8:	f7fe ff3c 	bl	203c24 <oled_setcursor>
		  if(HAL_GPIO_ReadPin(GPIOD,GPIO_PIN_7)==1){
  204dac:	2180      	movs	r1, #128	; 0x80
  204dae:	4819      	ldr	r0, [pc, #100]	; (204e14 <main+0x8d0>)
  204db0:	f7fc f990 	bl	2010d4 <HAL_GPIO_ReadPin>
  204db4:	2801      	cmp	r0, #1
  204db6:	d105      	bne.n	204dc4 <main+0x880>
			  calib_mode();
  204db8:	f7ff fae6 	bl	204388 <calib_mode>
			  HAL_IWDG_Refresh(&hiwdg);
  204dbc:	4819      	ldr	r0, [pc, #100]	; (204e24 <main+0x8e0>)
  204dbe:	f7fc fcc3 	bl	201748 <HAL_IWDG_Refresh>
  204dc2:	e6b6      	b.n	204b32 <main+0x5ee>
				oled_puts("OK?     waiting ");
  204dc4:	481b      	ldr	r0, [pc, #108]	; (204e34 <main+0x8f0>)
  204dc6:	f7fe fedb 	bl	203b80 <oled_puts>
				HAL_Delay(5);
  204dca:	2005      	movs	r0, #5
  204dcc:	f7fb fe6a 	bl	200aa4 <HAL_Delay>
  204dd0:	e6af      	b.n	204b32 <main+0x5ee>
			oled_returnhome();
  204dd2:	f7fe ff38 	bl	203c46 <oled_returnhome>
			oled_puts("select mode     ");
  204dd6:	4818      	ldr	r0, [pc, #96]	; (204e38 <main+0x8f4>)
			motor_move(0,0,0,0,0);
  204dd8:	2400      	movs	r4, #0
			oled_puts("select mode     ");
  204dda:	f7fe fed1 	bl	203b80 <oled_puts>
			oled_setcursor(1,0);
  204dde:	2100      	movs	r1, #0
  204de0:	2001      	movs	r0, #1
  204de2:	f7fe ff1f 	bl	203c24 <oled_setcursor>
			oled_puts("           SURF ");
  204de6:	4815      	ldr	r0, [pc, #84]	; (204e3c <main+0x8f8>)
  204de8:	f7fe feca 	bl	203b80 <oled_puts>
			motor_move(0,0,0,0,0);
  204dec:	4623      	mov	r3, r4
  204dee:	4622      	mov	r2, r4
  204df0:	4621      	mov	r1, r4
  204df2:	4620      	mov	r0, r4
  204df4:	9400      	str	r4, [sp, #0]
  204df6:	f000 f893 	bl	204f20 <motor_move>
			servo(90,90,90,90,90,90,0,0,0,0);
  204dfa:	235a      	movs	r3, #90	; 0x5a
  204dfc:	9405      	str	r4, [sp, #20]
  204dfe:	9404      	str	r4, [sp, #16]
  204e00:	461a      	mov	r2, r3
  204e02:	9403      	str	r4, [sp, #12]
  204e04:	4619      	mov	r1, r3
  204e06:	9402      	str	r4, [sp, #8]
  204e08:	4618      	mov	r0, r3
  204e0a:	9301      	str	r3, [sp, #4]
  204e0c:	9300      	str	r3, [sp, #0]
  204e0e:	f7fe fa71 	bl	2032f4 <servo>
  204e12:	e6c4      	b.n	204b9e <main+0x65a>
  204e14:	40020c00 	.word	0x40020c00
  204e18:	20000178 	.word	0x20000178
  204e1c:	40000c00 	.word	0x40000c00
  204e20:	002076f0 	.word	0x002076f0
  204e24:	20000168 	.word	0x20000168
  204e28:	002076df 	.word	0x002076df
  204e2c:	00207701 	.word	0x00207701
  204e30:	00207712 	.word	0x00207712
  204e34:	00207688 	.word	0x00207688
  204e38:	0020771f 	.word	0x0020771f
  204e3c:	00207730 	.word	0x00207730
  204e40:	002076aa 	.word	0x002076aa

00204e44 <HAL_UART_RxCpltCallback>:
		while (Rxbuf[j] != 253 && j<(Servonumber + 9)) {
  204e44:	4a28      	ldr	r2, [pc, #160]	; (204ee8 <HAL_UART_RxCpltCallback+0xa4>)
		int j = 0;
  204e46:	2300      	movs	r3, #0
  204e48:	4611      	mov	r1, r2
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart){
  204e4a:	b570      	push	{r4, r5, r6, lr}
		while (Rxbuf[j] != 253 && j<(Servonumber + 9)) {
  204e4c:	5c98      	ldrb	r0, [r3, r2]
  204e4e:	28fd      	cmp	r0, #253	; 0xfd
  204e50:	d013      	beq.n	204e7a <HAL_UART_RxCpltCallback+0x36>
  204e52:	2b0e      	cmp	r3, #14
  204e54:	d10f      	bne.n	204e76 <HAL_UART_RxCpltCallback+0x32>
  204e56:	2200      	movs	r2, #0
				data[k] = 0;
  204e58:	4b24      	ldr	r3, [pc, #144]	; (204eec <HAL_UART_RxCpltCallback+0xa8>)
  204e5a:	2100      	movs	r1, #0
  204e5c:	54d1      	strb	r1, [r2, r3]
			for (int k = 0; k < 7; k++) {
  204e5e:	3201      	adds	r2, #1
  204e60:	2a07      	cmp	r2, #7
  204e62:	d1fb      	bne.n	204e5c <HAL_UART_RxCpltCallback+0x18>
				data[k]=90;
  204e64:	225a      	movs	r2, #90	; 0x5a
			data[Servonumber+7]=0;
  204e66:	7319      	strb	r1, [r3, #12]
			data[Servonumber+8]=0;
  204e68:	7359      	strb	r1, [r3, #13]
				data[k]=90;
  204e6a:	71da      	strb	r2, [r3, #7]
  204e6c:	721a      	strb	r2, [r3, #8]
  204e6e:	725a      	strb	r2, [r3, #9]
  204e70:	729a      	strb	r2, [r3, #10]
  204e72:	72da      	strb	r2, [r3, #11]
  204e74:	bd70      	pop	{r4, r5, r6, pc}
			j++;
  204e76:	3301      	adds	r3, #1
  204e78:	e7e8      	b.n	204e4c <HAL_UART_RxCpltCallback+0x8>
		if(j>=Servonumber+9){
  204e7a:	2b0e      	cmp	r3, #14
  204e7c:	d0eb      	beq.n	204e56 <HAL_UART_RxCpltCallback+0x12>
  204e7e:	4a1b      	ldr	r2, [pc, #108]	; (204eec <HAL_UART_RxCpltCallback+0xa8>)
  204e80:	f103 040e 	add.w	r4, r3, #14
					data[k] = Rxbuf[j + k + 1];
  204e84:	1ad0      	subs	r0, r2, r3
					data[k] = Rxbuf[k - (Servonumber + 9 - j)];
  204e86:	18cd      	adds	r5, r1, r3
				if ((j + k) >= Servonumber + 9) {
  204e88:	2b0d      	cmp	r3, #13
					data[k] = Rxbuf[k - (Servonumber + 9 - j)];
  204e8a:	bfcc      	ite	gt
  204e8c:	f815 5c0e 	ldrbgt.w	r5, [r5, #-14]
					data[k] = Rxbuf[j + k + 1];
  204e90:	786d      	ldrble	r5, [r5, #1]
  204e92:	54c5      	strb	r5, [r0, r3]
  204e94:	3301      	adds	r3, #1
			for (int k = 0; k < (Servonumber + 9); k++) {
  204e96:	42a3      	cmp	r3, r4
  204e98:	d1f5      	bne.n	204e86 <HAL_UART_RxCpltCallback+0x42>
			motor[0]=data[0];
  204e9a:	4b15      	ldr	r3, [pc, #84]	; (204ef0 <HAL_UART_RxCpltCallback+0xac>)
  204e9c:	7811      	ldrb	r1, [r2, #0]
  204e9e:	7019      	strb	r1, [r3, #0]
			motor[1]=data[1];
  204ea0:	7851      	ldrb	r1, [r2, #1]
  204ea2:	7059      	strb	r1, [r3, #1]
			motor[2]=data[2];
  204ea4:	7891      	ldrb	r1, [r2, #2]
  204ea6:	7099      	strb	r1, [r3, #2]
			motor[3]=data[3];
  204ea8:	78d1      	ldrb	r1, [r2, #3]
  204eaa:	70d9      	strb	r1, [r3, #3]
			motor[4]=data[4];
  204eac:	7911      	ldrb	r1, [r2, #4]
  204eae:	7119      	strb	r1, [r3, #4]
			for(int i=0;i<Servonumber;i++){
  204eb0:	2300      	movs	r3, #0
			servodata[i]=(int16_t)data[i+7];
  204eb2:	4910      	ldr	r1, [pc, #64]	; (204ef4 <HAL_UART_RxCpltCallback+0xb0>)
  204eb4:	18d0      	adds	r0, r2, r3
  204eb6:	79c0      	ldrb	r0, [r0, #7]
  204eb8:	f821 0013 	strh.w	r0, [r1, r3, lsl #1]
			for(int i=0;i<Servonumber;i++){
  204ebc:	3301      	adds	r3, #1
  204ebe:	2b05      	cmp	r3, #5
  204ec0:	d1f8      	bne.n	204eb4 <HAL_UART_RxCpltCallback+0x70>
			Flug_Rxdata=1;
  204ec2:	2401      	movs	r4, #1
  204ec4:	4b0c      	ldr	r3, [pc, #48]	; (204ef8 <HAL_UART_RxCpltCallback+0xb4>)
			TX_buf[0]=1+HAL_GPIO_ReadPin(GPIOE,GPIO_PIN_3)*2;
  204ec6:	2108      	movs	r1, #8
  204ec8:	480c      	ldr	r0, [pc, #48]	; (204efc <HAL_UART_RxCpltCallback+0xb8>)
			Flug_Rxdata=1;
  204eca:	701c      	strb	r4, [r3, #0]
			TX_buf[0]=1+HAL_GPIO_ReadPin(GPIOE,GPIO_PIN_3)*2;
  204ecc:	f7fc f902 	bl	2010d4 <HAL_GPIO_ReadPin>
  204ed0:	40a0      	lsls	r0, r4
  204ed2:	490b      	ldr	r1, [pc, #44]	; (204f00 <HAL_UART_RxCpltCallback+0xbc>)
			HAL_UART_Transmit(&huart1,TX_buf,1,0xff);
  204ed4:	4622      	mov	r2, r4
  204ed6:	23ff      	movs	r3, #255	; 0xff
			TX_buf[0]=1+HAL_GPIO_ReadPin(GPIOE,GPIO_PIN_3)*2;
  204ed8:	4420      	add	r0, r4
  204eda:	7008      	strb	r0, [r1, #0]
			HAL_UART_Transmit(&huart1,TX_buf,1,0xff);
  204edc:	4809      	ldr	r0, [pc, #36]	; (204f04 <HAL_UART_RxCpltCallback+0xc0>)
		}
  204ede:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			HAL_UART_Transmit(&huart1,TX_buf,1,0xff);
  204ee2:	f7fd bdde 	b.w	202aa2 <HAL_UART_Transmit>
  204ee6:	bf00      	nop
  204ee8:	2000019c 	.word	0x2000019c
  204eec:	200001ed 	.word	0x200001ed
  204ef0:	20000205 	.word	0x20000205
  204ef4:	20000000 	.word	0x20000000
  204ef8:	2000003c 	.word	0x2000003c
  204efc:	40021000 	.word	0x40021000
  204f00:	200001ec 	.word	0x200001ec
  204f04:	20000538 	.word	0x20000538

00204f08 <_Error_Handler>:
	  HAL_GPIO_WritePin(GPIOB,GPIO_PIN_12,1);
  204f08:	4c04      	ldr	r4, [pc, #16]	; (204f1c <_Error_Handler+0x14>)
{
  204f0a:	b508      	push	{r3, lr}
	  HAL_GPIO_WritePin(GPIOB,GPIO_PIN_12,1);
  204f0c:	2201      	movs	r2, #1
  204f0e:	f44f 5180 	mov.w	r1, #4096	; 0x1000
  204f12:	4620      	mov	r0, r4
  204f14:	f7fc f8e4 	bl	2010e0 <HAL_GPIO_WritePin>
  204f18:	e7f8      	b.n	204f0c <_Error_Handler+0x4>
  204f1a:	bf00      	nop
  204f1c:	40020400 	.word	0x40020400

00204f20 <motor_move>:
 */


#include "mecanum.h"

void motor_move(uint8_t comand,uint8_t dig1,uint8_t dig2,uint8_t power1a,uint8_t power2a){
  204f20:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  204f24:	f89d 4028 	ldrb.w	r4, [sp, #40]	; 0x28
		  power=(power1a)*(power2a-1);
  204f28:	1e65      	subs	r5, r4, #1
  204f2a:	4cc3      	ldr	r4, [pc, #780]	; (205238 <motor_move+0x318>)
		  if(power<0){power=0;}
  204f2c:	435d      	muls	r5, r3
  204f2e:	bf48      	it	mi
  204f30:	2500      	movmi	r5, #0
  204f32:	6025      	str	r5, [r4, #0]
		  if(power1a==0){power=0;}
  204f34:	b903      	cbnz	r3, 204f38 <motor_move+0x18>
  204f36:	6023      	str	r3, [r4, #0]
		  digree=((dig1<<8)+dig2)-1000;
  204f38:	eb02 2201 	add.w	r2, r2, r1, lsl #8
  204f3c:	4dbf      	ldr	r5, [pc, #764]	; (20523c <motor_move+0x31c>)
  204f3e:	f5a2 737a 	sub.w	r3, r2, #1000	; 0x3e8
		  if(digree<0){digree=0;}
  204f42:	2b00      	cmp	r3, #0
		  digree=((dig1<<8)+dig2)-1000;
  204f44:	602b      	str	r3, [r5, #0]
		  if(digree<0){digree=0;}
  204f46:	da23      	bge.n	204f90 <motor_move+0x70>
  204f48:	2300      	movs	r3, #0
				 150;]
				 200;E]
				 50;360x@C
				 125;360x@C
				  */
		  switch(comand){
  204f4a:	287d      	cmp	r0, #125	; 0x7d
		  if(digree<0){digree=0;}
  204f4c:	602b      	str	r3, [r5, #0]
		  switch(comand){
  204f4e:	f000 84c5 	beq.w	2058dc <motor_move+0x9bc>
  204f52:	f200 8124 	bhi.w	20519e <motor_move+0x27e>
  204f56:	2832      	cmp	r0, #50	; 0x32
  204f58:	d027      	beq.n	204faa <motor_move+0x8a>
  204f5a:	2864      	cmp	r0, #100	; 0x64
  204f5c:	f000 875a 	beq.w	205e14 <motor_move+0xef4>
				digtemp=3000;
				HOUI_def=JY901_def_set();
		  break;

		  default:
				motor1(0,0);
  204f60:	2100      	movs	r1, #0
  204f62:	4608      	mov	r0, r1
  204f64:	f7fe fbf2 	bl	20374c <motor1>
			    motor2(0,0);
  204f68:	2100      	movs	r1, #0
  204f6a:	4608      	mov	r0, r1
  204f6c:	f7fe fc0c 	bl	203788 <motor2>
			    motor3(0,0);
  204f70:	2100      	movs	r1, #0
  204f72:	4608      	mov	r0, r1
  204f74:	f7fe fc26 	bl	2037c4 <motor3>
			    motor4(0,0);
  204f78:	2100      	movs	r1, #0
  204f7a:	4608      	mov	r0, r1
  204f7c:	f7fe fc40 	bl	203800 <motor4>
				HAL_GPIO_WritePin(GPIOE,GPIO_PIN_10,0);
  204f80:	2200      	movs	r2, #0
  204f82:	f44f 6180 	mov.w	r1, #1024	; 0x400
  204f86:	48ae      	ldr	r0, [pc, #696]	; (205240 <motor_move+0x320>)
				//digtemp=1000;
		  break;
		  }
	}
  204f88:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
				HAL_GPIO_WritePin(GPIOE,GPIO_PIN_10,0);
  204f8c:	f7fc b8a8 	b.w	2010e0 <HAL_GPIO_WritePin>
		  switch(comand){
  204f90:	287d      	cmp	r0, #125	; 0x7d
  204f92:	f000 84a3 	beq.w	2058dc <motor_move+0x9bc>
  204f96:	f200 8102 	bhi.w	20519e <motor_move+0x27e>
  204f9a:	2832      	cmp	r0, #50	; 0x32
  204f9c:	d1dd      	bne.n	204f5a <motor_move+0x3a>
			  if(digree>=0 && digree<=360){
  204f9e:	f5b3 7fb4 	cmp.w	r3, #360	; 0x168
  204fa2:	dcdd      	bgt.n	204f60 <motor_move+0x40>
				  if(digree>=0 && digree<=45){
  204fa4:	2b2d      	cmp	r3, #45	; 0x2d
  204fa6:	f200 8163 	bhi.w	205270 <motor_move+0x350>
					if(digtemp!=0){
  204faa:	4ea6      	ldr	r6, [pc, #664]	; (205244 <motor_move+0x324>)
  204fac:	6833      	ldr	r3, [r6, #0]
  204fae:	b1db      	cbz	r3, 204fe8 <motor_move+0xc8>
							motor1(0,0);
  204fb0:	2100      	movs	r1, #0
  204fb2:	4608      	mov	r0, r1
  204fb4:	f7fe fbca 	bl	20374c <motor1>
							motor2(0,0);
  204fb8:	2100      	movs	r1, #0
  204fba:	4608      	mov	r0, r1
  204fbc:	f7fe fbe4 	bl	203788 <motor2>
							motor3(0,0);
  204fc0:	2100      	movs	r1, #0
  204fc2:	4608      	mov	r0, r1
  204fc4:	f7fe fbfe 	bl	2037c4 <motor3>
							motor4(0,0);
  204fc8:	2100      	movs	r1, #0
  204fca:	4608      	mov	r0, r1
  204fcc:	f7fe fc18 	bl	203800 <motor4>
							HAL_GPIO_WritePin(GPIOE,GPIO_PIN_10,0);
  204fd0:	2200      	movs	r2, #0
  204fd2:	f44f 6180 	mov.w	r1, #1024	; 0x400
  204fd6:	489a      	ldr	r0, [pc, #616]	; (205240 <motor_move+0x320>)
  204fd8:	f7fc f882 	bl	2010e0 <HAL_GPIO_WritePin>
							xprintf("bleak now\r\n");
  204fdc:	489a      	ldr	r0, [pc, #616]	; (205248 <motor_move+0x328>)
  204fde:	f002 f9b1 	bl	207344 <xprintf>
							HAL_Delay(bleak_time);
  204fe2:	2014      	movs	r0, #20
  204fe4:	f7fb fd5e 	bl	200aa4 <HAL_Delay>
					  power2=(float)arm_sin_f32((45-digree)*M_PI/180)*power;
  204fe8:	6828      	ldr	r0, [r5, #0]
  204fea:	f8df 827c 	ldr.w	r8, [pc, #636]	; 205268 <motor_move+0x348>
  204fee:	f1c0 002d 	rsb	r0, r0, #45	; 0x2d
					  power1=(float)arm_sin_f32((135-digree)*M_PI/180)*power;
  204ff2:	f8df 9278 	ldr.w	r9, [pc, #632]	; 20526c <motor_move+0x34c>
					  power2=(float)arm_sin_f32((45-digree)*M_PI/180)*power;
  204ff6:	f7fb fa59 	bl	2004ac <__aeabi_i2d>
					  power4=(float)arm_sin_f32((225-digree)*M_PI/180)*-1*power;
  204ffa:	4f94      	ldr	r7, [pc, #592]	; (20524c <motor_move+0x32c>)
					  power2=(float)arm_sin_f32((45-digree)*M_PI/180)*power;
  204ffc:	a38c      	add	r3, pc, #560	; (adr r3, 205230 <motor_move+0x310>)
  204ffe:	e9d3 2300 	ldrd	r2, r3, [r3]
  205002:	f7fb fab9 	bl	200578 <__aeabi_dmul>
  205006:	2200      	movs	r2, #0
  205008:	4b91      	ldr	r3, [pc, #580]	; (205250 <motor_move+0x330>)
  20500a:	f7fb fbdf 	bl	2007cc <__aeabi_ddiv>
  20500e:	f7fb fcc5 	bl	20099c <__aeabi_d2f>
  205012:	ee00 0a10 	vmov	s0, r0
  205016:	f002 f9cd 	bl	2073b4 <arm_sin_f32>
  20501a:	edd4 7a00 	vldr	s15, [r4]
					  power1=(float)arm_sin_f32((135-digree)*M_PI/180)*power;
  20501e:	6828      	ldr	r0, [r5, #0]
					  power2=(float)arm_sin_f32((45-digree)*M_PI/180)*power;
  205020:	eef8 7ae7 	vcvt.f32.s32	s15, s15
					  power1=(float)arm_sin_f32((135-digree)*M_PI/180)*power;
  205024:	f1c0 0087 	rsb	r0, r0, #135	; 0x87
					  power2=(float)arm_sin_f32((45-digree)*M_PI/180)*power;
  205028:	ee27 0a80 	vmul.f32	s0, s15, s0
  20502c:	eebd 0ac0 	vcvt.s32.f32	s0, s0
  205030:	ed88 0a00 	vstr	s0, [r8]
					  power1=(float)arm_sin_f32((135-digree)*M_PI/180)*power;
  205034:	f7fb fa3a 	bl	2004ac <__aeabi_i2d>
  205038:	a37d      	add	r3, pc, #500	; (adr r3, 205230 <motor_move+0x310>)
  20503a:	e9d3 2300 	ldrd	r2, r3, [r3]
  20503e:	f7fb fa9b 	bl	200578 <__aeabi_dmul>
  205042:	2200      	movs	r2, #0
  205044:	4b82      	ldr	r3, [pc, #520]	; (205250 <motor_move+0x330>)
  205046:	f7fb fbc1 	bl	2007cc <__aeabi_ddiv>
  20504a:	f7fb fca7 	bl	20099c <__aeabi_d2f>
  20504e:	ee00 0a10 	vmov	s0, r0
  205052:	f002 f9af 	bl	2073b4 <arm_sin_f32>
  205056:	edd4 7a00 	vldr	s15, [r4]
					  power4=(float)arm_sin_f32((225-digree)*M_PI/180)*-1*power;
  20505a:	6828      	ldr	r0, [r5, #0]
					  power1=(float)arm_sin_f32((135-digree)*M_PI/180)*power;
  20505c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
					  power4=(float)arm_sin_f32((225-digree)*M_PI/180)*-1*power;
  205060:	f1c0 00e1 	rsb	r0, r0, #225	; 0xe1
					  power1=(float)arm_sin_f32((135-digree)*M_PI/180)*power;
  205064:	ee27 0a80 	vmul.f32	s0, s15, s0
  205068:	eebd 0ac0 	vcvt.s32.f32	s0, s0
  20506c:	ed89 0a00 	vstr	s0, [r9]
					  power4=(float)arm_sin_f32((225-digree)*M_PI/180)*-1*power;
  205070:	f7fb fa1c 	bl	2004ac <__aeabi_i2d>
  205074:	a36e      	add	r3, pc, #440	; (adr r3, 205230 <motor_move+0x310>)
  205076:	e9d3 2300 	ldrd	r2, r3, [r3]
  20507a:	f7fb fa7d 	bl	200578 <__aeabi_dmul>
  20507e:	2200      	movs	r2, #0
  205080:	4b73      	ldr	r3, [pc, #460]	; (205250 <motor_move+0x330>)
  205082:	f7fb fba3 	bl	2007cc <__aeabi_ddiv>
  205086:	f7fb fc89 	bl	20099c <__aeabi_d2f>
  20508a:	ee00 0a10 	vmov	s0, r0
  20508e:	f002 f991 	bl	2073b4 <arm_sin_f32>
  205092:	edd4 7a00 	vldr	s15, [r4]
					  power3=(float)arm_sin_f32((315-digree)*M_PI/180)*-1*power;
  205096:	6828      	ldr	r0, [r5, #0]
					  power4=(float)arm_sin_f32((225-digree)*M_PI/180)*-1*power;
  205098:	eef8 7ae7 	vcvt.f32.s32	s15, s15
					  power3=(float)arm_sin_f32((315-digree)*M_PI/180)*-1*power;
  20509c:	f5c0 709d 	rsb	r0, r0, #314	; 0x13a
					  power4=(float)arm_sin_f32((225-digree)*M_PI/180)*-1*power;
  2050a0:	ee20 0a67 	vnmul.f32	s0, s0, s15
					  power3=(float)arm_sin_f32((315-digree)*M_PI/180)*-1*power;
  2050a4:	3001      	adds	r0, #1
					  power4=(float)arm_sin_f32((225-digree)*M_PI/180)*-1*power;
  2050a6:	eebd 0ac0 	vcvt.s32.f32	s0, s0
  2050aa:	ed87 0a00 	vstr	s0, [r7]
					  power3=(float)arm_sin_f32((315-digree)*M_PI/180)*-1*power;
  2050ae:	f7fb f9fd 	bl	2004ac <__aeabi_i2d>
  2050b2:	a35f      	add	r3, pc, #380	; (adr r3, 205230 <motor_move+0x310>)
  2050b4:	e9d3 2300 	ldrd	r2, r3, [r3]
  2050b8:	f7fb fa5e 	bl	200578 <__aeabi_dmul>
  2050bc:	2200      	movs	r2, #0
  2050be:	4b64      	ldr	r3, [pc, #400]	; (205250 <motor_move+0x330>)
  2050c0:	f7fb fb84 	bl	2007cc <__aeabi_ddiv>
  2050c4:	f7fb fc6a 	bl	20099c <__aeabi_d2f>
  2050c8:	ee00 0a10 	vmov	s0, r0
  2050cc:	f002 f972 	bl	2073b4 <arm_sin_f32>
  2050d0:	ed94 7a00 	vldr	s14, [r4]
  2050d4:	f8d9 3000 	ldr.w	r3, [r9]
					motor1(0,power1);
  2050d8:	2000      	movs	r0, #0
					  power3=(float)arm_sin_f32((315-digree)*M_PI/180)*-1*power;
  2050da:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
  2050de:	f8d8 2000 	ldr.w	r2, [r8]
					  power3=power3*((float)power/y);
  2050e2:	4c5c      	ldr	r4, [pc, #368]	; (205254 <motor_move+0x334>)
  2050e4:	4293      	cmp	r3, r2
					  power3=(float)arm_sin_f32((315-digree)*M_PI/180)*-1*power;
  2050e6:	ee20 0a47 	vnmul.f32	s0, s0, s14
  2050ea:	bfb8      	it	lt
  2050ec:	4613      	movlt	r3, r2
					  temp1=max(power1,power2);
  2050ee:	4a5a      	ldr	r2, [pc, #360]	; (205258 <motor_move+0x338>)
					  power3=(float)arm_sin_f32((315-digree)*M_PI/180)*-1*power;
  2050f0:	eebd 0ac0 	vcvt.s32.f32	s0, s0
					  temp1=max(power1,power2);
  2050f4:	6013      	str	r3, [r2, #0]
  2050f6:	ee10 2a10 	vmov	r2, s0
					  power3=power3*((float)power/y);
  2050fa:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
  2050fe:	4293      	cmp	r3, r2
  205100:	bfb8      	it	lt
  205102:	4613      	movlt	r3, r2
					  temp2=max(power3,temp1);
  205104:	4a55      	ldr	r2, [pc, #340]	; (20525c <motor_move+0x33c>)
  205106:	6013      	str	r3, [r2, #0]
  205108:	683a      	ldr	r2, [r7, #0]
  20510a:	4293      	cmp	r3, r2
  20510c:	bfb8      	it	lt
  20510e:	4613      	movlt	r3, r2
					  y=max(power4,temp2);
  205110:	4a53      	ldr	r2, [pc, #332]	; (205260 <motor_move+0x340>)
					  power1=power1*((float)power/y);
  205112:	ee07 3a90 	vmov	s15, r3
					  y=max(power4,temp2);
  205116:	6013      	str	r3, [r2, #0]
					  power1=power1*((float)power/y);
  205118:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  20511c:	eec7 6a27 	vdiv.f32	s13, s14, s15
  205120:	edd9 7a00 	vldr	s15, [r9]
  205124:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  205128:	ee67 7aa6 	vmul.f32	s15, s15, s13
					  power3=power3*((float)power/y);
  20512c:	ee20 0a26 	vmul.f32	s0, s0, s13
					  power1=power1*((float)power/y);
  205130:	eefd 7ae7 	vcvt.s32.f32	s15, s15
					  power3=power3*((float)power/y);
  205134:	eebd 0ac0 	vcvt.s32.f32	s0, s0
					  power1=power1*((float)power/y);
  205138:	ee17 1a90 	vmov	r1, s15
  20513c:	edc9 7a00 	vstr	s15, [r9]
					  power2=power2*((float)power/y);
  205140:	edd8 7a00 	vldr	s15, [r8]
					  power3=power3*((float)power/y);
  205144:	ed84 0a00 	vstr	s0, [r4]
					  power2=power2*((float)power/y);
  205148:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
					  power4=power4*((float)power/y);
  20514c:	edd7 7a00 	vldr	s15, [r7]
  205150:	eef8 7ae7 	vcvt.f32.s32	s15, s15
					  power2=power2*((float)power/y);
  205154:	ee27 7a26 	vmul.f32	s14, s14, s13
					  power4=power4*((float)power/y);
  205158:	ee67 7aa6 	vmul.f32	s15, s15, s13
					  power2=power2*((float)power/y);
  20515c:	eebd 7ac7 	vcvt.s32.f32	s14, s14
					  power4=power4*((float)power/y);
  205160:	eefd 7ae7 	vcvt.s32.f32	s15, s15
					  power2=power2*((float)power/y);
  205164:	ed88 7a00 	vstr	s14, [r8]
					  power4=power4*((float)power/y);
  205168:	edc7 7a00 	vstr	s15, [r7]
					motor1(0,power1);
  20516c:	f7fe faee 	bl	20374c <motor1>
					motor2(0,power2);
  205170:	f8d8 1000 	ldr.w	r1, [r8]
  205174:	2000      	movs	r0, #0
  205176:	f7fe fb07 	bl	203788 <motor2>
					motor3(0,power3);
  20517a:	6821      	ldr	r1, [r4, #0]
  20517c:	2000      	movs	r0, #0
  20517e:	f7fe fb21 	bl	2037c4 <motor3>
					motor4(0,power4);
  205182:	6839      	ldr	r1, [r7, #0]
  205184:	2000      	movs	r0, #0
  205186:	f7fe fb3b 	bl	203800 <motor4>
					HAL_GPIO_WritePin(GPIOE,GPIO_PIN_10,1);
  20518a:	2201      	movs	r2, #1
  20518c:	f44f 6180 	mov.w	r1, #1024	; 0x400
  205190:	482b      	ldr	r0, [pc, #172]	; (205240 <motor_move+0x320>)
  205192:	f7fb ffa5 	bl	2010e0 <HAL_GPIO_WritePin>
					  digtemp=0;
  205196:	2300      	movs	r3, #0
  205198:	6033      	str	r3, [r6, #0]
  20519a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		  switch(comand){
  20519e:	28c8      	cmp	r0, #200	; 0xc8
  2051a0:	f001 8110 	beq.w	2063c4 <motor_move+0x14a4>
  2051a4:	28fa      	cmp	r0, #250	; 0xfa
  2051a6:	f000 8764 	beq.w	206072 <motor_move+0x1152>
  2051aa:	2896      	cmp	r0, #150	; 0x96
  2051ac:	f47f aed8 	bne.w	204f60 <motor_move+0x40>
				if(digtemp!=2000){
  2051b0:	4d24      	ldr	r5, [pc, #144]	; (205244 <motor_move+0x324>)
  2051b2:	682a      	ldr	r2, [r5, #0]
  2051b4:	f5b2 6ffa 	cmp.w	r2, #2000	; 0x7d0
  2051b8:	d018      	beq.n	2051ec <motor_move+0x2cc>
					motor1(0,0);
  2051ba:	2100      	movs	r1, #0
  2051bc:	4608      	mov	r0, r1
  2051be:	f7fe fac5 	bl	20374c <motor1>
					motor2(0,0);
  2051c2:	2100      	movs	r1, #0
  2051c4:	4608      	mov	r0, r1
  2051c6:	f7fe fadf 	bl	203788 <motor2>
					motor3(0,0);
  2051ca:	2100      	movs	r1, #0
  2051cc:	4608      	mov	r0, r1
  2051ce:	f7fe faf9 	bl	2037c4 <motor3>
					motor4(0,0);
  2051d2:	2100      	movs	r1, #0
  2051d4:	4608      	mov	r0, r1
  2051d6:	f7fe fb13 	bl	203800 <motor4>
					HAL_GPIO_WritePin(GPIOE,GPIO_PIN_10,0);
  2051da:	4819      	ldr	r0, [pc, #100]	; (205240 <motor_move+0x320>)
  2051dc:	2200      	movs	r2, #0
  2051de:	f44f 6180 	mov.w	r1, #1024	; 0x400
  2051e2:	f7fb ff7d 	bl	2010e0 <HAL_GPIO_WritePin>
					HAL_Delay(bleak_time);
  2051e6:	2014      	movs	r0, #20
  2051e8:	f7fb fc5c 	bl	200aa4 <HAL_Delay>
				motor1(0,power);
  2051ec:	6821      	ldr	r1, [r4, #0]
  2051ee:	2000      	movs	r0, #0
  2051f0:	f7fe faac 	bl	20374c <motor1>
				motor2(0,power);
  2051f4:	6821      	ldr	r1, [r4, #0]
  2051f6:	2000      	movs	r0, #0
  2051f8:	f7fe fac6 	bl	203788 <motor2>
				motor3(power,0);
  2051fc:	2100      	movs	r1, #0
  2051fe:	6820      	ldr	r0, [r4, #0]
  205200:	f7fe fae0 	bl	2037c4 <motor3>
				motor4(power,0);
  205204:	2100      	movs	r1, #0
  205206:	6820      	ldr	r0, [r4, #0]
  205208:	f7fe fafa 	bl	203800 <motor4>
				HAL_GPIO_WritePin(GPIOE,GPIO_PIN_10,1);
  20520c:	2201      	movs	r2, #1
  20520e:	f44f 6180 	mov.w	r1, #1024	; 0x400
  205212:	480b      	ldr	r0, [pc, #44]	; (205240 <motor_move+0x320>)
  205214:	f7fb ff64 	bl	2010e0 <HAL_GPIO_WritePin>
				digtemp=2000;
  205218:	f44f 63fa 	mov.w	r3, #2000	; 0x7d0
				digtemp=3000;
  20521c:	602b      	str	r3, [r5, #0]
				HOUI_def=JY901_def_set();
  20521e:	f7fe f829 	bl	203274 <JY901_def_set>
  205222:	4b10      	ldr	r3, [pc, #64]	; (205264 <motor_move+0x344>)
  205224:	8018      	strh	r0, [r3, #0]
		  break;
  205226:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  20522a:	bf00      	nop
  20522c:	f3af 8000 	nop.w
  205230:	54442d18 	.word	0x54442d18
  205234:	400921fb 	.word	0x400921fb
  205238:	20000184 	.word	0x20000184
  20523c:	200001b8 	.word	0x200001b8
  205240:	40021000 	.word	0x40021000
  205244:	20000210 	.word	0x20000210
  205248:	002077e3 	.word	0x002077e3
  20524c:	200001e8 	.word	0x200001e8
  205250:	40668000 	.word	0x40668000
  205254:	20000198 	.word	0x20000198
  205258:	200001b0 	.word	0x200001b0
  20525c:	2000017c 	.word	0x2000017c
  205260:	200001fc 	.word	0x200001fc
  205264:	20000178 	.word	0x20000178
  205268:	200001c0 	.word	0x200001c0
  20526c:	2000020c 	.word	0x2000020c
				  else if(digree>45 && digree<=90){
  205270:	f2a2 4116 	subw	r1, r2, #1046	; 0x416
  205274:	f8df 9224 	ldr.w	r9, [pc, #548]	; 20549c <motor_move+0x57c>
  205278:	4f7f      	ldr	r7, [pc, #508]	; (205478 <motor_move+0x558>)
  20527a:	292c      	cmp	r1, #44	; 0x2c
  20527c:	f8df 8220 	ldr.w	r8, [pc, #544]	; 2054a0 <motor_move+0x580>
  205280:	4e7e      	ldr	r6, [pc, #504]	; (20547c <motor_move+0x55c>)
  205282:	f200 810f 	bhi.w	2054a4 <motor_move+0x584>
						  if(digtemp!=90){
  205286:	f8d9 3000 	ldr.w	r3, [r9]
  20528a:	2b5a      	cmp	r3, #90	; 0x5a
  20528c:	d01b      	beq.n	2052c6 <motor_move+0x3a6>
							  motor1(0,0);
  20528e:	2100      	movs	r1, #0
  205290:	4608      	mov	r0, r1
  205292:	f7fe fa5b 	bl	20374c <motor1>
							  motor2(0,0);
  205296:	2100      	movs	r1, #0
  205298:	4608      	mov	r0, r1
  20529a:	f7fe fa75 	bl	203788 <motor2>
							  motor3(0,0);
  20529e:	2100      	movs	r1, #0
  2052a0:	4608      	mov	r0, r1
  2052a2:	f7fe fa8f 	bl	2037c4 <motor3>
							  motor4(0,0);
  2052a6:	2100      	movs	r1, #0
  2052a8:	4608      	mov	r0, r1
  2052aa:	f7fe faa9 	bl	203800 <motor4>
								HAL_GPIO_WritePin(GPIOE,GPIO_PIN_10,0);
  2052ae:	2200      	movs	r2, #0
  2052b0:	f44f 6180 	mov.w	r1, #1024	; 0x400
  2052b4:	4872      	ldr	r0, [pc, #456]	; (205480 <motor_move+0x560>)
  2052b6:	f7fb ff13 	bl	2010e0 <HAL_GPIO_WritePin>
							xprintf("bleak now\r\n");
  2052ba:	4872      	ldr	r0, [pc, #456]	; (205484 <motor_move+0x564>)
  2052bc:	f002 f842 	bl	207344 <xprintf>
							  HAL_Delay(bleak_time);
  2052c0:	2014      	movs	r0, #20
  2052c2:	f7fb fbef 	bl	200aa4 <HAL_Delay>
						  power2=(float)arm_sin_f32((digree-45)*M_PI/180)*power;
  2052c6:	6828      	ldr	r0, [r5, #0]
  2052c8:	382d      	subs	r0, #45	; 0x2d
  2052ca:	f7fb f8ef 	bl	2004ac <__aeabi_i2d>
  2052ce:	a368      	add	r3, pc, #416	; (adr r3, 205470 <motor_move+0x550>)
  2052d0:	e9d3 2300 	ldrd	r2, r3, [r3]
  2052d4:	f7fb f950 	bl	200578 <__aeabi_dmul>
  2052d8:	2200      	movs	r2, #0
  2052da:	4b6b      	ldr	r3, [pc, #428]	; (205488 <motor_move+0x568>)
  2052dc:	f7fb fa76 	bl	2007cc <__aeabi_ddiv>
  2052e0:	f7fb fb5c 	bl	20099c <__aeabi_d2f>
  2052e4:	ee00 0a10 	vmov	s0, r0
  2052e8:	f002 f864 	bl	2073b4 <arm_sin_f32>
  2052ec:	edd4 7a00 	vldr	s15, [r4]
						  power1=(float)arm_sin_f32((135-digree)*M_PI/180)*power;
  2052f0:	6828      	ldr	r0, [r5, #0]
						  power2=(float)arm_sin_f32((digree-45)*M_PI/180)*power;
  2052f2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
						  power1=(float)arm_sin_f32((135-digree)*M_PI/180)*power;
  2052f6:	f1c0 0087 	rsb	r0, r0, #135	; 0x87
						  power2=(float)arm_sin_f32((digree-45)*M_PI/180)*power;
  2052fa:	ee27 0a80 	vmul.f32	s0, s15, s0
  2052fe:	eebd 0ac0 	vcvt.s32.f32	s0, s0
  205302:	ed87 0a00 	vstr	s0, [r7]
						  power1=(float)arm_sin_f32((135-digree)*M_PI/180)*power;
  205306:	f7fb f8d1 	bl	2004ac <__aeabi_i2d>
  20530a:	a359      	add	r3, pc, #356	; (adr r3, 205470 <motor_move+0x550>)
  20530c:	e9d3 2300 	ldrd	r2, r3, [r3]
  205310:	f7fb f932 	bl	200578 <__aeabi_dmul>
  205314:	2200      	movs	r2, #0
  205316:	4b5c      	ldr	r3, [pc, #368]	; (205488 <motor_move+0x568>)
  205318:	f7fb fa58 	bl	2007cc <__aeabi_ddiv>
  20531c:	f7fb fb3e 	bl	20099c <__aeabi_d2f>
  205320:	ee00 0a10 	vmov	s0, r0
  205324:	f002 f846 	bl	2073b4 <arm_sin_f32>
  205328:	edd4 7a00 	vldr	s15, [r4]
						  power4=(float)arm_sin_f32((225-digree)*M_PI/180)*power;
  20532c:	6828      	ldr	r0, [r5, #0]
						  power1=(float)arm_sin_f32((135-digree)*M_PI/180)*power;
  20532e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
						  power4=(float)arm_sin_f32((225-digree)*M_PI/180)*power;
  205332:	f1c0 00e1 	rsb	r0, r0, #225	; 0xe1
						  power1=(float)arm_sin_f32((135-digree)*M_PI/180)*power;
  205336:	ee27 0a80 	vmul.f32	s0, s15, s0
  20533a:	eebd 0ac0 	vcvt.s32.f32	s0, s0
  20533e:	ed88 0a00 	vstr	s0, [r8]
						  power4=(float)arm_sin_f32((225-digree)*M_PI/180)*power;
  205342:	f7fb f8b3 	bl	2004ac <__aeabi_i2d>
  205346:	a34a      	add	r3, pc, #296	; (adr r3, 205470 <motor_move+0x550>)
  205348:	e9d3 2300 	ldrd	r2, r3, [r3]
  20534c:	f7fb f914 	bl	200578 <__aeabi_dmul>
  205350:	2200      	movs	r2, #0
  205352:	4b4d      	ldr	r3, [pc, #308]	; (205488 <motor_move+0x568>)
  205354:	f7fb fa3a 	bl	2007cc <__aeabi_ddiv>
  205358:	f7fb fb20 	bl	20099c <__aeabi_d2f>
  20535c:	ee00 0a10 	vmov	s0, r0
  205360:	f002 f828 	bl	2073b4 <arm_sin_f32>
  205364:	edd4 7a00 	vldr	s15, [r4]
						  power3=(float)arm_sin_f32((315-digree)*M_PI/180)*-1*power;
  205368:	6828      	ldr	r0, [r5, #0]
						  power4=(float)arm_sin_f32((225-digree)*M_PI/180)*power;
  20536a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
						  power3=(float)arm_sin_f32((315-digree)*M_PI/180)*-1*power;
  20536e:	f5c0 709d 	rsb	r0, r0, #314	; 0x13a
						  power4=(float)arm_sin_f32((225-digree)*M_PI/180)*power;
  205372:	ee27 0a80 	vmul.f32	s0, s15, s0
						  power3=(float)arm_sin_f32((315-digree)*M_PI/180)*-1*power;
  205376:	3001      	adds	r0, #1
						  power4=(float)arm_sin_f32((225-digree)*M_PI/180)*power;
  205378:	eebd 0ac0 	vcvt.s32.f32	s0, s0
  20537c:	ed86 0a00 	vstr	s0, [r6]
						  power3=(float)arm_sin_f32((315-digree)*M_PI/180)*-1*power;
  205380:	f7fb f894 	bl	2004ac <__aeabi_i2d>
  205384:	a33a      	add	r3, pc, #232	; (adr r3, 205470 <motor_move+0x550>)
  205386:	e9d3 2300 	ldrd	r2, r3, [r3]
  20538a:	f7fb f8f5 	bl	200578 <__aeabi_dmul>
  20538e:	2200      	movs	r2, #0
  205390:	4b3d      	ldr	r3, [pc, #244]	; (205488 <motor_move+0x568>)
  205392:	f7fb fa1b 	bl	2007cc <__aeabi_ddiv>
  205396:	f7fb fb01 	bl	20099c <__aeabi_d2f>
  20539a:	ee00 0a10 	vmov	s0, r0
  20539e:	f002 f809 	bl	2073b4 <arm_sin_f32>
  2053a2:	ed94 7a00 	vldr	s14, [r4]
  2053a6:	f8d8 3000 	ldr.w	r3, [r8]
						  motor1(0,power1);
  2053aa:	2000      	movs	r0, #0
						  power3=(float)arm_sin_f32((315-digree)*M_PI/180)*-1*power;
  2053ac:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
  2053b0:	683a      	ldr	r2, [r7, #0]
						  power3=power3*((float)power/y);
  2053b2:	4c36      	ldr	r4, [pc, #216]	; (20548c <motor_move+0x56c>)
  2053b4:	4293      	cmp	r3, r2
						  power3=(float)arm_sin_f32((315-digree)*M_PI/180)*-1*power;
  2053b6:	ee20 0a47 	vnmul.f32	s0, s0, s14
  2053ba:	bfb8      	it	lt
  2053bc:	4613      	movlt	r3, r2
						  temp1=max(power1,power2);
  2053be:	4a34      	ldr	r2, [pc, #208]	; (205490 <motor_move+0x570>)
						  power3=(float)arm_sin_f32((315-digree)*M_PI/180)*-1*power;
  2053c0:	eebd 0ac0 	vcvt.s32.f32	s0, s0
						  temp1=max(power1,power2);
  2053c4:	6013      	str	r3, [r2, #0]
  2053c6:	ee10 2a10 	vmov	r2, s0
						  power3=power3*((float)power/y);
  2053ca:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
  2053ce:	4293      	cmp	r3, r2
  2053d0:	bfb8      	it	lt
  2053d2:	4613      	movlt	r3, r2
						  temp2=max(power3,temp1);
  2053d4:	4a2f      	ldr	r2, [pc, #188]	; (205494 <motor_move+0x574>)
  2053d6:	6013      	str	r3, [r2, #0]
  2053d8:	6832      	ldr	r2, [r6, #0]
  2053da:	4293      	cmp	r3, r2
  2053dc:	bfb8      	it	lt
  2053de:	4613      	movlt	r3, r2
						  y=max(power4,temp2);
  2053e0:	4a2d      	ldr	r2, [pc, #180]	; (205498 <motor_move+0x578>)
						  power1=power1*((float)power/y);
  2053e2:	ee07 3a90 	vmov	s15, r3
						  y=max(power4,temp2);
  2053e6:	6013      	str	r3, [r2, #0]
						  power1=power1*((float)power/y);
  2053e8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  2053ec:	eec7 6a27 	vdiv.f32	s13, s14, s15
  2053f0:	edd8 7a00 	vldr	s15, [r8]
  2053f4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  2053f8:	ee67 7aa6 	vmul.f32	s15, s15, s13
						  power3=power3*((float)power/y);
  2053fc:	ee20 0a26 	vmul.f32	s0, s0, s13
						  power1=power1*((float)power/y);
  205400:	eefd 7ae7 	vcvt.s32.f32	s15, s15
						  power3=power3*((float)power/y);
  205404:	eebd 0ac0 	vcvt.s32.f32	s0, s0
						  power1=power1*((float)power/y);
  205408:	ee17 1a90 	vmov	r1, s15
  20540c:	edc8 7a00 	vstr	s15, [r8]
						  power2=power2*((float)power/y);
  205410:	edd7 7a00 	vldr	s15, [r7]
						  power3=power3*((float)power/y);
  205414:	ed84 0a00 	vstr	s0, [r4]
						  power2=power2*((float)power/y);
  205418:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
						  power4=power4*((float)power/y);
  20541c:	edd6 7a00 	vldr	s15, [r6]
  205420:	eef8 7ae7 	vcvt.f32.s32	s15, s15
						  power2=power2*((float)power/y);
  205424:	ee27 7a26 	vmul.f32	s14, s14, s13
						  power4=power4*((float)power/y);
  205428:	ee67 7aa6 	vmul.f32	s15, s15, s13
						  power2=power2*((float)power/y);
  20542c:	eebd 7ac7 	vcvt.s32.f32	s14, s14
						  power4=power4*((float)power/y);
  205430:	eefd 7ae7 	vcvt.s32.f32	s15, s15
						  power2=power2*((float)power/y);
  205434:	ed87 7a00 	vstr	s14, [r7]
						  power4=power4*((float)power/y);
  205438:	edc6 7a00 	vstr	s15, [r6]
						  motor1(0,power1);
  20543c:	f7fe f986 	bl	20374c <motor1>
						  motor2(power2,0);
  205440:	2100      	movs	r1, #0
  205442:	6838      	ldr	r0, [r7, #0]
  205444:	f7fe f9a0 	bl	203788 <motor2>
						  motor3(0,power3);
  205448:	6821      	ldr	r1, [r4, #0]
  20544a:	2000      	movs	r0, #0
  20544c:	f7fe f9ba 	bl	2037c4 <motor3>
						  motor4(power4,0);
  205450:	2100      	movs	r1, #0
  205452:	6830      	ldr	r0, [r6, #0]
  205454:	f7fe f9d4 	bl	203800 <motor4>
							HAL_GPIO_WritePin(GPIOE,GPIO_PIN_10,1);
  205458:	2201      	movs	r2, #1
  20545a:	f44f 6180 	mov.w	r1, #1024	; 0x400
  20545e:	4808      	ldr	r0, [pc, #32]	; (205480 <motor_move+0x560>)
  205460:	f7fb fe3e 	bl	2010e0 <HAL_GPIO_WritePin>
						  digtemp=90;
  205464:	235a      	movs	r3, #90	; 0x5a
						  digtemp=0;
  205466:	f8c9 3000 	str.w	r3, [r9]
  20546a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  20546e:	bf00      	nop
  205470:	54442d18 	.word	0x54442d18
  205474:	400921fb 	.word	0x400921fb
  205478:	200001c0 	.word	0x200001c0
  20547c:	200001e8 	.word	0x200001e8
  205480:	40021000 	.word	0x40021000
  205484:	002077e3 	.word	0x002077e3
  205488:	40668000 	.word	0x40668000
  20548c:	20000198 	.word	0x20000198
  205490:	200001b0 	.word	0x200001b0
  205494:	2000017c 	.word	0x2000017c
  205498:	200001fc 	.word	0x200001fc
  20549c:	20000210 	.word	0x20000210
  2054a0:	2000020c 	.word	0x2000020c
				  else if(digree>90 && digree<=135){
  2054a4:	f2a2 4143 	subw	r1, r2, #1091	; 0x443
  2054a8:	292c      	cmp	r1, #44	; 0x2c
  2054aa:	f67f aeec 	bls.w	205286 <motor_move+0x366>
				  else if(digree>135 && digree<=180){
  2054ae:	f5a2 618e 	sub.w	r1, r2, #1136	; 0x470
  2054b2:	292c      	cmp	r1, #44	; 0x2c
  2054b4:	f200 8102 	bhi.w	2056bc <motor_move+0x79c>
						  if(digtemp!=180){
  2054b8:	f8d9 3000 	ldr.w	r3, [r9]
  2054bc:	2bb4      	cmp	r3, #180	; 0xb4
  2054be:	d01b      	beq.n	2054f8 <motor_move+0x5d8>
							  motor1(0,0);
  2054c0:	2100      	movs	r1, #0
  2054c2:	4608      	mov	r0, r1
  2054c4:	f7fe f942 	bl	20374c <motor1>
							  motor2(0,0);
  2054c8:	2100      	movs	r1, #0
  2054ca:	4608      	mov	r0, r1
  2054cc:	f7fe f95c 	bl	203788 <motor2>
							  motor3(0,0);
  2054d0:	2100      	movs	r1, #0
  2054d2:	4608      	mov	r0, r1
  2054d4:	f7fe f976 	bl	2037c4 <motor3>
							  motor4(0,0);
  2054d8:	2100      	movs	r1, #0
  2054da:	4608      	mov	r0, r1
  2054dc:	f7fe f990 	bl	203800 <motor4>
								HAL_GPIO_WritePin(GPIOE,GPIO_PIN_10,0);
  2054e0:	2200      	movs	r2, #0
  2054e2:	f44f 6180 	mov.w	r1, #1024	; 0x400
  2054e6:	486e      	ldr	r0, [pc, #440]	; (2056a0 <motor_move+0x780>)
  2054e8:	f7fb fdfa 	bl	2010e0 <HAL_GPIO_WritePin>
							xprintf("bleak now\r\n");
  2054ec:	486d      	ldr	r0, [pc, #436]	; (2056a4 <motor_move+0x784>)
  2054ee:	f001 ff29 	bl	207344 <xprintf>
							  HAL_Delay(bleak_time);
  2054f2:	2014      	movs	r0, #20
  2054f4:	f7fb fad6 	bl	200aa4 <HAL_Delay>
						  power2=(float)arm_sin_f32((digree-45)*M_PI/180)*power;
  2054f8:	6828      	ldr	r0, [r5, #0]
  2054fa:	382d      	subs	r0, #45	; 0x2d
  2054fc:	f7fa ffd6 	bl	2004ac <__aeabi_i2d>
  205500:	a365      	add	r3, pc, #404	; (adr r3, 205698 <motor_move+0x778>)
  205502:	e9d3 2300 	ldrd	r2, r3, [r3]
  205506:	f7fb f837 	bl	200578 <__aeabi_dmul>
  20550a:	2200      	movs	r2, #0
  20550c:	4b66      	ldr	r3, [pc, #408]	; (2056a8 <motor_move+0x788>)
  20550e:	f7fb f95d 	bl	2007cc <__aeabi_ddiv>
  205512:	f7fb fa43 	bl	20099c <__aeabi_d2f>
  205516:	ee00 0a10 	vmov	s0, r0
  20551a:	f001 ff4b 	bl	2073b4 <arm_sin_f32>
  20551e:	edd4 7a00 	vldr	s15, [r4]
						  power1=(float)arm_sin_f32((digree-135)*M_PI/180)*power;
  205522:	6828      	ldr	r0, [r5, #0]
						  power2=(float)arm_sin_f32((digree-45)*M_PI/180)*power;
  205524:	eef8 7ae7 	vcvt.f32.s32	s15, s15
						  power1=(float)arm_sin_f32((digree-135)*M_PI/180)*power;
  205528:	3887      	subs	r0, #135	; 0x87
						  power2=(float)arm_sin_f32((digree-45)*M_PI/180)*power;
  20552a:	ee27 0a80 	vmul.f32	s0, s15, s0
  20552e:	eebd 0ac0 	vcvt.s32.f32	s0, s0
  205532:	ed87 0a00 	vstr	s0, [r7]
						  power1=(float)arm_sin_f32((digree-135)*M_PI/180)*power;
  205536:	f7fa ffb9 	bl	2004ac <__aeabi_i2d>
  20553a:	a357      	add	r3, pc, #348	; (adr r3, 205698 <motor_move+0x778>)
  20553c:	e9d3 2300 	ldrd	r2, r3, [r3]
  205540:	f7fb f81a 	bl	200578 <__aeabi_dmul>
  205544:	2200      	movs	r2, #0
  205546:	4b58      	ldr	r3, [pc, #352]	; (2056a8 <motor_move+0x788>)
  205548:	f7fb f940 	bl	2007cc <__aeabi_ddiv>
  20554c:	f7fb fa26 	bl	20099c <__aeabi_d2f>
  205550:	ee00 0a10 	vmov	s0, r0
  205554:	f001 ff2e 	bl	2073b4 <arm_sin_f32>
  205558:	edd4 7a00 	vldr	s15, [r4]
						  power4=(float)arm_sin_f32((225-digree)*M_PI/180)*power;
  20555c:	6828      	ldr	r0, [r5, #0]
						  power1=(float)arm_sin_f32((digree-135)*M_PI/180)*power;
  20555e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
						  power4=(float)arm_sin_f32((225-digree)*M_PI/180)*power;
  205562:	f1c0 00e1 	rsb	r0, r0, #225	; 0xe1
						  power1=(float)arm_sin_f32((digree-135)*M_PI/180)*power;
  205566:	ee27 0a80 	vmul.f32	s0, s15, s0
  20556a:	eebd 0ac0 	vcvt.s32.f32	s0, s0
  20556e:	ed88 0a00 	vstr	s0, [r8]
						  power4=(float)arm_sin_f32((225-digree)*M_PI/180)*power;
  205572:	f7fa ff9b 	bl	2004ac <__aeabi_i2d>
  205576:	a348      	add	r3, pc, #288	; (adr r3, 205698 <motor_move+0x778>)
  205578:	e9d3 2300 	ldrd	r2, r3, [r3]
  20557c:	f7fa fffc 	bl	200578 <__aeabi_dmul>
  205580:	2200      	movs	r2, #0
  205582:	4b49      	ldr	r3, [pc, #292]	; (2056a8 <motor_move+0x788>)
  205584:	f7fb f922 	bl	2007cc <__aeabi_ddiv>
  205588:	f7fb fa08 	bl	20099c <__aeabi_d2f>
  20558c:	ee00 0a10 	vmov	s0, r0
  205590:	f001 ff10 	bl	2073b4 <arm_sin_f32>
  205594:	edd4 7a00 	vldr	s15, [r4]
						  power3=(float)arm_sin_f32((315-digree)*M_PI/180)*power;
  205598:	6828      	ldr	r0, [r5, #0]
						  power4=(float)arm_sin_f32((225-digree)*M_PI/180)*power;
  20559a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
						  power3=(float)arm_sin_f32((315-digree)*M_PI/180)*power;
  20559e:	f5c0 709d 	rsb	r0, r0, #314	; 0x13a
						  power4=(float)arm_sin_f32((225-digree)*M_PI/180)*power;
  2055a2:	ee27 0a80 	vmul.f32	s0, s15, s0
						  power3=(float)arm_sin_f32((315-digree)*M_PI/180)*power;
  2055a6:	3001      	adds	r0, #1
						  power4=(float)arm_sin_f32((225-digree)*M_PI/180)*power;
  2055a8:	eebd 0ac0 	vcvt.s32.f32	s0, s0
  2055ac:	ed86 0a00 	vstr	s0, [r6]
						  power3=(float)arm_sin_f32((315-digree)*M_PI/180)*power;
  2055b0:	f7fa ff7c 	bl	2004ac <__aeabi_i2d>
  2055b4:	a338      	add	r3, pc, #224	; (adr r3, 205698 <motor_move+0x778>)
  2055b6:	e9d3 2300 	ldrd	r2, r3, [r3]
  2055ba:	f7fa ffdd 	bl	200578 <__aeabi_dmul>
  2055be:	2200      	movs	r2, #0
  2055c0:	4b39      	ldr	r3, [pc, #228]	; (2056a8 <motor_move+0x788>)
  2055c2:	f7fb f903 	bl	2007cc <__aeabi_ddiv>
  2055c6:	f7fb f9e9 	bl	20099c <__aeabi_d2f>
  2055ca:	ee00 0a10 	vmov	s0, r0
  2055ce:	f001 fef1 	bl	2073b4 <arm_sin_f32>
  2055d2:	ed94 7a00 	vldr	s14, [r4]
  2055d6:	f8d8 3000 	ldr.w	r3, [r8]
						  motor1(power1,0);
  2055da:	2100      	movs	r1, #0
						  power3=(float)arm_sin_f32((315-digree)*M_PI/180)*power;
  2055dc:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
  2055e0:	683a      	ldr	r2, [r7, #0]
						  power3=power3*((float)power/y);
  2055e2:	4c32      	ldr	r4, [pc, #200]	; (2056ac <motor_move+0x78c>)
  2055e4:	4293      	cmp	r3, r2
						  power3=(float)arm_sin_f32((315-digree)*M_PI/180)*power;
  2055e6:	ee20 0a07 	vmul.f32	s0, s0, s14
  2055ea:	bfb8      	it	lt
  2055ec:	4613      	movlt	r3, r2
						  temp1=max(power1,power2);
  2055ee:	4a30      	ldr	r2, [pc, #192]	; (2056b0 <motor_move+0x790>)
						  power3=(float)arm_sin_f32((315-digree)*M_PI/180)*power;
  2055f0:	eebd 0ac0 	vcvt.s32.f32	s0, s0
						  temp1=max(power1,power2);
  2055f4:	6013      	str	r3, [r2, #0]
  2055f6:	ee10 2a10 	vmov	r2, s0
						  power3=power3*((float)power/y);
  2055fa:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
  2055fe:	4293      	cmp	r3, r2
  205600:	bfb8      	it	lt
  205602:	4613      	movlt	r3, r2
						  temp2=max(power3,temp1);
  205604:	4a2b      	ldr	r2, [pc, #172]	; (2056b4 <motor_move+0x794>)
  205606:	6013      	str	r3, [r2, #0]
  205608:	6832      	ldr	r2, [r6, #0]
  20560a:	4293      	cmp	r3, r2
  20560c:	bfb8      	it	lt
  20560e:	4613      	movlt	r3, r2
						  y=max(power4,temp2);
  205610:	4a29      	ldr	r2, [pc, #164]	; (2056b8 <motor_move+0x798>)
						  power1=power1*((float)power/y);
  205612:	ee07 3a90 	vmov	s15, r3
						  y=max(power4,temp2);
  205616:	6013      	str	r3, [r2, #0]
						  power1=power1*((float)power/y);
  205618:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  20561c:	eec7 6a27 	vdiv.f32	s13, s14, s15
  205620:	edd8 7a00 	vldr	s15, [r8]
  205624:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  205628:	ee67 7aa6 	vmul.f32	s15, s15, s13
						  power3=power3*((float)power/y);
  20562c:	ee20 0a26 	vmul.f32	s0, s0, s13
						  power1=power1*((float)power/y);
  205630:	eefd 7ae7 	vcvt.s32.f32	s15, s15
						  power3=power3*((float)power/y);
  205634:	eebd 0ac0 	vcvt.s32.f32	s0, s0
						  power1=power1*((float)power/y);
  205638:	ee17 0a90 	vmov	r0, s15
  20563c:	edc8 7a00 	vstr	s15, [r8]
						  power2=power2*((float)power/y);
  205640:	edd7 7a00 	vldr	s15, [r7]
						  power3=power3*((float)power/y);
  205644:	ed84 0a00 	vstr	s0, [r4]
						  power2=power2*((float)power/y);
  205648:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
						  power4=power4*((float)power/y);
  20564c:	edd6 7a00 	vldr	s15, [r6]
  205650:	eef8 7ae7 	vcvt.f32.s32	s15, s15
						  power2=power2*((float)power/y);
  205654:	ee27 7a26 	vmul.f32	s14, s14, s13
						  power4=power4*((float)power/y);
  205658:	ee67 7aa6 	vmul.f32	s15, s15, s13
						  power2=power2*((float)power/y);
  20565c:	eebd 7ac7 	vcvt.s32.f32	s14, s14
						  power4=power4*((float)power/y);
  205660:	eefd 7ae7 	vcvt.s32.f32	s15, s15
						  power2=power2*((float)power/y);
  205664:	ed87 7a00 	vstr	s14, [r7]
						  power4=power4*((float)power/y);
  205668:	edc6 7a00 	vstr	s15, [r6]
						  motor1(power1,0);
  20566c:	f7fe f86e 	bl	20374c <motor1>
						  motor2(power2,0);
  205670:	2100      	movs	r1, #0
  205672:	6838      	ldr	r0, [r7, #0]
  205674:	f7fe f888 	bl	203788 <motor2>
						  motor3(power3,0);
  205678:	2100      	movs	r1, #0
  20567a:	6820      	ldr	r0, [r4, #0]
  20567c:	f7fe f8a2 	bl	2037c4 <motor3>
						  motor4(power4,0);
  205680:	2100      	movs	r1, #0
  205682:	6830      	ldr	r0, [r6, #0]
  205684:	f7fe f8bc 	bl	203800 <motor4>
							HAL_GPIO_WritePin(GPIOE,GPIO_PIN_10,1);
  205688:	2201      	movs	r2, #1
  20568a:	f44f 6180 	mov.w	r1, #1024	; 0x400
  20568e:	4804      	ldr	r0, [pc, #16]	; (2056a0 <motor_move+0x780>)
  205690:	f7fb fd26 	bl	2010e0 <HAL_GPIO_WritePin>
						  digtemp=180;
  205694:	23b4      	movs	r3, #180	; 0xb4
  205696:	e6e6      	b.n	205466 <motor_move+0x546>
  205698:	54442d18 	.word	0x54442d18
  20569c:	400921fb 	.word	0x400921fb
  2056a0:	40021000 	.word	0x40021000
  2056a4:	002077e3 	.word	0x002077e3
  2056a8:	40668000 	.word	0x40668000
  2056ac:	20000198 	.word	0x20000198
  2056b0:	200001b0 	.word	0x200001b0
  2056b4:	2000017c 	.word	0x2000017c
  2056b8:	200001fc 	.word	0x200001fc
				  else if(digree>180 && digree<=225){
  2056bc:	f2a2 429d 	subw	r2, r2, #1181	; 0x49d
					  else if(digree>180 && digree<=225){
  2056c0:	2a2c      	cmp	r2, #44	; 0x2c
  2056c2:	f67f aef9 	bls.w	2054b8 <motor_move+0x598>
					  else if(digree>225 && digree<=270){
  2056c6:	f1a3 02e2 	sub.w	r2, r3, #226	; 0xe2
  2056ca:	2a2c      	cmp	r2, #44	; 0x2c
  2056cc:	f200 830a 	bhi.w	205ce4 <motor_move+0xdc4>
						  if(digtemp!=270){
  2056d0:	f8d9 3000 	ldr.w	r3, [r9]
						  if(digtemp!=270){
  2056d4:	f5b3 7f87 	cmp.w	r3, #270	; 0x10e
  2056d8:	d01b      	beq.n	205712 <motor_move+0x7f2>
							  motor1(0,0);
  2056da:	2100      	movs	r1, #0
  2056dc:	4608      	mov	r0, r1
  2056de:	f7fe f835 	bl	20374c <motor1>
							  motor2(0,0);
  2056e2:	2100      	movs	r1, #0
  2056e4:	4608      	mov	r0, r1
  2056e6:	f7fe f84f 	bl	203788 <motor2>
							  motor3(0,0);
  2056ea:	2100      	movs	r1, #0
  2056ec:	4608      	mov	r0, r1
  2056ee:	f7fe f869 	bl	2037c4 <motor3>
							  motor4(0,0);
  2056f2:	2100      	movs	r1, #0
  2056f4:	4608      	mov	r0, r1
  2056f6:	f7fe f883 	bl	203800 <motor4>
								HAL_GPIO_WritePin(GPIOE,GPIO_PIN_10,0);
  2056fa:	2200      	movs	r2, #0
  2056fc:	f44f 6180 	mov.w	r1, #1024	; 0x400
  205700:	486f      	ldr	r0, [pc, #444]	; (2058c0 <motor_move+0x9a0>)
  205702:	f7fb fced 	bl	2010e0 <HAL_GPIO_WritePin>
							xprintf("bleak now\r\n");
  205706:	486f      	ldr	r0, [pc, #444]	; (2058c4 <motor_move+0x9a4>)
  205708:	f001 fe1c 	bl	207344 <xprintf>
							  HAL_Delay(bleak_time);
  20570c:	2014      	movs	r0, #20
  20570e:	f7fb f9c9 	bl	200aa4 <HAL_Delay>
						  power2=(float)arm_sin_f32((digree-45)*M_PI/180)*-1*power;
  205712:	6828      	ldr	r0, [r5, #0]
  205714:	382d      	subs	r0, #45	; 0x2d
  205716:	f7fa fec9 	bl	2004ac <__aeabi_i2d>
  20571a:	a367      	add	r3, pc, #412	; (adr r3, 2058b8 <motor_move+0x998>)
  20571c:	e9d3 2300 	ldrd	r2, r3, [r3]
  205720:	f7fa ff2a 	bl	200578 <__aeabi_dmul>
  205724:	2200      	movs	r2, #0
  205726:	4b68      	ldr	r3, [pc, #416]	; (2058c8 <motor_move+0x9a8>)
  205728:	f7fb f850 	bl	2007cc <__aeabi_ddiv>
  20572c:	f7fb f936 	bl	20099c <__aeabi_d2f>
  205730:	ee00 0a10 	vmov	s0, r0
  205734:	f001 fe3e 	bl	2073b4 <arm_sin_f32>
  205738:	edd4 7a00 	vldr	s15, [r4]
						  power1=(float)arm_sin_f32((digree-135)*M_PI/180)*power;
  20573c:	6828      	ldr	r0, [r5, #0]
						  power2=(float)arm_sin_f32((digree-45)*M_PI/180)*-1*power;
  20573e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
						  power1=(float)arm_sin_f32((digree-135)*M_PI/180)*power;
  205742:	3887      	subs	r0, #135	; 0x87
						  power2=(float)arm_sin_f32((digree-45)*M_PI/180)*-1*power;
  205744:	ee20 0a67 	vnmul.f32	s0, s0, s15
  205748:	eebd 0ac0 	vcvt.s32.f32	s0, s0
  20574c:	ed87 0a00 	vstr	s0, [r7]
						  power1=(float)arm_sin_f32((digree-135)*M_PI/180)*power;
  205750:	f7fa feac 	bl	2004ac <__aeabi_i2d>
  205754:	a358      	add	r3, pc, #352	; (adr r3, 2058b8 <motor_move+0x998>)
  205756:	e9d3 2300 	ldrd	r2, r3, [r3]
  20575a:	f7fa ff0d 	bl	200578 <__aeabi_dmul>
  20575e:	2200      	movs	r2, #0
  205760:	4b59      	ldr	r3, [pc, #356]	; (2058c8 <motor_move+0x9a8>)
  205762:	f7fb f833 	bl	2007cc <__aeabi_ddiv>
  205766:	f7fb f919 	bl	20099c <__aeabi_d2f>
  20576a:	ee00 0a10 	vmov	s0, r0
  20576e:	f001 fe21 	bl	2073b4 <arm_sin_f32>
  205772:	edd4 7a00 	vldr	s15, [r4]
						  power4=(float)arm_sin_f32((digree-225)*M_PI/180)*power;
  205776:	6828      	ldr	r0, [r5, #0]
						  power1=(float)arm_sin_f32((digree-135)*M_PI/180)*power;
  205778:	eef8 7ae7 	vcvt.f32.s32	s15, s15
						  power4=(float)arm_sin_f32((digree-225)*M_PI/180)*power;
  20577c:	38e1      	subs	r0, #225	; 0xe1
						  power1=(float)arm_sin_f32((digree-135)*M_PI/180)*power;
  20577e:	ee27 0a80 	vmul.f32	s0, s15, s0
  205782:	eebd 0ac0 	vcvt.s32.f32	s0, s0
  205786:	ed88 0a00 	vstr	s0, [r8]
						  power4=(float)arm_sin_f32((digree-225)*M_PI/180)*power;
  20578a:	f7fa fe8f 	bl	2004ac <__aeabi_i2d>
  20578e:	a34a      	add	r3, pc, #296	; (adr r3, 2058b8 <motor_move+0x998>)
  205790:	e9d3 2300 	ldrd	r2, r3, [r3]
  205794:	f7fa fef0 	bl	200578 <__aeabi_dmul>
  205798:	2200      	movs	r2, #0
  20579a:	4b4b      	ldr	r3, [pc, #300]	; (2058c8 <motor_move+0x9a8>)
  20579c:	f7fb f816 	bl	2007cc <__aeabi_ddiv>
  2057a0:	f7fb f8fc 	bl	20099c <__aeabi_d2f>
  2057a4:	ee00 0a10 	vmov	s0, r0
  2057a8:	f001 fe04 	bl	2073b4 <arm_sin_f32>
  2057ac:	edd4 7a00 	vldr	s15, [r4]
						  power3=(float)arm_sin_f32((315-digree)*M_PI/180)*power;
  2057b0:	6828      	ldr	r0, [r5, #0]
						  power4=(float)arm_sin_f32((digree-225)*M_PI/180)*power;
  2057b2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
						  power3=(float)arm_sin_f32((315-digree)*M_PI/180)*power;
  2057b6:	f5c0 709d 	rsb	r0, r0, #314	; 0x13a
						  power4=(float)arm_sin_f32((digree-225)*M_PI/180)*power;
  2057ba:	ee27 0a80 	vmul.f32	s0, s15, s0
						  power3=(float)arm_sin_f32((315-digree)*M_PI/180)*power;
  2057be:	3001      	adds	r0, #1
						  power4=(float)arm_sin_f32((digree-225)*M_PI/180)*power;
  2057c0:	eebd 0ac0 	vcvt.s32.f32	s0, s0
  2057c4:	ed86 0a00 	vstr	s0, [r6]
						  power3=(float)arm_sin_f32((315-digree)*M_PI/180)*power;
  2057c8:	f7fa fe70 	bl	2004ac <__aeabi_i2d>
  2057cc:	a33a      	add	r3, pc, #232	; (adr r3, 2058b8 <motor_move+0x998>)
  2057ce:	e9d3 2300 	ldrd	r2, r3, [r3]
  2057d2:	f7fa fed1 	bl	200578 <__aeabi_dmul>
  2057d6:	2200      	movs	r2, #0
  2057d8:	4b3b      	ldr	r3, [pc, #236]	; (2058c8 <motor_move+0x9a8>)
  2057da:	f7fa fff7 	bl	2007cc <__aeabi_ddiv>
  2057de:	f7fb f8dd 	bl	20099c <__aeabi_d2f>
  2057e2:	ee00 0a10 	vmov	s0, r0
  2057e6:	f001 fde5 	bl	2073b4 <arm_sin_f32>
  2057ea:	ed94 7a00 	vldr	s14, [r4]
  2057ee:	f8d8 3000 	ldr.w	r3, [r8]
						  motor1(power1,0);
  2057f2:	2100      	movs	r1, #0
						  power3=(float)arm_sin_f32((315-digree)*M_PI/180)*power;
  2057f4:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
  2057f8:	683a      	ldr	r2, [r7, #0]
						  power3=power3*((float)power/y);
  2057fa:	4c34      	ldr	r4, [pc, #208]	; (2058cc <motor_move+0x9ac>)
  2057fc:	4293      	cmp	r3, r2
						  power3=(float)arm_sin_f32((315-digree)*M_PI/180)*power;
  2057fe:	ee20 0a07 	vmul.f32	s0, s0, s14
  205802:	bfb8      	it	lt
  205804:	4613      	movlt	r3, r2
						  temp1=max(power1,power2);
  205806:	4a32      	ldr	r2, [pc, #200]	; (2058d0 <motor_move+0x9b0>)
						  power3=(float)arm_sin_f32((315-digree)*M_PI/180)*power;
  205808:	eebd 0ac0 	vcvt.s32.f32	s0, s0
						  temp1=max(power1,power2);
  20580c:	6013      	str	r3, [r2, #0]
  20580e:	ee10 2a10 	vmov	r2, s0
						  power3=power3*((float)power/y);
  205812:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
  205816:	4293      	cmp	r3, r2
  205818:	bfb8      	it	lt
  20581a:	4613      	movlt	r3, r2
						  temp2=max(power3,temp1);
  20581c:	4a2d      	ldr	r2, [pc, #180]	; (2058d4 <motor_move+0x9b4>)
  20581e:	6013      	str	r3, [r2, #0]
  205820:	6832      	ldr	r2, [r6, #0]
  205822:	4293      	cmp	r3, r2
  205824:	bfb8      	it	lt
  205826:	4613      	movlt	r3, r2
						  y=max(power4,temp2);
  205828:	4a2b      	ldr	r2, [pc, #172]	; (2058d8 <motor_move+0x9b8>)
						  power1=power1*((float)power/y);
  20582a:	ee07 3a90 	vmov	s15, r3
						  y=max(power4,temp2);
  20582e:	6013      	str	r3, [r2, #0]
						  power1=power1*((float)power/y);
  205830:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  205834:	eec7 6a27 	vdiv.f32	s13, s14, s15
  205838:	edd8 7a00 	vldr	s15, [r8]
  20583c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  205840:	ee67 7aa6 	vmul.f32	s15, s15, s13
						  power3=power3*((float)power/y);
  205844:	ee20 0a26 	vmul.f32	s0, s0, s13
						  power1=power1*((float)power/y);
  205848:	eefd 7ae7 	vcvt.s32.f32	s15, s15
						  power3=power3*((float)power/y);
  20584c:	eebd 0ac0 	vcvt.s32.f32	s0, s0
						  power1=power1*((float)power/y);
  205850:	ee17 0a90 	vmov	r0, s15
  205854:	edc8 7a00 	vstr	s15, [r8]
						  power2=power2*((float)power/y);
  205858:	edd7 7a00 	vldr	s15, [r7]
						  power3=power3*((float)power/y);
  20585c:	ed84 0a00 	vstr	s0, [r4]
						  power2=power2*((float)power/y);
  205860:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
						  power4=power4*((float)power/y);
  205864:	edd6 7a00 	vldr	s15, [r6]
  205868:	eef8 7ae7 	vcvt.f32.s32	s15, s15
						  power2=power2*((float)power/y);
  20586c:	ee27 7a26 	vmul.f32	s14, s14, s13
						  power4=power4*((float)power/y);
  205870:	ee67 7aa6 	vmul.f32	s15, s15, s13
						  power2=power2*((float)power/y);
  205874:	eebd 7ac7 	vcvt.s32.f32	s14, s14
						  power4=power4*((float)power/y);
  205878:	eefd 7ae7 	vcvt.s32.f32	s15, s15
						  power2=power2*((float)power/y);
  20587c:	ed87 7a00 	vstr	s14, [r7]
						  power4=power4*((float)power/y);
  205880:	edc6 7a00 	vstr	s15, [r6]
						  motor1(power1,0);
  205884:	f7fd ff62 	bl	20374c <motor1>
						  motor2(0,power2);
  205888:	6839      	ldr	r1, [r7, #0]
  20588a:	2000      	movs	r0, #0
  20588c:	f7fd ff7c 	bl	203788 <motor2>
						  motor3(power3,0);
  205890:	2100      	movs	r1, #0
  205892:	6820      	ldr	r0, [r4, #0]
  205894:	f7fd ff96 	bl	2037c4 <motor3>
						  motor4(0,power4);
  205898:	6831      	ldr	r1, [r6, #0]
  20589a:	2000      	movs	r0, #0
  20589c:	f7fd ffb0 	bl	203800 <motor4>
							HAL_GPIO_WritePin(GPIOE,GPIO_PIN_10,1);
  2058a0:	2201      	movs	r2, #1
  2058a2:	f44f 6180 	mov.w	r1, #1024	; 0x400
  2058a6:	4806      	ldr	r0, [pc, #24]	; (2058c0 <motor_move+0x9a0>)
  2058a8:	f7fb fc1a 	bl	2010e0 <HAL_GPIO_WritePin>
						  digtemp=270;
  2058ac:	f44f 7387 	mov.w	r3, #270	; 0x10e
  2058b0:	e5d9      	b.n	205466 <motor_move+0x546>
  2058b2:	bf00      	nop
  2058b4:	f3af 8000 	nop.w
  2058b8:	54442d18 	.word	0x54442d18
  2058bc:	400921fb 	.word	0x400921fb
  2058c0:	40021000 	.word	0x40021000
  2058c4:	002077e3 	.word	0x002077e3
  2058c8:	40668000 	.word	0x40668000
  2058cc:	20000198 	.word	0x20000198
  2058d0:	200001b0 	.word	0x200001b0
  2058d4:	2000017c 	.word	0x2000017c
  2058d8:	200001fc 	.word	0x200001fc
				HOUI=JY901_yaw_get(HOUI_def);
  2058dc:	4fc8      	ldr	r7, [pc, #800]	; (205c00 <motor_move+0xce0>)
  2058de:	4ec9      	ldr	r6, [pc, #804]	; (205c04 <motor_move+0xce4>)
  2058e0:	8838      	ldrh	r0, [r7, #0]
  2058e2:	46bb      	mov	fp, r7
  2058e4:	f7fd fce4 	bl	2032b0 <JY901_yaw_get>
  2058e8:	b280      	uxth	r0, r0
  2058ea:	8030      	strh	r0, [r6, #0]
				if(HOUI>= 5 && HOUI<=355){
  2058ec:	3805      	subs	r0, #5
  2058ee:	f5b0 7faf 	cmp.w	r0, #350	; 0x15e
  2058f2:	d83c      	bhi.n	20596e <motor_move+0xa4e>
					motor1(0,0);
  2058f4:	2100      	movs	r1, #0
						HAL_GPIO_WritePin(GPIOE,GPIO_PIN_10,1);
  2058f6:	f8df 9310 	ldr.w	r9, [pc, #784]	; 205c08 <motor_move+0xce8>
						xprintf(" speed= %d\r\n",(int)map_m(HOUI,359,180,70,300));
  2058fa:	f8df a338 	ldr.w	sl, [pc, #824]	; 205c34 <motor_move+0xd14>
					motor1(0,0);
  2058fe:	4608      	mov	r0, r1
  205900:	f7fd ff24 	bl	20374c <motor1>
					motor2(0,0);
  205904:	2100      	movs	r1, #0
  205906:	4608      	mov	r0, r1
  205908:	f7fd ff3e 	bl	203788 <motor2>
					motor3(0,0);
  20590c:	2100      	movs	r1, #0
  20590e:	4608      	mov	r0, r1
  205910:	f7fd ff58 	bl	2037c4 <motor3>
					motor4(0,0);
  205914:	2100      	movs	r1, #0
  205916:	4608      	mov	r0, r1
  205918:	f7fd ff72 	bl	203800 <motor4>
					HAL_GPIO_WritePin(GPIOE,GPIO_PIN_10,0);
  20591c:	2200      	movs	r2, #0
  20591e:	f44f 6180 	mov.w	r1, #1024	; 0x400
  205922:	48b9      	ldr	r0, [pc, #740]	; (205c08 <motor_move+0xce8>)
  205924:	f7fb fbdc 	bl	2010e0 <HAL_GPIO_WritePin>
					HAL_Delay(20);
  205928:	2014      	movs	r0, #20
  20592a:	f7fb f8bb 	bl	200aa4 <HAL_Delay>
					while(HOUI>=5 && HOUI<=355){
  20592e:	8833      	ldrh	r3, [r6, #0]
  205930:	3b05      	subs	r3, #5
  205932:	b29b      	uxth	r3, r3
  205934:	f5b3 7faf 	cmp.w	r3, #350	; 0x15e
  205938:	f240 8118 	bls.w	205b6c <motor_move+0xc4c>
					motor1(0,0);
  20593c:	2100      	movs	r1, #0
  20593e:	4608      	mov	r0, r1
  205940:	f7fd ff04 	bl	20374c <motor1>
					motor2(0,0);
  205944:	2100      	movs	r1, #0
  205946:	4608      	mov	r0, r1
  205948:	f7fd ff1e 	bl	203788 <motor2>
					motor3(0,0);
  20594c:	2100      	movs	r1, #0
  20594e:	4608      	mov	r0, r1
  205950:	f7fd ff38 	bl	2037c4 <motor3>
					motor4(0,0);
  205954:	2100      	movs	r1, #0
  205956:	4608      	mov	r0, r1
  205958:	f7fd ff52 	bl	203800 <motor4>
					HAL_GPIO_WritePin(GPIOE,GPIO_PIN_10,0);
  20595c:	48aa      	ldr	r0, [pc, #680]	; (205c08 <motor_move+0xce8>)
  20595e:	2200      	movs	r2, #0
  205960:	f44f 6180 	mov.w	r1, #1024	; 0x400
  205964:	f7fb fbbc 	bl	2010e0 <HAL_GPIO_WritePin>
					HAL_Delay(20);
  205968:	2014      	movs	r0, #20
  20596a:	f7fb f89b 	bl	200aa4 <HAL_Delay>
				  if(digree>=0 && digree<=360){
  20596e:	682b      	ldr	r3, [r5, #0]
  205970:	f5b3 7fb4 	cmp.w	r3, #360	; 0x168
  205974:	f63f aaf4 	bhi.w	204f60 <motor_move+0x40>
					  if(digree>=0 && digree<=45){
  205978:	2b2d      	cmp	r3, #45	; 0x2d
  20597a:	f8df 92bc 	ldr.w	r9, [pc, #700]	; 205c38 <motor_move+0xd18>
  20597e:	4fa3      	ldr	r7, [pc, #652]	; (205c0c <motor_move+0xcec>)
  205980:	f8df 82b8 	ldr.w	r8, [pc, #696]	; 205c3c <motor_move+0xd1c>
  205984:	4ea2      	ldr	r6, [pc, #648]	; (205c10 <motor_move+0xcf0>)
  205986:	f200 819b 	bhi.w	205cc0 <motor_move+0xda0>
						if(digtemp!=0){
  20598a:	f8d9 3000 	ldr.w	r3, [r9]
  20598e:	b1db      	cbz	r3, 2059c8 <motor_move+0xaa8>
								motor1(0,0);
  205990:	2100      	movs	r1, #0
  205992:	4608      	mov	r0, r1
  205994:	f7fd feda 	bl	20374c <motor1>
								motor2(0,0);
  205998:	2100      	movs	r1, #0
  20599a:	4608      	mov	r0, r1
  20599c:	f7fd fef4 	bl	203788 <motor2>
								motor3(0,0);
  2059a0:	2100      	movs	r1, #0
  2059a2:	4608      	mov	r0, r1
  2059a4:	f7fd ff0e 	bl	2037c4 <motor3>
								motor4(0,0);
  2059a8:	2100      	movs	r1, #0
  2059aa:	4608      	mov	r0, r1
  2059ac:	f7fd ff28 	bl	203800 <motor4>
								HAL_GPIO_WritePin(GPIOE,GPIO_PIN_10,0);
  2059b0:	2200      	movs	r2, #0
  2059b2:	f44f 6180 	mov.w	r1, #1024	; 0x400
  2059b6:	4894      	ldr	r0, [pc, #592]	; (205c08 <motor_move+0xce8>)
  2059b8:	f7fb fb92 	bl	2010e0 <HAL_GPIO_WritePin>
								xprintf("bleak now\r\n");
  2059bc:	4895      	ldr	r0, [pc, #596]	; (205c14 <motor_move+0xcf4>)
  2059be:	f001 fcc1 	bl	207344 <xprintf>
								HAL_Delay(bleak_time);
  2059c2:	2014      	movs	r0, #20
  2059c4:	f7fb f86e 	bl	200aa4 <HAL_Delay>
						  power2=(float)arm_sin_f32((45-digree)*M_PI/180)*power;
  2059c8:	6828      	ldr	r0, [r5, #0]
  2059ca:	f1c0 002d 	rsb	r0, r0, #45	; 0x2d
  2059ce:	f7fa fd6d 	bl	2004ac <__aeabi_i2d>
  2059d2:	a389      	add	r3, pc, #548	; (adr r3, 205bf8 <motor_move+0xcd8>)
  2059d4:	e9d3 2300 	ldrd	r2, r3, [r3]
  2059d8:	f7fa fdce 	bl	200578 <__aeabi_dmul>
  2059dc:	2200      	movs	r2, #0
  2059de:	4b8e      	ldr	r3, [pc, #568]	; (205c18 <motor_move+0xcf8>)
  2059e0:	f7fa fef4 	bl	2007cc <__aeabi_ddiv>
  2059e4:	f7fa ffda 	bl	20099c <__aeabi_d2f>
  2059e8:	ee00 0a10 	vmov	s0, r0
  2059ec:	f001 fce2 	bl	2073b4 <arm_sin_f32>
  2059f0:	edd4 7a00 	vldr	s15, [r4]
						  power1=(float)arm_sin_f32((135-digree)*M_PI/180)*power;
  2059f4:	6828      	ldr	r0, [r5, #0]
						  power2=(float)arm_sin_f32((45-digree)*M_PI/180)*power;
  2059f6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
						  power1=(float)arm_sin_f32((135-digree)*M_PI/180)*power;
  2059fa:	f1c0 0087 	rsb	r0, r0, #135	; 0x87
						  power2=(float)arm_sin_f32((45-digree)*M_PI/180)*power;
  2059fe:	ee27 0a80 	vmul.f32	s0, s15, s0
  205a02:	eebd 0ac0 	vcvt.s32.f32	s0, s0
  205a06:	ed87 0a00 	vstr	s0, [r7]
						  power1=(float)arm_sin_f32((135-digree)*M_PI/180)*power;
  205a0a:	f7fa fd4f 	bl	2004ac <__aeabi_i2d>
  205a0e:	a37a      	add	r3, pc, #488	; (adr r3, 205bf8 <motor_move+0xcd8>)
  205a10:	e9d3 2300 	ldrd	r2, r3, [r3]
  205a14:	f7fa fdb0 	bl	200578 <__aeabi_dmul>
  205a18:	2200      	movs	r2, #0
  205a1a:	4b7f      	ldr	r3, [pc, #508]	; (205c18 <motor_move+0xcf8>)
  205a1c:	f7fa fed6 	bl	2007cc <__aeabi_ddiv>
  205a20:	f7fa ffbc 	bl	20099c <__aeabi_d2f>
  205a24:	ee00 0a10 	vmov	s0, r0
  205a28:	f001 fcc4 	bl	2073b4 <arm_sin_f32>
  205a2c:	edd4 7a00 	vldr	s15, [r4]
						  power4=(float)arm_sin_f32((225-digree)*M_PI/180)*-1*power;
  205a30:	6828      	ldr	r0, [r5, #0]
						  power1=(float)arm_sin_f32((135-digree)*M_PI/180)*power;
  205a32:	eef8 7ae7 	vcvt.f32.s32	s15, s15
						  power4=(float)arm_sin_f32((225-digree)*M_PI/180)*-1*power;
  205a36:	f1c0 00e1 	rsb	r0, r0, #225	; 0xe1
						  power1=(float)arm_sin_f32((135-digree)*M_PI/180)*power;
  205a3a:	ee27 0a80 	vmul.f32	s0, s15, s0
  205a3e:	eebd 0ac0 	vcvt.s32.f32	s0, s0
  205a42:	ed88 0a00 	vstr	s0, [r8]
						  power4=(float)arm_sin_f32((225-digree)*M_PI/180)*-1*power;
  205a46:	f7fa fd31 	bl	2004ac <__aeabi_i2d>
  205a4a:	a36b      	add	r3, pc, #428	; (adr r3, 205bf8 <motor_move+0xcd8>)
  205a4c:	e9d3 2300 	ldrd	r2, r3, [r3]
  205a50:	f7fa fd92 	bl	200578 <__aeabi_dmul>
  205a54:	2200      	movs	r2, #0
  205a56:	4b70      	ldr	r3, [pc, #448]	; (205c18 <motor_move+0xcf8>)
  205a58:	f7fa feb8 	bl	2007cc <__aeabi_ddiv>
  205a5c:	f7fa ff9e 	bl	20099c <__aeabi_d2f>
  205a60:	ee00 0a10 	vmov	s0, r0
  205a64:	f001 fca6 	bl	2073b4 <arm_sin_f32>
  205a68:	edd4 7a00 	vldr	s15, [r4]
						  power3=(float)arm_sin_f32((315-digree)*M_PI/180)*-1*power;
  205a6c:	6828      	ldr	r0, [r5, #0]
						  power4=(float)arm_sin_f32((225-digree)*M_PI/180)*-1*power;
  205a6e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
						  power3=(float)arm_sin_f32((315-digree)*M_PI/180)*-1*power;
  205a72:	f5c0 709d 	rsb	r0, r0, #314	; 0x13a
						  power4=(float)arm_sin_f32((225-digree)*M_PI/180)*-1*power;
  205a76:	ee20 0a67 	vnmul.f32	s0, s0, s15
						  power3=(float)arm_sin_f32((315-digree)*M_PI/180)*-1*power;
  205a7a:	3001      	adds	r0, #1
						  power4=(float)arm_sin_f32((225-digree)*M_PI/180)*-1*power;
  205a7c:	eebd 0ac0 	vcvt.s32.f32	s0, s0
  205a80:	ed86 0a00 	vstr	s0, [r6]
						  power3=(float)arm_sin_f32((315-digree)*M_PI/180)*-1*power;
  205a84:	f7fa fd12 	bl	2004ac <__aeabi_i2d>
  205a88:	a35b      	add	r3, pc, #364	; (adr r3, 205bf8 <motor_move+0xcd8>)
  205a8a:	e9d3 2300 	ldrd	r2, r3, [r3]
  205a8e:	f7fa fd73 	bl	200578 <__aeabi_dmul>
  205a92:	2200      	movs	r2, #0
  205a94:	4b60      	ldr	r3, [pc, #384]	; (205c18 <motor_move+0xcf8>)
  205a96:	f7fa fe99 	bl	2007cc <__aeabi_ddiv>
  205a9a:	f7fa ff7f 	bl	20099c <__aeabi_d2f>
  205a9e:	ee00 0a10 	vmov	s0, r0
  205aa2:	f001 fc87 	bl	2073b4 <arm_sin_f32>
  205aa6:	ed94 7a00 	vldr	s14, [r4]
  205aaa:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
  205aae:	ee20 0a47 	vnmul.f32	s0, s0, s14
  205ab2:	f8d8 3000 	ldr.w	r3, [r8]
						  power3=(float)arm_sin_f32((digree-315)*M_PI/180)*power;
  205ab6:	eebd 0ac0 	vcvt.s32.f32	s0, s0
  205aba:	683a      	ldr	r2, [r7, #0]
						  motor1(0,power1);
  205abc:	2000      	movs	r0, #0
						  power3=power3*((float)power/y);
  205abe:	4c57      	ldr	r4, [pc, #348]	; (205c1c <motor_move+0xcfc>)
  205ac0:	4293      	cmp	r3, r2
  205ac2:	bfb8      	it	lt
  205ac4:	4613      	movlt	r3, r2
						  temp1=max(power1,power2);
  205ac6:	4a56      	ldr	r2, [pc, #344]	; (205c20 <motor_move+0xd00>)
  205ac8:	6013      	str	r3, [r2, #0]
  205aca:	ee10 2a10 	vmov	r2, s0
						  power3=power3*((float)power/y);
  205ace:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
  205ad2:	4293      	cmp	r3, r2
  205ad4:	bfb8      	it	lt
  205ad6:	4613      	movlt	r3, r2
						  temp2=max(power3,temp1);
  205ad8:	4a52      	ldr	r2, [pc, #328]	; (205c24 <motor_move+0xd04>)
  205ada:	6013      	str	r3, [r2, #0]
  205adc:	6832      	ldr	r2, [r6, #0]
  205ade:	4293      	cmp	r3, r2
  205ae0:	bfb8      	it	lt
  205ae2:	4613      	movlt	r3, r2
						  y=max(power4,temp2);
  205ae4:	4a50      	ldr	r2, [pc, #320]	; (205c28 <motor_move+0xd08>)
						  power1=power1*((float)power/y);
  205ae6:	ee07 3a90 	vmov	s15, r3
						  y=max(power4,temp2);
  205aea:	6013      	str	r3, [r2, #0]
						  power1=power1*((float)power/y);
  205aec:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  205af0:	eec7 6a27 	vdiv.f32	s13, s14, s15
  205af4:	edd8 7a00 	vldr	s15, [r8]
  205af8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  205afc:	ee67 7aa6 	vmul.f32	s15, s15, s13
						  power3=power3*((float)power/y);
  205b00:	ee20 0a26 	vmul.f32	s0, s0, s13
						  power1=power1*((float)power/y);
  205b04:	eefd 7ae7 	vcvt.s32.f32	s15, s15
						  power3=power3*((float)power/y);
  205b08:	eebd 0ac0 	vcvt.s32.f32	s0, s0
						  power1=power1*((float)power/y);
  205b0c:	ee17 1a90 	vmov	r1, s15
  205b10:	edc8 7a00 	vstr	s15, [r8]
						  power2=power2*((float)power/y);
  205b14:	edd7 7a00 	vldr	s15, [r7]
						  power3=power3*((float)power/y);
  205b18:	ed84 0a00 	vstr	s0, [r4]
						  power2=power2*((float)power/y);
  205b1c:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
						  power4=power4*((float)power/y);
  205b20:	edd6 7a00 	vldr	s15, [r6]
  205b24:	eef8 7ae7 	vcvt.f32.s32	s15, s15
						  power2=power2*((float)power/y);
  205b28:	ee27 7a26 	vmul.f32	s14, s14, s13
						  power4=power4*((float)power/y);
  205b2c:	ee67 7aa6 	vmul.f32	s15, s15, s13
						  power2=power2*((float)power/y);
  205b30:	eebd 7ac7 	vcvt.s32.f32	s14, s14
						  power4=power4*((float)power/y);
  205b34:	eefd 7ae7 	vcvt.s32.f32	s15, s15
						  power2=power2*((float)power/y);
  205b38:	ed87 7a00 	vstr	s14, [r7]
						  power4=power4*((float)power/y);
  205b3c:	edc6 7a00 	vstr	s15, [r6]
						  motor1(0,power1);
  205b40:	f7fd fe04 	bl	20374c <motor1>
						  motor2(0,power2);
  205b44:	6839      	ldr	r1, [r7, #0]
  205b46:	2000      	movs	r0, #0
  205b48:	f7fd fe1e 	bl	203788 <motor2>
						  motor3(0,power3);
  205b4c:	6821      	ldr	r1, [r4, #0]
  205b4e:	2000      	movs	r0, #0
  205b50:	f7fd fe38 	bl	2037c4 <motor3>
						  motor4(0,power4);
  205b54:	6831      	ldr	r1, [r6, #0]
  205b56:	2000      	movs	r0, #0
  205b58:	f7fd fe52 	bl	203800 <motor4>
							HAL_GPIO_WritePin(GPIOE,GPIO_PIN_10,1);
  205b5c:	2201      	movs	r2, #1
  205b5e:	f44f 6180 	mov.w	r1, #1024	; 0x400
  205b62:	4829      	ldr	r0, [pc, #164]	; (205c08 <motor_move+0xce8>)
  205b64:	f7fb fabc 	bl	2010e0 <HAL_GPIO_WritePin>
						  digtemp=0;
  205b68:	2300      	movs	r3, #0
  205b6a:	e47c      	b.n	205466 <motor_move+0x546>
					HOUI=JY901_yaw_get(HOUI_def);
  205b6c:	f8bb 0000 	ldrh.w	r0, [fp]
  205b70:	f44f 77c8 	mov.w	r7, #400	; 0x190
  205b74:	f7fd fb9c 	bl	2032b0 <JY901_yaw_get>
  205b78:	b283      	uxth	r3, r0
					if(HOUI<180){
  205b7a:	2bb3      	cmp	r3, #179	; 0xb3
					HOUI=JY901_yaw_get(HOUI_def);
  205b7c:	8033      	strh	r3, [r6, #0]
  205b7e:	4618      	mov	r0, r3
					if(HOUI<180){
  205b80:	d85e      	bhi.n	205c40 <motor_move+0xd20>
int max(int a,int b){
	if(a>b){return a;}
	else{return b;}
}
long map_m(long x, long in_min, long in_max, long out_min, long out_max) {
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  205b82:	f04f 08b4 	mov.w	r8, #180	; 0xb4
  205b86:	4378      	muls	r0, r7
  205b88:	fb90 f1f8 	sdiv	r1, r0, r8
					motor2(0,(int)map_m(HOUI,0,180,300,700));
  205b8c:	2000      	movs	r0, #0
  205b8e:	f501 7196 	add.w	r1, r1, #300	; 0x12c
  205b92:	f7fd fdf9 	bl	203788 <motor2>
					motor1(0,(int)map_m(HOUI,0,180,300,700));
  205b96:	8831      	ldrh	r1, [r6, #0]
  205b98:	2000      	movs	r0, #0
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  205b9a:	4379      	muls	r1, r7
  205b9c:	fb91 f1f8 	sdiv	r1, r1, r8
					motor1(0,(int)map_m(HOUI,0,180,300,700));
  205ba0:	f501 7196 	add.w	r1, r1, #300	; 0x12c
  205ba4:	f7fd fdd2 	bl	20374c <motor1>
					motor4((int)map_m(HOUI,0,180,300,700),0);
  205ba8:	8830      	ldrh	r0, [r6, #0]
  205baa:	2100      	movs	r1, #0
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  205bac:	4378      	muls	r0, r7
  205bae:	fb90 f0f8 	sdiv	r0, r0, r8
					motor4((int)map_m(HOUI,0,180,300,700),0);
  205bb2:	f500 7096 	add.w	r0, r0, #300	; 0x12c
  205bb6:	f7fd fe23 	bl	203800 <motor4>
					motor3((int)map_m(HOUI,0,180,300,700),0);
  205bba:	8830      	ldrh	r0, [r6, #0]
  205bbc:	2100      	movs	r1, #0
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  205bbe:	4378      	muls	r0, r7
  205bc0:	fb90 f0f8 	sdiv	r0, r0, r8
					motor3((int)map_m(HOUI,0,180,300,700),0);
  205bc4:	f500 7096 	add.w	r0, r0, #300	; 0x12c
  205bc8:	f7fd fdfc 	bl	2037c4 <motor3>
					HAL_GPIO_WritePin(GPIOE,GPIO_PIN_10,1);
  205bcc:	2201      	movs	r2, #1
  205bce:	f44f 6180 	mov.w	r1, #1024	; 0x400
  205bd2:	4648      	mov	r0, r9
  205bd4:	f7fb fa84 	bl	2010e0 <HAL_GPIO_WritePin>
					xprintf("LS now");
  205bd8:	4814      	ldr	r0, [pc, #80]	; (205c2c <motor_move+0xd0c>)
  205bda:	f001 fbb3 	bl	207344 <xprintf>
					xprintf(" speed= %d\r\n",(int)map_m(HOUI,0,180,70,300));
  205bde:	8833      	ldrh	r3, [r6, #0]
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  205be0:	21e6      	movs	r1, #230	; 0xe6
						xprintf(" speed= %d\r\n",(int)map_m(HOUI,359,180,70,300));
  205be2:	4650      	mov	r0, sl
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  205be4:	4359      	muls	r1, r3
  205be6:	fb91 f1f8 	sdiv	r1, r1, r8
						xprintf(" speed= %d\r\n",(int)map_m(HOUI,359,180,70,300));
  205bea:	3146      	adds	r1, #70	; 0x46
  205bec:	f001 fbaa 	bl	207344 <xprintf>
					  HAL_IWDG_Refresh(&hiwdg);
  205bf0:	480f      	ldr	r0, [pc, #60]	; (205c30 <motor_move+0xd10>)
  205bf2:	f7fb fda9 	bl	201748 <HAL_IWDG_Refresh>
  205bf6:	e69a      	b.n	20592e <motor_move+0xa0e>
  205bf8:	54442d18 	.word	0x54442d18
  205bfc:	400921fb 	.word	0x400921fb
  205c00:	20000178 	.word	0x20000178
  205c04:	200001bc 	.word	0x200001bc
  205c08:	40021000 	.word	0x40021000
  205c0c:	200001c0 	.word	0x200001c0
  205c10:	200001e8 	.word	0x200001e8
  205c14:	002077e3 	.word	0x002077e3
  205c18:	40668000 	.word	0x40668000
  205c1c:	20000198 	.word	0x20000198
  205c20:	200001b0 	.word	0x200001b0
  205c24:	2000017c 	.word	0x2000017c
  205c28:	200001fc 	.word	0x200001fc
  205c2c:	002075a4 	.word	0x002075a4
  205c30:	20000168 	.word	0x20000168
  205c34:	002075ab 	.word	0x002075ab
  205c38:	20000210 	.word	0x20000210
  205c3c:	2000020c 	.word	0x2000020c
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  205c40:	f46f 73b3 	mvn.w	r3, #358	; 0x166
  205c44:	f06f 08b2 	mvn.w	r8, #178	; 0xb2
						motor2((int)map_m(HOUI,359,180,300,700),0);
  205c48:	2100      	movs	r1, #0
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  205c4a:	4418      	add	r0, r3
  205c4c:	4378      	muls	r0, r7
  205c4e:	fb90 f0f8 	sdiv	r0, r0, r8
						motor2((int)map_m(HOUI,359,180,300,700),0);
  205c52:	f500 7096 	add.w	r0, r0, #300	; 0x12c
  205c56:	f7fd fd97 	bl	203788 <motor2>
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  205c5a:	f46f 72b3 	mvn.w	r2, #358	; 0x166
						motor1((int)map_m(HOUI,359,180,300,700),0);
  205c5e:	8830      	ldrh	r0, [r6, #0]
  205c60:	2100      	movs	r1, #0
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  205c62:	4410      	add	r0, r2
  205c64:	4378      	muls	r0, r7
  205c66:	fb90 f0f8 	sdiv	r0, r0, r8
						motor1((int)map_m(HOUI,359,180,300,700),0);
  205c6a:	f500 7096 	add.w	r0, r0, #300	; 0x12c
  205c6e:	f7fd fd6d 	bl	20374c <motor1>
						motor4(0,(int)map_m(HOUI,359,180,300,700));
  205c72:	8831      	ldrh	r1, [r6, #0]
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  205c74:	f46f 70b3 	mvn.w	r0, #358	; 0x166
  205c78:	4401      	add	r1, r0
						motor4(0,(int)map_m(HOUI,359,180,300,700));
  205c7a:	2000      	movs	r0, #0
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  205c7c:	4379      	muls	r1, r7
  205c7e:	fb91 f1f8 	sdiv	r1, r1, r8
						motor4(0,(int)map_m(HOUI,359,180,300,700));
  205c82:	f501 7196 	add.w	r1, r1, #300	; 0x12c
  205c86:	f7fd fdbb 	bl	203800 <motor4>
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  205c8a:	f46f 7eb3 	mvn.w	lr, #358	; 0x166
						motor3(0,(int)map_m(HOUI,359,180,300,700));
  205c8e:	8831      	ldrh	r1, [r6, #0]
  205c90:	2000      	movs	r0, #0
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  205c92:	4471      	add	r1, lr
  205c94:	4379      	muls	r1, r7
  205c96:	fb91 f1f8 	sdiv	r1, r1, r8
						motor3(0,(int)map_m(HOUI,359,180,300,700));
  205c9a:	f501 7196 	add.w	r1, r1, #300	; 0x12c
  205c9e:	f7fd fd91 	bl	2037c4 <motor3>
						HAL_GPIO_WritePin(GPIOE,GPIO_PIN_10,1);
  205ca2:	f44f 6180 	mov.w	r1, #1024	; 0x400
  205ca6:	2201      	movs	r2, #1
  205ca8:	4648      	mov	r0, r9
  205caa:	f7fb fa19 	bl	2010e0 <HAL_GPIO_WritePin>
						xprintf("RS now");
  205cae:	48c4      	ldr	r0, [pc, #784]	; (205fc0 <motor_move+0x10a0>)
  205cb0:	f001 fb48 	bl	207344 <xprintf>
						xprintf(" speed= %d\r\n",(int)map_m(HOUI,359,180,70,300));
  205cb4:	8831      	ldrh	r1, [r6, #0]
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  205cb6:	f46f 7cb3 	mvn.w	ip, #358	; 0x166
  205cba:	eb01 030c 	add.w	r3, r1, ip
  205cbe:	e78f      	b.n	205be0 <motor_move+0xcc0>
					  else if(digree>45 && digree<=90){
  205cc0:	f1a3 022e 	sub.w	r2, r3, #46	; 0x2e
  205cc4:	2a2c      	cmp	r2, #44	; 0x2c
  205cc6:	f67f aade 	bls.w	205286 <motor_move+0x366>
					  else if(digree>90 && digree<=135){
  205cca:	f1a3 025b 	sub.w	r2, r3, #91	; 0x5b
  205cce:	2a2c      	cmp	r2, #44	; 0x2c
  205cd0:	f67f aad9 	bls.w	205286 <motor_move+0x366>
					  else if(digree>135 && digree<=180){
  205cd4:	f1a3 0288 	sub.w	r2, r3, #136	; 0x88
  205cd8:	2a2c      	cmp	r2, #44	; 0x2c
  205cda:	f67f abed 	bls.w	2054b8 <motor_move+0x598>
					  else if(digree>180 && digree<=225){
  205cde:	f1a3 02b5 	sub.w	r2, r3, #181	; 0xb5
  205ce2:	e4ed      	b.n	2056c0 <motor_move+0x7a0>
					  else if(digree>270 && digree<=315){
  205ce4:	f46f 7b87 	mvn.w	fp, #270	; 0x10e
  205ce8:	445b      	add	r3, fp
  205cea:	2b2c      	cmp	r3, #44	; 0x2c
						  if(digtemp!=270){
  205cec:	f8d9 3000 	ldr.w	r3, [r9]
					  else if(digree>270 && digree<=315){
  205cf0:	f67f acf0 	bls.w	2056d4 <motor_move+0x7b4>
						  if(digtemp!=0){
  205cf4:	b1db      	cbz	r3, 205d2e <motor_move+0xe0e>
							  motor1(0,0);
  205cf6:	2100      	movs	r1, #0
  205cf8:	4608      	mov	r0, r1
  205cfa:	f7fd fd27 	bl	20374c <motor1>
							  motor2(0,0);
  205cfe:	2100      	movs	r1, #0
  205d00:	4608      	mov	r0, r1
  205d02:	f7fd fd41 	bl	203788 <motor2>
							  motor3(0,0);
  205d06:	2100      	movs	r1, #0
  205d08:	4608      	mov	r0, r1
  205d0a:	f7fd fd5b 	bl	2037c4 <motor3>
							  motor4(0,0);
  205d0e:	2100      	movs	r1, #0
  205d10:	4608      	mov	r0, r1
  205d12:	f7fd fd75 	bl	203800 <motor4>
								HAL_GPIO_WritePin(GPIOE,GPIO_PIN_10,0);
  205d16:	2200      	movs	r2, #0
  205d18:	f44f 6180 	mov.w	r1, #1024	; 0x400
  205d1c:	48a9      	ldr	r0, [pc, #676]	; (205fc4 <motor_move+0x10a4>)
  205d1e:	f7fb f9df 	bl	2010e0 <HAL_GPIO_WritePin>
							xprintf("bleak now\r\n");
  205d22:	48a9      	ldr	r0, [pc, #676]	; (205fc8 <motor_move+0x10a8>)
  205d24:	f001 fb0e 	bl	207344 <xprintf>
							  HAL_Delay(bleak_time);
  205d28:	2014      	movs	r0, #20
  205d2a:	f7fa febb 	bl	200aa4 <HAL_Delay>
						  power2=(float)arm_sin_f32((digree-45)*M_PI/180)*-1*power;
  205d2e:	6828      	ldr	r0, [r5, #0]
						  power3=(float)arm_sin_f32((digree-315)*M_PI/180)*power;
  205d30:	f46f 7a9d 	mvn.w	sl, #314	; 0x13a
						  power2=(float)arm_sin_f32((digree-45)*M_PI/180)*-1*power;
  205d34:	382d      	subs	r0, #45	; 0x2d
  205d36:	f7fa fbb9 	bl	2004ac <__aeabi_i2d>
  205d3a:	a39f      	add	r3, pc, #636	; (adr r3, 205fb8 <motor_move+0x1098>)
  205d3c:	e9d3 2300 	ldrd	r2, r3, [r3]
  205d40:	f7fa fc1a 	bl	200578 <__aeabi_dmul>
  205d44:	2200      	movs	r2, #0
  205d46:	4ba1      	ldr	r3, [pc, #644]	; (205fcc <motor_move+0x10ac>)
  205d48:	f7fa fd40 	bl	2007cc <__aeabi_ddiv>
  205d4c:	f7fa fe26 	bl	20099c <__aeabi_d2f>
  205d50:	ee00 0a10 	vmov	s0, r0
  205d54:	f001 fb2e 	bl	2073b4 <arm_sin_f32>
  205d58:	edd4 7a00 	vldr	s15, [r4]
						  power1=(float)arm_sin_f32((digree-135)*M_PI/180)*-1*power;
  205d5c:	6828      	ldr	r0, [r5, #0]
						  power2=(float)arm_sin_f32((digree-45)*M_PI/180)*-1*power;
  205d5e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
						  power1=(float)arm_sin_f32((digree-135)*M_PI/180)*-1*power;
  205d62:	3887      	subs	r0, #135	; 0x87
						  power2=(float)arm_sin_f32((digree-45)*M_PI/180)*-1*power;
  205d64:	ee20 0a67 	vnmul.f32	s0, s0, s15
  205d68:	eebd 0ac0 	vcvt.s32.f32	s0, s0
  205d6c:	ed87 0a00 	vstr	s0, [r7]
						  power1=(float)arm_sin_f32((digree-135)*M_PI/180)*-1*power;
  205d70:	f7fa fb9c 	bl	2004ac <__aeabi_i2d>
  205d74:	a390      	add	r3, pc, #576	; (adr r3, 205fb8 <motor_move+0x1098>)
  205d76:	e9d3 2300 	ldrd	r2, r3, [r3]
  205d7a:	f7fa fbfd 	bl	200578 <__aeabi_dmul>
  205d7e:	2200      	movs	r2, #0
  205d80:	4b92      	ldr	r3, [pc, #584]	; (205fcc <motor_move+0x10ac>)
  205d82:	f7fa fd23 	bl	2007cc <__aeabi_ddiv>
  205d86:	f7fa fe09 	bl	20099c <__aeabi_d2f>
  205d8a:	ee00 0a10 	vmov	s0, r0
  205d8e:	f001 fb11 	bl	2073b4 <arm_sin_f32>
  205d92:	edd4 7a00 	vldr	s15, [r4]
						  power4=(float)arm_sin_f32((digree-225)*M_PI/180)*power;
  205d96:	6828      	ldr	r0, [r5, #0]
						  power1=(float)arm_sin_f32((digree-135)*M_PI/180)*-1*power;
  205d98:	eef8 7ae7 	vcvt.f32.s32	s15, s15
						  power4=(float)arm_sin_f32((digree-225)*M_PI/180)*power;
  205d9c:	38e1      	subs	r0, #225	; 0xe1
						  power1=(float)arm_sin_f32((digree-135)*M_PI/180)*-1*power;
  205d9e:	ee20 0a67 	vnmul.f32	s0, s0, s15
  205da2:	eebd 0ac0 	vcvt.s32.f32	s0, s0
  205da6:	ed88 0a00 	vstr	s0, [r8]
						  power4=(float)arm_sin_f32((digree-225)*M_PI/180)*power;
  205daa:	f7fa fb7f 	bl	2004ac <__aeabi_i2d>
  205dae:	a382      	add	r3, pc, #520	; (adr r3, 205fb8 <motor_move+0x1098>)
  205db0:	e9d3 2300 	ldrd	r2, r3, [r3]
  205db4:	f7fa fbe0 	bl	200578 <__aeabi_dmul>
  205db8:	2200      	movs	r2, #0
  205dba:	4b84      	ldr	r3, [pc, #528]	; (205fcc <motor_move+0x10ac>)
  205dbc:	f7fa fd06 	bl	2007cc <__aeabi_ddiv>
  205dc0:	f7fa fdec 	bl	20099c <__aeabi_d2f>
  205dc4:	ee00 0a10 	vmov	s0, r0
  205dc8:	f001 faf4 	bl	2073b4 <arm_sin_f32>
  205dcc:	edd4 7a00 	vldr	s15, [r4]
						  power3=(float)arm_sin_f32((digree-315)*M_PI/180)*power;
  205dd0:	6828      	ldr	r0, [r5, #0]
						  power4=(float)arm_sin_f32((digree-225)*M_PI/180)*power;
  205dd2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
						  power3=(float)arm_sin_f32((digree-315)*M_PI/180)*power;
  205dd6:	4450      	add	r0, sl
						  power4=(float)arm_sin_f32((digree-225)*M_PI/180)*power;
  205dd8:	ee27 0a80 	vmul.f32	s0, s15, s0
  205ddc:	eebd 0ac0 	vcvt.s32.f32	s0, s0
  205de0:	ed86 0a00 	vstr	s0, [r6]
						  power3=(float)arm_sin_f32((digree-315)*M_PI/180)*power;
  205de4:	f7fa fb62 	bl	2004ac <__aeabi_i2d>
  205de8:	a373      	add	r3, pc, #460	; (adr r3, 205fb8 <motor_move+0x1098>)
  205dea:	e9d3 2300 	ldrd	r2, r3, [r3]
  205dee:	f7fa fbc3 	bl	200578 <__aeabi_dmul>
  205df2:	2200      	movs	r2, #0
  205df4:	4b75      	ldr	r3, [pc, #468]	; (205fcc <motor_move+0x10ac>)
  205df6:	f7fa fce9 	bl	2007cc <__aeabi_ddiv>
  205dfa:	f7fa fdcf 	bl	20099c <__aeabi_d2f>
  205dfe:	ee00 0a10 	vmov	s0, r0
  205e02:	f001 fad7 	bl	2073b4 <arm_sin_f32>
  205e06:	ed94 7a00 	vldr	s14, [r4]
  205e0a:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
  205e0e:	ee20 0a07 	vmul.f32	s0, s0, s14
  205e12:	e64e      	b.n	205ab2 <motor_move+0xb92>
				HOUI=JY901_yaw_get(HOUI_def);
  205e14:	4f6e      	ldr	r7, [pc, #440]	; (205fd0 <motor_move+0x10b0>)
  205e16:	4e6f      	ldr	r6, [pc, #444]	; (205fd4 <motor_move+0x10b4>)
  205e18:	8838      	ldrh	r0, [r7, #0]
  205e1a:	f7fd fa49 	bl	2032b0 <JY901_yaw_get>
  205e1e:	b280      	uxth	r0, r0
  205e20:	8030      	strh	r0, [r6, #0]
		  	   if(HOUI>= 5 && HOUI<=355){
  205e22:	3805      	subs	r0, #5
  205e24:	f5b0 7faf 	cmp.w	r0, #350	; 0x15e
  205e28:	f200 80dc 	bhi.w	205fe4 <motor_move+0x10c4>
		  		motor1(0,0);
  205e2c:	2100      	movs	r1, #0
		  			HAL_GPIO_WritePin(GPIOE,GPIO_PIN_10,1);
  205e2e:	4d65      	ldr	r5, [pc, #404]	; (205fc4 <motor_move+0x10a4>)
		  	    	xprintf("RS now");
  205e30:	f8df 918c 	ldr.w	r9, [pc, #396]	; 205fc0 <motor_move+0x10a0>
		  		motor1(0,0);
  205e34:	4608      	mov	r0, r1
		  	    	xprintf(" speed= %d\r\n",(int)map_m(HOUI,359,180,70,300));
  205e36:	f8df 81a8 	ldr.w	r8, [pc, #424]	; 205fe0 <motor_move+0x10c0>
		  		motor1(0,0);
  205e3a:	f7fd fc87 	bl	20374c <motor1>
		  	    motor2(0,0);
  205e3e:	2100      	movs	r1, #0
  205e40:	4608      	mov	r0, r1
  205e42:	f7fd fca1 	bl	203788 <motor2>
		  		motor3(0,0);
  205e46:	2100      	movs	r1, #0
  205e48:	4608      	mov	r0, r1
  205e4a:	f7fd fcbb 	bl	2037c4 <motor3>
		  		motor4(0,0);
  205e4e:	2100      	movs	r1, #0
  205e50:	4608      	mov	r0, r1
  205e52:	f7fd fcd5 	bl	203800 <motor4>
				HAL_GPIO_WritePin(GPIOE,GPIO_PIN_10,0);
  205e56:	2200      	movs	r2, #0
  205e58:	f44f 6180 	mov.w	r1, #1024	; 0x400
  205e5c:	4859      	ldr	r0, [pc, #356]	; (205fc4 <motor_move+0x10a4>)
  205e5e:	f7fb f93f 	bl	2010e0 <HAL_GPIO_WritePin>
		  		HAL_Delay(20);
  205e62:	2014      	movs	r0, #20
  205e64:	f7fa fe1e 	bl	200aa4 <HAL_Delay>
		  	  while(HOUI>=5 && HOUI<=355){
  205e68:	8833      	ldrh	r3, [r6, #0]
  205e6a:	3b05      	subs	r3, #5
  205e6c:	b29b      	uxth	r3, r3
  205e6e:	f5b3 7faf 	cmp.w	r3, #350	; 0x15e
  205e72:	d91a      	bls.n	205eaa <motor_move+0xf8a>
				 motor1(0,0);
  205e74:	2100      	movs	r1, #0
  205e76:	4608      	mov	r0, r1
  205e78:	f7fd fc68 	bl	20374c <motor1>
				 motor2(0,0);
  205e7c:	2100      	movs	r1, #0
  205e7e:	4608      	mov	r0, r1
  205e80:	f7fd fc82 	bl	203788 <motor2>
				 motor3(0,0);
  205e84:	2100      	movs	r1, #0
  205e86:	4608      	mov	r0, r1
  205e88:	f7fd fc9c 	bl	2037c4 <motor3>
				 motor4(0,0);
  205e8c:	2100      	movs	r1, #0
  205e8e:	4608      	mov	r0, r1
  205e90:	f7fd fcb6 	bl	203800 <motor4>
					HAL_GPIO_WritePin(GPIOE,GPIO_PIN_10,0);
  205e94:	484b      	ldr	r0, [pc, #300]	; (205fc4 <motor_move+0x10a4>)
  205e96:	2200      	movs	r2, #0
  205e98:	f44f 6180 	mov.w	r1, #1024	; 0x400
  205e9c:	f7fb f920 	bl	2010e0 <HAL_GPIO_WritePin>
				 HAL_Delay(20);
  205ea0:	2014      	movs	r0, #20
	}
  205ea2:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
				 HAL_Delay(20);
  205ea6:	f7fa bdfd 	b.w	200aa4 <HAL_Delay>
		  		HOUI=JY901_yaw_get(HOUI_def);
  205eaa:	8838      	ldrh	r0, [r7, #0]
  205eac:	f44f 74c8 	mov.w	r4, #400	; 0x190
  205eb0:	f7fd f9fe 	bl	2032b0 <JY901_yaw_get>
  205eb4:	b283      	uxth	r3, r0
		  	    if(HOUI<180){
  205eb6:	2bb3      	cmp	r3, #179	; 0xb3
		  		HOUI=JY901_yaw_get(HOUI_def);
  205eb8:	8033      	strh	r3, [r6, #0]
  205eba:	4618      	mov	r0, r3
		  	    if(HOUI<180){
  205ebc:	d83a      	bhi.n	205f34 <motor_move+0x1014>
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  205ebe:	f04f 0ab4 	mov.w	sl, #180	; 0xb4
  205ec2:	4360      	muls	r0, r4
  205ec4:	fb90 f1fa 	sdiv	r1, r0, sl
		  	 	motor1(0,(int)map_m(HOUI,0,180,300,700));
  205ec8:	2000      	movs	r0, #0
  205eca:	f501 7196 	add.w	r1, r1, #300	; 0x12c
  205ece:	f7fd fc3d 	bl	20374c <motor1>
		  	 	motor2(0,(int)map_m(HOUI,0,180,300,700));
  205ed2:	8831      	ldrh	r1, [r6, #0]
  205ed4:	2000      	movs	r0, #0
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  205ed6:	4361      	muls	r1, r4
  205ed8:	fb91 f1fa 	sdiv	r1, r1, sl
		  	 	motor2(0,(int)map_m(HOUI,0,180,300,700));
  205edc:	f501 7196 	add.w	r1, r1, #300	; 0x12c
  205ee0:	f7fd fc52 	bl	203788 <motor2>
		  	 	motor3((int)map_m(HOUI,0,180,300,700),0);
  205ee4:	8830      	ldrh	r0, [r6, #0]
  205ee6:	2100      	movs	r1, #0
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  205ee8:	4360      	muls	r0, r4
  205eea:	fb90 f0fa 	sdiv	r0, r0, sl
		  	 	motor3((int)map_m(HOUI,0,180,300,700),0);
  205eee:	f500 7096 	add.w	r0, r0, #300	; 0x12c
  205ef2:	f7fd fc67 	bl	2037c4 <motor3>
		  	 	motor4((int)map_m(HOUI,0,180,300,700),0);
  205ef6:	8830      	ldrh	r0, [r6, #0]
  205ef8:	2100      	movs	r1, #0
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  205efa:	4360      	muls	r0, r4
  205efc:	fb90 f0fa 	sdiv	r0, r0, sl
		  	 	motor4((int)map_m(HOUI,0,180,300,700),0);
  205f00:	f500 7096 	add.w	r0, r0, #300	; 0x12c
  205f04:	f7fd fc7c 	bl	203800 <motor4>
				HAL_GPIO_WritePin(GPIOE,GPIO_PIN_10,1);
  205f08:	2201      	movs	r2, #1
  205f0a:	f44f 6180 	mov.w	r1, #1024	; 0x400
  205f0e:	4628      	mov	r0, r5
  205f10:	f7fb f8e6 	bl	2010e0 <HAL_GPIO_WritePin>
		  	 	xprintf("LS now");
  205f14:	4830      	ldr	r0, [pc, #192]	; (205fd8 <motor_move+0x10b8>)
  205f16:	f001 fa15 	bl	207344 <xprintf>
		  	 	xprintf(" speed= %d\r\n",(int)map_m(HOUI,0,180,70,300));
  205f1a:	8833      	ldrh	r3, [r6, #0]
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  205f1c:	21e6      	movs	r1, #230	; 0xe6
		  	    	xprintf(" speed= %d\r\n",(int)map_m(HOUI,359,180,70,300));
  205f1e:	4640      	mov	r0, r8
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  205f20:	4359      	muls	r1, r3
  205f22:	fb91 f1fa 	sdiv	r1, r1, sl
		  	    	xprintf(" speed= %d\r\n",(int)map_m(HOUI,359,180,70,300));
  205f26:	3146      	adds	r1, #70	; 0x46
  205f28:	f001 fa0c 	bl	207344 <xprintf>
		  	  HAL_IWDG_Refresh(&hiwdg);
  205f2c:	482b      	ldr	r0, [pc, #172]	; (205fdc <motor_move+0x10bc>)
  205f2e:	f7fb fc0b 	bl	201748 <HAL_IWDG_Refresh>
  205f32:	e799      	b.n	205e68 <motor_move+0xf48>
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  205f34:	f46f 73b3 	mvn.w	r3, #358	; 0x166
  205f38:	f06f 0ab2 	mvn.w	sl, #178	; 0xb2
		  	    	motor1((int)map_m(HOUI,359,180,300,700),0);
  205f3c:	2100      	movs	r1, #0
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  205f3e:	4418      	add	r0, r3
  205f40:	4360      	muls	r0, r4
  205f42:	fb90 f0fa 	sdiv	r0, r0, sl
		  	    	motor1((int)map_m(HOUI,359,180,300,700),0);
  205f46:	f500 7096 	add.w	r0, r0, #300	; 0x12c
  205f4a:	f7fd fbff 	bl	20374c <motor1>
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  205f4e:	f46f 72b3 	mvn.w	r2, #358	; 0x166
		  	    	motor2((int)map_m(HOUI,359,180,300,700),0);
  205f52:	8830      	ldrh	r0, [r6, #0]
  205f54:	2100      	movs	r1, #0
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  205f56:	4410      	add	r0, r2
  205f58:	4360      	muls	r0, r4
  205f5a:	fb90 f0fa 	sdiv	r0, r0, sl
		  	    	motor2((int)map_m(HOUI,359,180,300,700),0);
  205f5e:	f500 7096 	add.w	r0, r0, #300	; 0x12c
  205f62:	f7fd fc11 	bl	203788 <motor2>
		  	    	motor3(0,(int)map_m(HOUI,359,180,300,700));
  205f66:	8831      	ldrh	r1, [r6, #0]
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  205f68:	f46f 70b3 	mvn.w	r0, #358	; 0x166
  205f6c:	4401      	add	r1, r0
		  	    	motor3(0,(int)map_m(HOUI,359,180,300,700));
  205f6e:	2000      	movs	r0, #0
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  205f70:	4361      	muls	r1, r4
  205f72:	fb91 f1fa 	sdiv	r1, r1, sl
		  	    	motor3(0,(int)map_m(HOUI,359,180,300,700));
  205f76:	f501 7196 	add.w	r1, r1, #300	; 0x12c
  205f7a:	f7fd fc23 	bl	2037c4 <motor3>
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  205f7e:	f46f 7eb3 	mvn.w	lr, #358	; 0x166
		  	    	motor4(0,(int)map_m(HOUI,359,180,300,700));
  205f82:	8831      	ldrh	r1, [r6, #0]
  205f84:	2000      	movs	r0, #0
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  205f86:	4471      	add	r1, lr
  205f88:	4361      	muls	r1, r4
  205f8a:	fb91 f1fa 	sdiv	r1, r1, sl
		  	    	motor4(0,(int)map_m(HOUI,359,180,300,700));
  205f8e:	f501 7196 	add.w	r1, r1, #300	; 0x12c
  205f92:	f7fd fc35 	bl	203800 <motor4>
		  			HAL_GPIO_WritePin(GPIOE,GPIO_PIN_10,1);
  205f96:	f44f 6180 	mov.w	r1, #1024	; 0x400
  205f9a:	2201      	movs	r2, #1
  205f9c:	4628      	mov	r0, r5
  205f9e:	f7fb f89f 	bl	2010e0 <HAL_GPIO_WritePin>
		  	    	xprintf("RS now");
  205fa2:	4648      	mov	r0, r9
  205fa4:	f001 f9ce 	bl	207344 <xprintf>
		  	    	xprintf(" speed= %d\r\n",(int)map_m(HOUI,359,180,70,300));
  205fa8:	8831      	ldrh	r1, [r6, #0]
	  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  205faa:	f46f 7cb3 	mvn.w	ip, #358	; 0x166
  205fae:	eb01 030c 	add.w	r3, r1, ip
  205fb2:	e7b3      	b.n	205f1c <motor_move+0xffc>
  205fb4:	f3af 8000 	nop.w
  205fb8:	54442d18 	.word	0x54442d18
  205fbc:	400921fb 	.word	0x400921fb
  205fc0:	002075b8 	.word	0x002075b8
  205fc4:	40021000 	.word	0x40021000
  205fc8:	002077e3 	.word	0x002077e3
  205fcc:	40668000 	.word	0x40668000
  205fd0:	20000178 	.word	0x20000178
  205fd4:	200001bc 	.word	0x200001bc
  205fd8:	002075a4 	.word	0x002075a4
  205fdc:	20000168 	.word	0x20000168
  205fe0:	002075ab 	.word	0x002075ab
		  	   else if(digree>=0 && digree<=360){
  205fe4:	682b      	ldr	r3, [r5, #0]
  205fe6:	f5b3 7fb4 	cmp.w	r3, #360	; 0x168
  205fea:	d83d      	bhi.n	206068 <motor_move+0x1148>
		 		  if(digree<=23 || digree>=338){
  205fec:	f1a3 0218 	sub.w	r2, r3, #24
  205ff0:	4dd3      	ldr	r5, [pc, #844]	; (206340 <motor_move+0x1420>)
  205ff2:	f5b2 7f9d 	cmp.w	r2, #314	; 0x13a
  205ff6:	d342      	bcc.n	20607e <motor_move+0x115e>
		 			if(digtemp!=0){
  205ff8:	682b      	ldr	r3, [r5, #0]
  205ffa:	b1db      	cbz	r3, 206034 <motor_move+0x1114>
		 					motor1(0,0);
  205ffc:	2100      	movs	r1, #0
  205ffe:	4608      	mov	r0, r1
  206000:	f7fd fba4 	bl	20374c <motor1>
		 					motor2(0,0);
  206004:	2100      	movs	r1, #0
  206006:	4608      	mov	r0, r1
  206008:	f7fd fbbe 	bl	203788 <motor2>
		 					motor3(0,0);
  20600c:	2100      	movs	r1, #0
  20600e:	4608      	mov	r0, r1
  206010:	f7fd fbd8 	bl	2037c4 <motor3>
		 					motor4(0,0);
  206014:	2100      	movs	r1, #0
  206016:	4608      	mov	r0, r1
  206018:	f7fd fbf2 	bl	203800 <motor4>
		 					HAL_GPIO_WritePin(GPIOE,GPIO_PIN_10,0);
  20601c:	2200      	movs	r2, #0
  20601e:	f44f 6180 	mov.w	r1, #1024	; 0x400
  206022:	48c8      	ldr	r0, [pc, #800]	; (206344 <motor_move+0x1424>)
  206024:	f7fb f85c 	bl	2010e0 <HAL_GPIO_WritePin>
		 					xprintf("bleak now\r\n");
  206028:	48c7      	ldr	r0, [pc, #796]	; (206348 <motor_move+0x1428>)
  20602a:	f001 f98b 	bl	207344 <xprintf>
		 					HAL_Delay(bleak_time);
  20602e:	2014      	movs	r0, #20
  206030:	f7fa fd38 	bl	200aa4 <HAL_Delay>
		 			motor1(0,power);
  206034:	6821      	ldr	r1, [r4, #0]
  206036:	2000      	movs	r0, #0
  206038:	f7fd fb88 	bl	20374c <motor1>
		 			motor2(0,power);
  20603c:	6821      	ldr	r1, [r4, #0]
  20603e:	2000      	movs	r0, #0
  206040:	f7fd fba2 	bl	203788 <motor2>
		 			motor3(0,power);
  206044:	6821      	ldr	r1, [r4, #0]
  206046:	2000      	movs	r0, #0
  206048:	f7fd fbbc 	bl	2037c4 <motor3>
		 			motor4(0,power);
  20604c:	6821      	ldr	r1, [r4, #0]
  20604e:	2000      	movs	r0, #0
  206050:	f7fd fbd6 	bl	203800 <motor4>
		 			HAL_GPIO_WritePin(GPIOE,GPIO_PIN_10,1);
  206054:	2201      	movs	r2, #1
  206056:	f44f 6180 	mov.w	r1, #1024	; 0x400
  20605a:	48ba      	ldr	r0, [pc, #744]	; (206344 <motor_move+0x1424>)
  20605c:	f7fb f840 	bl	2010e0 <HAL_GPIO_WritePin>
		 			  digtemp=0;
  206060:	2300      	movs	r3, #0
		 			  digtemp=315;
  206062:	602b      	str	r3, [r5, #0]
  206064:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		 		  oled_puts("Running       ST");
  206068:	48b8      	ldr	r0, [pc, #736]	; (20634c <motor_move+0x142c>)
  20606a:	f7fd fd89 	bl	203b80 <oled_puts>
  20606e:	f7fe bf77 	b.w	204f60 <motor_move+0x40>
		  	    if(digree>=0 && digree<=360){
  206072:	682b      	ldr	r3, [r5, #0]
  206074:	f5b3 7fb4 	cmp.w	r3, #360	; 0x168
  206078:	d9b8      	bls.n	205fec <motor_move+0x10cc>
  20607a:	f7fe bf71 	b.w	204f60 <motor_move+0x40>
		 		  else if(digree>23 && digree<=68){
  20607e:	2a2c      	cmp	r2, #44	; 0x2c
  206080:	d836      	bhi.n	2060f0 <motor_move+0x11d0>
		 			  if(digtemp!=45){
  206082:	682b      	ldr	r3, [r5, #0]
  206084:	2b2d      	cmp	r3, #45	; 0x2d
  206086:	d01b      	beq.n	2060c0 <motor_move+0x11a0>
		 				  motor1(0,0);
  206088:	2100      	movs	r1, #0
  20608a:	4608      	mov	r0, r1
  20608c:	f7fd fb5e 	bl	20374c <motor1>
		 				  motor2(0,0);
  206090:	2100      	movs	r1, #0
  206092:	4608      	mov	r0, r1
  206094:	f7fd fb78 	bl	203788 <motor2>
		 				  motor3(0,0);
  206098:	2100      	movs	r1, #0
  20609a:	4608      	mov	r0, r1
  20609c:	f7fd fb92 	bl	2037c4 <motor3>
		 				  motor4(0,0);
  2060a0:	2100      	movs	r1, #0
  2060a2:	4608      	mov	r0, r1
  2060a4:	f7fd fbac 	bl	203800 <motor4>
		 					HAL_GPIO_WritePin(GPIOE,GPIO_PIN_10,0);
  2060a8:	2200      	movs	r2, #0
  2060aa:	f44f 6180 	mov.w	r1, #1024	; 0x400
  2060ae:	48a5      	ldr	r0, [pc, #660]	; (206344 <motor_move+0x1424>)
  2060b0:	f7fb f816 	bl	2010e0 <HAL_GPIO_WritePin>
		 				xprintf("bleak now\r\n");
  2060b4:	48a4      	ldr	r0, [pc, #656]	; (206348 <motor_move+0x1428>)
  2060b6:	f001 f945 	bl	207344 <xprintf>
		 				  HAL_Delay(bleak_time);
  2060ba:	2014      	movs	r0, #20
  2060bc:	f7fa fcf2 	bl	200aa4 <HAL_Delay>
		 			  motor1(0,power);
  2060c0:	6821      	ldr	r1, [r4, #0]
  2060c2:	2000      	movs	r0, #0
  2060c4:	f7fd fb42 	bl	20374c <motor1>
		 			  motor2(0,0);
  2060c8:	2100      	movs	r1, #0
  2060ca:	4608      	mov	r0, r1
  2060cc:	f7fd fb5c 	bl	203788 <motor2>
		 			  motor3(0,power);
  2060d0:	6821      	ldr	r1, [r4, #0]
  2060d2:	2000      	movs	r0, #0
  2060d4:	f7fd fb76 	bl	2037c4 <motor3>
		 			  motor4(0,0);
  2060d8:	2100      	movs	r1, #0
  2060da:	4608      	mov	r0, r1
  2060dc:	f7fd fb90 	bl	203800 <motor4>
		 				HAL_GPIO_WritePin(GPIOE,GPIO_PIN_10,1);
  2060e0:	2201      	movs	r2, #1
  2060e2:	f44f 6180 	mov.w	r1, #1024	; 0x400
  2060e6:	4897      	ldr	r0, [pc, #604]	; (206344 <motor_move+0x1424>)
  2060e8:	f7fa fffa 	bl	2010e0 <HAL_GPIO_WritePin>
		 			  digtemp=45;
  2060ec:	232d      	movs	r3, #45	; 0x2d
  2060ee:	e7b8      	b.n	206062 <motor_move+0x1142>
		 		  else if(digree>68 && digree<=113){
  2060f0:	f1a3 0245 	sub.w	r2, r3, #69	; 0x45
  2060f4:	2a2c      	cmp	r2, #44	; 0x2c
  2060f6:	d836      	bhi.n	206166 <motor_move+0x1246>
		 			  if(digtemp!=90){
  2060f8:	682b      	ldr	r3, [r5, #0]
  2060fa:	2b5a      	cmp	r3, #90	; 0x5a
  2060fc:	d01b      	beq.n	206136 <motor_move+0x1216>
		 				  motor1(0,0);
  2060fe:	2100      	movs	r1, #0
  206100:	4608      	mov	r0, r1
  206102:	f7fd fb23 	bl	20374c <motor1>
		 				  motor2(0,0);
  206106:	2100      	movs	r1, #0
  206108:	4608      	mov	r0, r1
  20610a:	f7fd fb3d 	bl	203788 <motor2>
		 				  motor3(0,0);
  20610e:	2100      	movs	r1, #0
  206110:	4608      	mov	r0, r1
  206112:	f7fd fb57 	bl	2037c4 <motor3>
		 				  motor4(0,0);
  206116:	2100      	movs	r1, #0
  206118:	4608      	mov	r0, r1
  20611a:	f7fd fb71 	bl	203800 <motor4>
		 					HAL_GPIO_WritePin(GPIOE,GPIO_PIN_10,0);
  20611e:	2200      	movs	r2, #0
  206120:	f44f 6180 	mov.w	r1, #1024	; 0x400
  206124:	4887      	ldr	r0, [pc, #540]	; (206344 <motor_move+0x1424>)
  206126:	f7fa ffdb 	bl	2010e0 <HAL_GPIO_WritePin>
		 				xprintf("bleak now\r\n");
  20612a:	4887      	ldr	r0, [pc, #540]	; (206348 <motor_move+0x1428>)
  20612c:	f001 f90a 	bl	207344 <xprintf>
		 				  HAL_Delay(bleak_time);
  206130:	2014      	movs	r0, #20
  206132:	f7fa fcb7 	bl	200aa4 <HAL_Delay>
		 			  motor1(0,power);
  206136:	6821      	ldr	r1, [r4, #0]
  206138:	2000      	movs	r0, #0
  20613a:	f7fd fb07 	bl	20374c <motor1>
		 			  motor2(power,0);
  20613e:	2100      	movs	r1, #0
  206140:	6820      	ldr	r0, [r4, #0]
  206142:	f7fd fb21 	bl	203788 <motor2>
		 			  motor3(0,power);
  206146:	6821      	ldr	r1, [r4, #0]
  206148:	2000      	movs	r0, #0
  20614a:	f7fd fb3b 	bl	2037c4 <motor3>
		 			  motor4(power,0);
  20614e:	2100      	movs	r1, #0
  206150:	6820      	ldr	r0, [r4, #0]
  206152:	f7fd fb55 	bl	203800 <motor4>
		 				HAL_GPIO_WritePin(GPIOE,GPIO_PIN_10,1);
  206156:	2201      	movs	r2, #1
  206158:	f44f 6180 	mov.w	r1, #1024	; 0x400
  20615c:	4879      	ldr	r0, [pc, #484]	; (206344 <motor_move+0x1424>)
  20615e:	f7fa ffbf 	bl	2010e0 <HAL_GPIO_WritePin>
		 			  digtemp=90;
  206162:	235a      	movs	r3, #90	; 0x5a
  206164:	e77d      	b.n	206062 <motor_move+0x1142>
		 		  else if(digree>113 && digree<=158){
  206166:	f1a3 0272 	sub.w	r2, r3, #114	; 0x72
  20616a:	2a2c      	cmp	r2, #44	; 0x2c
  20616c:	d836      	bhi.n	2061dc <motor_move+0x12bc>
		 			  if(digtemp!=135){
  20616e:	682b      	ldr	r3, [r5, #0]
  206170:	2b87      	cmp	r3, #135	; 0x87
  206172:	d01b      	beq.n	2061ac <motor_move+0x128c>
		 				  motor1(0,0);
  206174:	2100      	movs	r1, #0
  206176:	4608      	mov	r0, r1
  206178:	f7fd fae8 	bl	20374c <motor1>
		 				  motor2(0,0);
  20617c:	2100      	movs	r1, #0
  20617e:	4608      	mov	r0, r1
  206180:	f7fd fb02 	bl	203788 <motor2>
		 				  motor3(0,0);
  206184:	2100      	movs	r1, #0
  206186:	4608      	mov	r0, r1
  206188:	f7fd fb1c 	bl	2037c4 <motor3>
		 				  motor4(0,0);
  20618c:	2100      	movs	r1, #0
  20618e:	4608      	mov	r0, r1
  206190:	f7fd fb36 	bl	203800 <motor4>
		 					HAL_GPIO_WritePin(GPIOE,GPIO_PIN_10,0);
  206194:	2200      	movs	r2, #0
  206196:	f44f 6180 	mov.w	r1, #1024	; 0x400
  20619a:	486a      	ldr	r0, [pc, #424]	; (206344 <motor_move+0x1424>)
  20619c:	f7fa ffa0 	bl	2010e0 <HAL_GPIO_WritePin>
		 				xprintf("bleak now\r\n");
  2061a0:	4869      	ldr	r0, [pc, #420]	; (206348 <motor_move+0x1428>)
  2061a2:	f001 f8cf 	bl	207344 <xprintf>
		 				  HAL_Delay(bleak_time);
  2061a6:	2014      	movs	r0, #20
  2061a8:	f7fa fc7c 	bl	200aa4 <HAL_Delay>
		 			  motor1(0,0);
  2061ac:	2100      	movs	r1, #0
  2061ae:	4608      	mov	r0, r1
  2061b0:	f7fd facc 	bl	20374c <motor1>
		 			  motor2(power,0);
  2061b4:	2100      	movs	r1, #0
  2061b6:	6820      	ldr	r0, [r4, #0]
  2061b8:	f7fd fae6 	bl	203788 <motor2>
		 			  motor3(0,0);
  2061bc:	2100      	movs	r1, #0
  2061be:	4608      	mov	r0, r1
  2061c0:	f7fd fb00 	bl	2037c4 <motor3>
		 			  motor4(power,0);
  2061c4:	2100      	movs	r1, #0
  2061c6:	6820      	ldr	r0, [r4, #0]
  2061c8:	f7fd fb1a 	bl	203800 <motor4>
		 				HAL_GPIO_WritePin(GPIOE,GPIO_PIN_10,1);
  2061cc:	2201      	movs	r2, #1
  2061ce:	f44f 6180 	mov.w	r1, #1024	; 0x400
  2061d2:	485c      	ldr	r0, [pc, #368]	; (206344 <motor_move+0x1424>)
  2061d4:	f7fa ff84 	bl	2010e0 <HAL_GPIO_WritePin>
		 			  digtemp=135;
  2061d8:	2387      	movs	r3, #135	; 0x87
  2061da:	e742      	b.n	206062 <motor_move+0x1142>
		 		  else if(digree>158 && digree<=203){
  2061dc:	f1a3 029f 	sub.w	r2, r3, #159	; 0x9f
  2061e0:	2a2c      	cmp	r2, #44	; 0x2c
  2061e2:	d836      	bhi.n	206252 <motor_move+0x1332>
		 			  if(digtemp!=180){
  2061e4:	682b      	ldr	r3, [r5, #0]
  2061e6:	2bb4      	cmp	r3, #180	; 0xb4
  2061e8:	d01b      	beq.n	206222 <motor_move+0x1302>
		 				  motor1(0,0);
  2061ea:	2100      	movs	r1, #0
  2061ec:	4608      	mov	r0, r1
  2061ee:	f7fd faad 	bl	20374c <motor1>
		 				  motor2(0,0);
  2061f2:	2100      	movs	r1, #0
  2061f4:	4608      	mov	r0, r1
  2061f6:	f7fd fac7 	bl	203788 <motor2>
		 				  motor3(0,0);
  2061fa:	2100      	movs	r1, #0
  2061fc:	4608      	mov	r0, r1
  2061fe:	f7fd fae1 	bl	2037c4 <motor3>
		 				  motor4(0,0);
  206202:	2100      	movs	r1, #0
  206204:	4608      	mov	r0, r1
  206206:	f7fd fafb 	bl	203800 <motor4>
		 					HAL_GPIO_WritePin(GPIOE,GPIO_PIN_10,0);
  20620a:	2200      	movs	r2, #0
  20620c:	f44f 6180 	mov.w	r1, #1024	; 0x400
  206210:	484c      	ldr	r0, [pc, #304]	; (206344 <motor_move+0x1424>)
  206212:	f7fa ff65 	bl	2010e0 <HAL_GPIO_WritePin>
		 				xprintf("bleak now\r\n");
  206216:	484c      	ldr	r0, [pc, #304]	; (206348 <motor_move+0x1428>)
  206218:	f001 f894 	bl	207344 <xprintf>
		 				  HAL_Delay(bleak_time);
  20621c:	2014      	movs	r0, #20
  20621e:	f7fa fc41 	bl	200aa4 <HAL_Delay>
		 			  motor1(power,0);
  206222:	2100      	movs	r1, #0
  206224:	6820      	ldr	r0, [r4, #0]
  206226:	f7fd fa91 	bl	20374c <motor1>
		 			  motor2(power,0);
  20622a:	2100      	movs	r1, #0
  20622c:	6820      	ldr	r0, [r4, #0]
  20622e:	f7fd faab 	bl	203788 <motor2>
		 			  motor3(power,0);
  206232:	2100      	movs	r1, #0
  206234:	6820      	ldr	r0, [r4, #0]
  206236:	f7fd fac5 	bl	2037c4 <motor3>
		 			  motor4(power,0);
  20623a:	2100      	movs	r1, #0
  20623c:	6820      	ldr	r0, [r4, #0]
  20623e:	f7fd fadf 	bl	203800 <motor4>
		 				HAL_GPIO_WritePin(GPIOE,GPIO_PIN_10,1);
  206242:	2201      	movs	r2, #1
  206244:	f44f 6180 	mov.w	r1, #1024	; 0x400
  206248:	483e      	ldr	r0, [pc, #248]	; (206344 <motor_move+0x1424>)
  20624a:	f7fa ff49 	bl	2010e0 <HAL_GPIO_WritePin>
		 			  digtemp=180;
  20624e:	23b4      	movs	r3, #180	; 0xb4
  206250:	e707      	b.n	206062 <motor_move+0x1142>
		 		  else if(digree>203 && digree<=248){
  206252:	f1a3 02cc 	sub.w	r2, r3, #204	; 0xcc
  206256:	2a2c      	cmp	r2, #44	; 0x2c
  206258:	d836      	bhi.n	2062c8 <motor_move+0x13a8>
		 			  if(digtemp!=225){
  20625a:	682b      	ldr	r3, [r5, #0]
  20625c:	2be1      	cmp	r3, #225	; 0xe1
  20625e:	d01b      	beq.n	206298 <motor_move+0x1378>
		 				  motor1(0,0);
  206260:	2100      	movs	r1, #0
  206262:	4608      	mov	r0, r1
  206264:	f7fd fa72 	bl	20374c <motor1>
		 				  motor2(0,0);
  206268:	2100      	movs	r1, #0
  20626a:	4608      	mov	r0, r1
  20626c:	f7fd fa8c 	bl	203788 <motor2>
		 				  motor3(0,0);
  206270:	2100      	movs	r1, #0
  206272:	4608      	mov	r0, r1
  206274:	f7fd faa6 	bl	2037c4 <motor3>
		 				  motor4(0,0);
  206278:	2100      	movs	r1, #0
  20627a:	4608      	mov	r0, r1
  20627c:	f7fd fac0 	bl	203800 <motor4>
		 					HAL_GPIO_WritePin(GPIOE,GPIO_PIN_10,0);
  206280:	2200      	movs	r2, #0
  206282:	f44f 6180 	mov.w	r1, #1024	; 0x400
  206286:	482f      	ldr	r0, [pc, #188]	; (206344 <motor_move+0x1424>)
  206288:	f7fa ff2a 	bl	2010e0 <HAL_GPIO_WritePin>
		 				xprintf("bleak now\r\n");
  20628c:	482e      	ldr	r0, [pc, #184]	; (206348 <motor_move+0x1428>)
  20628e:	f001 f859 	bl	207344 <xprintf>
		 				  HAL_Delay(bleak_time);
  206292:	2014      	movs	r0, #20
  206294:	f7fa fc06 	bl	200aa4 <HAL_Delay>
		 			  motor1(power,0);
  206298:	2100      	movs	r1, #0
  20629a:	6820      	ldr	r0, [r4, #0]
  20629c:	f7fd fa56 	bl	20374c <motor1>
		 			  motor2(0,0);
  2062a0:	2100      	movs	r1, #0
  2062a2:	4608      	mov	r0, r1
  2062a4:	f7fd fa70 	bl	203788 <motor2>
		 			  motor3(power,0);
  2062a8:	2100      	movs	r1, #0
  2062aa:	6820      	ldr	r0, [r4, #0]
  2062ac:	f7fd fa8a 	bl	2037c4 <motor3>
		 			  motor4(0,0);
  2062b0:	2100      	movs	r1, #0
  2062b2:	4608      	mov	r0, r1
  2062b4:	f7fd faa4 	bl	203800 <motor4>
		 				HAL_GPIO_WritePin(GPIOE,GPIO_PIN_10,1);
  2062b8:	2201      	movs	r2, #1
  2062ba:	f44f 6180 	mov.w	r1, #1024	; 0x400
  2062be:	4821      	ldr	r0, [pc, #132]	; (206344 <motor_move+0x1424>)
  2062c0:	f7fa ff0e 	bl	2010e0 <HAL_GPIO_WritePin>
		 			  digtemp=225;
  2062c4:	23e1      	movs	r3, #225	; 0xe1
  2062c6:	e6cc      	b.n	206062 <motor_move+0x1142>
		 		  else if(digree>248 && digree<=293){
  2062c8:	3bf9      	subs	r3, #249	; 0xf9
  2062ca:	2b2c      	cmp	r3, #44	; 0x2c
  2062cc:	d840      	bhi.n	206350 <motor_move+0x1430>
		 			  if(digtemp!=270){
  2062ce:	682b      	ldr	r3, [r5, #0]
  2062d0:	f5b3 7f87 	cmp.w	r3, #270	; 0x10e
  2062d4:	d01b      	beq.n	20630e <motor_move+0x13ee>
		 				  motor1(0,0);
  2062d6:	2100      	movs	r1, #0
  2062d8:	4608      	mov	r0, r1
  2062da:	f7fd fa37 	bl	20374c <motor1>
		 				  motor2(0,0);
  2062de:	2100      	movs	r1, #0
  2062e0:	4608      	mov	r0, r1
  2062e2:	f7fd fa51 	bl	203788 <motor2>
		 				  motor3(0,0);
  2062e6:	2100      	movs	r1, #0
  2062e8:	4608      	mov	r0, r1
  2062ea:	f7fd fa6b 	bl	2037c4 <motor3>
		 				  motor4(0,0);
  2062ee:	2100      	movs	r1, #0
  2062f0:	4608      	mov	r0, r1
  2062f2:	f7fd fa85 	bl	203800 <motor4>
		 					HAL_GPIO_WritePin(GPIOE,GPIO_PIN_10,0);
  2062f6:	2200      	movs	r2, #0
  2062f8:	f44f 6180 	mov.w	r1, #1024	; 0x400
  2062fc:	4811      	ldr	r0, [pc, #68]	; (206344 <motor_move+0x1424>)
  2062fe:	f7fa feef 	bl	2010e0 <HAL_GPIO_WritePin>
		 				xprintf("bleak now\r\n");
  206302:	4811      	ldr	r0, [pc, #68]	; (206348 <motor_move+0x1428>)
  206304:	f001 f81e 	bl	207344 <xprintf>
		 				  HAL_Delay(bleak_time);
  206308:	2014      	movs	r0, #20
  20630a:	f7fa fbcb 	bl	200aa4 <HAL_Delay>
		 			  motor1(power,0);
  20630e:	2100      	movs	r1, #0
  206310:	6820      	ldr	r0, [r4, #0]
  206312:	f7fd fa1b 	bl	20374c <motor1>
		 			  motor2(0,power);
  206316:	6821      	ldr	r1, [r4, #0]
  206318:	2000      	movs	r0, #0
  20631a:	f7fd fa35 	bl	203788 <motor2>
		 			  motor3(power,0);
  20631e:	2100      	movs	r1, #0
  206320:	6820      	ldr	r0, [r4, #0]
  206322:	f7fd fa4f 	bl	2037c4 <motor3>
		 			  motor4(0,power);
  206326:	6821      	ldr	r1, [r4, #0]
  206328:	2000      	movs	r0, #0
  20632a:	f7fd fa69 	bl	203800 <motor4>
		 				HAL_GPIO_WritePin(GPIOE,GPIO_PIN_10,1);
  20632e:	2201      	movs	r2, #1
  206330:	f44f 6180 	mov.w	r1, #1024	; 0x400
  206334:	4803      	ldr	r0, [pc, #12]	; (206344 <motor_move+0x1424>)
  206336:	f7fa fed3 	bl	2010e0 <HAL_GPIO_WritePin>
		 			  digtemp=270;
  20633a:	f44f 7387 	mov.w	r3, #270	; 0x10e
  20633e:	e690      	b.n	206062 <motor_move+0x1142>
  206340:	20000210 	.word	0x20000210
  206344:	40021000 	.word	0x40021000
  206348:	002077e3 	.word	0x002077e3
  20634c:	002077ef 	.word	0x002077ef
		 			  if(digtemp!=315){
  206350:	682a      	ldr	r2, [r5, #0]
  206352:	f240 133b 	movw	r3, #315	; 0x13b
  206356:	429a      	cmp	r2, r3
  206358:	d01b      	beq.n	206392 <motor_move+0x1472>
		 				  motor1(0,0);
  20635a:	2100      	movs	r1, #0
  20635c:	4608      	mov	r0, r1
  20635e:	f7fd f9f5 	bl	20374c <motor1>
		 				  motor2(0,0);
  206362:	2100      	movs	r1, #0
  206364:	4608      	mov	r0, r1
  206366:	f7fd fa0f 	bl	203788 <motor2>
		 				  motor3(0,0);
  20636a:	2100      	movs	r1, #0
  20636c:	4608      	mov	r0, r1
  20636e:	f7fd fa29 	bl	2037c4 <motor3>
		 				  motor4(0,0);
  206372:	2100      	movs	r1, #0
  206374:	4608      	mov	r0, r1
  206376:	f7fd fa43 	bl	203800 <motor4>
		 					HAL_GPIO_WritePin(GPIOE,GPIO_PIN_10,0);
  20637a:	2200      	movs	r2, #0
  20637c:	f44f 6180 	mov.w	r1, #1024	; 0x400
  206380:	482d      	ldr	r0, [pc, #180]	; (206438 <motor_move+0x1518>)
  206382:	f7fa fead 	bl	2010e0 <HAL_GPIO_WritePin>
		 				xprintf("bleak now\r\n");
  206386:	482d      	ldr	r0, [pc, #180]	; (20643c <motor_move+0x151c>)
  206388:	f000 ffdc 	bl	207344 <xprintf>
		 				  HAL_Delay(bleak_time);
  20638c:	2014      	movs	r0, #20
  20638e:	f7fa fb89 	bl	200aa4 <HAL_Delay>
		 			  motor1(0,0);
  206392:	2100      	movs	r1, #0
  206394:	4608      	mov	r0, r1
  206396:	f7fd f9d9 	bl	20374c <motor1>
		 			  motor2(0,power);
  20639a:	6821      	ldr	r1, [r4, #0]
  20639c:	2000      	movs	r0, #0
  20639e:	f7fd f9f3 	bl	203788 <motor2>
		 			  motor3(0,0);
  2063a2:	2100      	movs	r1, #0
  2063a4:	4608      	mov	r0, r1
  2063a6:	f7fd fa0d 	bl	2037c4 <motor3>
		 			  motor4(0,power);
  2063aa:	6821      	ldr	r1, [r4, #0]
  2063ac:	2000      	movs	r0, #0
  2063ae:	f7fd fa27 	bl	203800 <motor4>
		 				HAL_GPIO_WritePin(GPIOE,GPIO_PIN_10,1);
  2063b2:	2201      	movs	r2, #1
  2063b4:	f44f 6180 	mov.w	r1, #1024	; 0x400
  2063b8:	481f      	ldr	r0, [pc, #124]	; (206438 <motor_move+0x1518>)
  2063ba:	f7fa fe91 	bl	2010e0 <HAL_GPIO_WritePin>
		 			  digtemp=315;
  2063be:	f240 133b 	movw	r3, #315	; 0x13b
  2063c2:	e64e      	b.n	206062 <motor_move+0x1142>
				if(digtemp!=3000){
  2063c4:	4d1e      	ldr	r5, [pc, #120]	; (206440 <motor_move+0x1520>)
  2063c6:	f640 32b8 	movw	r2, #3000	; 0xbb8
  2063ca:	6829      	ldr	r1, [r5, #0]
  2063cc:	4291      	cmp	r1, r2
  2063ce:	d018      	beq.n	206402 <motor_move+0x14e2>
					motor1(0,0);
  2063d0:	2100      	movs	r1, #0
  2063d2:	4608      	mov	r0, r1
  2063d4:	f7fd f9ba 	bl	20374c <motor1>
					motor2(0,0);
  2063d8:	2100      	movs	r1, #0
  2063da:	4608      	mov	r0, r1
  2063dc:	f7fd f9d4 	bl	203788 <motor2>
					motor3(0,0);
  2063e0:	2100      	movs	r1, #0
  2063e2:	4608      	mov	r0, r1
  2063e4:	f7fd f9ee 	bl	2037c4 <motor3>
					motor4(0,0);
  2063e8:	2100      	movs	r1, #0
  2063ea:	4608      	mov	r0, r1
  2063ec:	f7fd fa08 	bl	203800 <motor4>
					HAL_GPIO_WritePin(GPIOE,GPIO_PIN_10,0);
  2063f0:	4811      	ldr	r0, [pc, #68]	; (206438 <motor_move+0x1518>)
  2063f2:	2200      	movs	r2, #0
  2063f4:	f44f 6180 	mov.w	r1, #1024	; 0x400
  2063f8:	f7fa fe72 	bl	2010e0 <HAL_GPIO_WritePin>
					HAL_Delay(bleak_time);
  2063fc:	2014      	movs	r0, #20
  2063fe:	f7fa fb51 	bl	200aa4 <HAL_Delay>
				motor1(power,0);
  206402:	2100      	movs	r1, #0
  206404:	6820      	ldr	r0, [r4, #0]
  206406:	f7fd f9a1 	bl	20374c <motor1>
				motor2(power,0);
  20640a:	2100      	movs	r1, #0
  20640c:	6820      	ldr	r0, [r4, #0]
  20640e:	f7fd f9bb 	bl	203788 <motor2>
				motor3(0,power);
  206412:	6821      	ldr	r1, [r4, #0]
  206414:	2000      	movs	r0, #0
  206416:	f7fd f9d5 	bl	2037c4 <motor3>
				motor4(0,power);
  20641a:	6821      	ldr	r1, [r4, #0]
  20641c:	2000      	movs	r0, #0
  20641e:	f7fd f9ef 	bl	203800 <motor4>
				HAL_GPIO_WritePin(GPIOE,GPIO_PIN_10,1);
  206422:	2201      	movs	r2, #1
  206424:	f44f 6180 	mov.w	r1, #1024	; 0x400
  206428:	4803      	ldr	r0, [pc, #12]	; (206438 <motor_move+0x1518>)
  20642a:	f7fa fe59 	bl	2010e0 <HAL_GPIO_WritePin>
				digtemp=3000;
  20642e:	f640 33b8 	movw	r3, #3000	; 0xbb8
  206432:	f7fe bef3 	b.w	20521c <motor_move+0x2fc>
  206436:	bf00      	nop
  206438:	40021000 	.word	0x40021000
  20643c:	002077e3 	.word	0x002077e3
  206440:	20000210 	.word	0x20000210

00206444 <printLCD>:
	if (digree >= 0 && digree <= 360) {
  206444:	4b18      	ldr	r3, [pc, #96]	; (2064a8 <printLCD+0x64>)
  206446:	681b      	ldr	r3, [r3, #0]
  206448:	f5b3 7fb4 	cmp.w	r3, #360	; 0x168
  20644c:	d829      	bhi.n	2064a2 <printLCD+0x5e>
		if (digree <= 23 || digree >= 338) {oled_puts("Running   FD");}
  20644e:	f1a3 0218 	sub.w	r2, r3, #24
  206452:	f5b2 7f9d 	cmp.w	r2, #314	; 0x13a
  206456:	d302      	bcc.n	20645e <printLCD+0x1a>
  206458:	4814      	ldr	r0, [pc, #80]	; (2064ac <printLCD+0x68>)
else{oled_puts("Running  ST");}
  20645a:	f7fd bb91 	b.w	203b80 <oled_puts>
		else if (digree>23 && digree <= 68)   {oled_puts("Running   RF");}
  20645e:	2a2c      	cmp	r2, #44	; 0x2c
  206460:	d801      	bhi.n	206466 <printLCD+0x22>
  206462:	4813      	ldr	r0, [pc, #76]	; (2064b0 <printLCD+0x6c>)
  206464:	e7f9      	b.n	20645a <printLCD+0x16>
		else if (digree>68 && digree <= 113)  {oled_puts("Running   Ri");}
  206466:	f1a3 0245 	sub.w	r2, r3, #69	; 0x45
  20646a:	2a2c      	cmp	r2, #44	; 0x2c
  20646c:	d801      	bhi.n	206472 <printLCD+0x2e>
  20646e:	4811      	ldr	r0, [pc, #68]	; (2064b4 <printLCD+0x70>)
  206470:	e7f3      	b.n	20645a <printLCD+0x16>
		else if (digree>113 && digree <= 158) {oled_puts("Running   RB");}
  206472:	f1a3 0272 	sub.w	r2, r3, #114	; 0x72
  206476:	2a2c      	cmp	r2, #44	; 0x2c
  206478:	d801      	bhi.n	20647e <printLCD+0x3a>
  20647a:	480f      	ldr	r0, [pc, #60]	; (2064b8 <printLCD+0x74>)
  20647c:	e7ed      	b.n	20645a <printLCD+0x16>
		else if (digree>158 && digree <= 203) {oled_puts("Running   BK");}
  20647e:	f1a3 029f 	sub.w	r2, r3, #159	; 0x9f
  206482:	2a2c      	cmp	r2, #44	; 0x2c
  206484:	d801      	bhi.n	20648a <printLCD+0x46>
  206486:	480d      	ldr	r0, [pc, #52]	; (2064bc <printLCD+0x78>)
  206488:	e7e7      	b.n	20645a <printLCD+0x16>
		else if (digree>203 && digree <= 248) {oled_puts("Running   LB");}
  20648a:	f1a3 02cc 	sub.w	r2, r3, #204	; 0xcc
  20648e:	2a2c      	cmp	r2, #44	; 0x2c
  206490:	d801      	bhi.n	206496 <printLCD+0x52>
  206492:	480b      	ldr	r0, [pc, #44]	; (2064c0 <printLCD+0x7c>)
  206494:	e7e1      	b.n	20645a <printLCD+0x16>
		else if (digree>248 && digree <= 293) {oled_puts("Running   Le");}
  206496:	3bf9      	subs	r3, #249	; 0xf9
  206498:	2b2c      	cmp	r3, #44	; 0x2c
  20649a:	bf94      	ite	ls
  20649c:	4809      	ldrls	r0, [pc, #36]	; (2064c4 <printLCD+0x80>)
		else if (digree>293 && digree <= 338) {oled_puts("Running   LF");}
  20649e:	480a      	ldrhi	r0, [pc, #40]	; (2064c8 <printLCD+0x84>)
  2064a0:	e7db      	b.n	20645a <printLCD+0x16>
else{oled_puts("Running  ST");}
  2064a2:	480a      	ldr	r0, [pc, #40]	; (2064cc <printLCD+0x88>)
  2064a4:	e7d9      	b.n	20645a <printLCD+0x16>
  2064a6:	bf00      	nop
  2064a8:	200001b8 	.word	0x200001b8
  2064ac:	00207800 	.word	0x00207800
  2064b0:	0020780d 	.word	0x0020780d
  2064b4:	0020781a 	.word	0x0020781a
  2064b8:	00207827 	.word	0x00207827
  2064bc:	00207834 	.word	0x00207834
  2064c0:	00207841 	.word	0x00207841
  2064c4:	0020784e 	.word	0x0020784e
  2064c8:	0020785b 	.word	0x0020785b
  2064cc:	00207868 	.word	0x00207868

002064d0 <getUs>:
 */
#include "microsectimer.h"



uint32_t getUs(void) {
  2064d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
uint32_t usTicks = HAL_RCC_GetSysClockFreq() / 1000000;
  2064d2:	4c0c      	ldr	r4, [pc, #48]	; (206504 <getUs+0x34>)
  2064d4:	f7fb fb0a 	bl	201aec <HAL_RCC_GetSysClockFreq>
register uint32_t ms, cycle_cnt;
do {
ms = HAL_GetTick();
cycle_cnt = SysTick->VAL;
  2064d8:	4f0b      	ldr	r7, [pc, #44]	; (206508 <getUs+0x38>)
uint32_t usTicks = HAL_RCC_GetSysClockFreq() / 1000000;
  2064da:	fbb0 f4f4 	udiv	r4, r0, r4
ms = HAL_GetTick();
  2064de:	f7fa fadb 	bl	200a98 <HAL_GetTick>
  2064e2:	4605      	mov	r5, r0
cycle_cnt = SysTick->VAL;
  2064e4:	68be      	ldr	r6, [r7, #8]
} while (ms != HAL_GetTick());
  2064e6:	f7fa fad7 	bl	200a98 <HAL_GetTick>
  2064ea:	4285      	cmp	r5, r0
  2064ec:	d1f7      	bne.n	2064de <getUs+0xe>
return (ms * 1000) + (usTicks * 1000 - cycle_cnt) / usTicks;
  2064ee:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
  2064f2:	fb03 f004 	mul.w	r0, r3, r4
  2064f6:	1b80      	subs	r0, r0, r6
  2064f8:	fbb0 f0f4 	udiv	r0, r0, r4
}
  2064fc:	fb03 0005 	mla	r0, r3, r5, r0
  206500:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  206502:	bf00      	nop
  206504:	000f4240 	.word	0x000f4240
  206508:	e000e010 	.word	0xe000e010

0020650c <delayUs>:

void delayUs(uint16_t micros) {
  20650c:	b538      	push	{r3, r4, r5, lr}
  20650e:	4604      	mov	r4, r0
uint32_t start = getUs();
  206510:	f7ff ffde 	bl	2064d0 <getUs>
  206514:	4605      	mov	r5, r0
while (getUs()-start < (uint32_t) micros) {
  206516:	f7ff ffdb 	bl	2064d0 <getUs>
  20651a:	1b40      	subs	r0, r0, r5
  20651c:	42a0      	cmp	r0, r4
  20651e:	d300      	bcc.n	206522 <delayUs+0x16>
	asm("nop");
}
}
  206520:	bd38      	pop	{r3, r4, r5, pc}
	asm("nop");
  206522:	bf00      	nop
  206524:	e7f7      	b.n	206516 <delayUs+0xa>
	...

00206528 <solenoid>:


void solenoid(uint8_t movedata){
	uint8_t tempbuf;
	tempbuf=(movedata & 0b00000010)>>1;
	if(tempbuf==1){
  206528:	f3c0 0240 	ubfx	r2, r0, #1, #1
		HAL_GPIO_TogglePin(GPIOC,GPIO_PIN_14);
  20652c:	f44f 4180 	mov.w	r1, #16384	; 0x4000
void solenoid(uint8_t movedata){
  206530:	b510      	push	{r4, lr}
  206532:	4604      	mov	r4, r0
		HAL_GPIO_TogglePin(GPIOC,GPIO_PIN_14);
  206534:	480a      	ldr	r0, [pc, #40]	; (206560 <solenoid+0x38>)
	if(tempbuf==1){
  206536:	b17a      	cbz	r2, 206558 <solenoid+0x30>
		HAL_GPIO_TogglePin(GPIOC,GPIO_PIN_14);
  206538:	f7fa fdd7 	bl	2010ea <HAL_GPIO_TogglePin>
		HAL_Delay(75);
  20653c:	204b      	movs	r0, #75	; 0x4b
  20653e:	f7fa fab1 	bl	200aa4 <HAL_Delay>
	}
	else{
		HAL_GPIO_WritePin(GPIOC,GPIO_PIN_14,0);
	}
	tempbuf=(movedata & 0b00000100)>>2;
	if(tempbuf==1){HAL_GPIO_WritePin(GPIOC,GPIO_PIN_15,1);}
  206542:	f3c4 0280 	ubfx	r2, r4, #2, #1
  206546:	b102      	cbz	r2, 20654a <solenoid+0x22>
  206548:	2201      	movs	r2, #1
	else{HAL_GPIO_WritePin(GPIOC,GPIO_PIN_15,0);}
  20654a:	f44f 4100 	mov.w	r1, #32768	; 0x8000
  20654e:	4804      	ldr	r0, [pc, #16]	; (206560 <solenoid+0x38>)
}
  206550:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	else{HAL_GPIO_WritePin(GPIOC,GPIO_PIN_15,0);}
  206554:	f7fa bdc4 	b.w	2010e0 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GPIOC,GPIO_PIN_14,0);
  206558:	f7fa fdc2 	bl	2010e0 <HAL_GPIO_WritePin>
  20655c:	e7f1      	b.n	206542 <solenoid+0x1a>
  20655e:	bf00      	nop
  206560:	40020800 	.word	0x40020800

00206564 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
  206564:	b508      	push	{r3, lr}
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
  206566:	2003      	movs	r0, #3
  206568:	f7fa faaa 	bl	200ac0 <HAL_NVIC_SetPriorityGrouping>

  /* System interrupt init*/
  /* MemoryManagement_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(MemoryManagement_IRQn, 0, 0);
  20656c:	2200      	movs	r2, #0
  20656e:	f06f 000b 	mvn.w	r0, #11
  206572:	4611      	mov	r1, r2
  206574:	f7fa fab6 	bl	200ae4 <HAL_NVIC_SetPriority>
  /* BusFault_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(BusFault_IRQn, 0, 0);
  206578:	2200      	movs	r2, #0
  20657a:	f06f 000a 	mvn.w	r0, #10
  20657e:	4611      	mov	r1, r2
  206580:	f7fa fab0 	bl	200ae4 <HAL_NVIC_SetPriority>
  /* UsageFault_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(UsageFault_IRQn, 0, 0);
  206584:	2200      	movs	r2, #0
  206586:	f06f 0009 	mvn.w	r0, #9
  20658a:	4611      	mov	r1, r2
  20658c:	f7fa faaa 	bl	200ae4 <HAL_NVIC_SetPriority>
  /* SVCall_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SVCall_IRQn, 0, 0);
  206590:	2200      	movs	r2, #0
  206592:	f06f 0004 	mvn.w	r0, #4
  206596:	4611      	mov	r1, r2
  206598:	f7fa faa4 	bl	200ae4 <HAL_NVIC_SetPriority>
  /* DebugMonitor_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DebugMonitor_IRQn, 0, 0);
  20659c:	2200      	movs	r2, #0
  20659e:	f06f 0003 	mvn.w	r0, #3
  2065a2:	4611      	mov	r1, r2
  2065a4:	f7fa fa9e 	bl	200ae4 <HAL_NVIC_SetPriority>
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 0, 0);
  2065a8:	2200      	movs	r2, #0
  2065aa:	f06f 0001 	mvn.w	r0, #1
  2065ae:	4611      	mov	r1, r2
  2065b0:	f7fa fa98 	bl	200ae4 <HAL_NVIC_SetPriority>
  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
  2065b4:	2200      	movs	r2, #0
  2065b6:	f04f 30ff 	mov.w	r0, #4294967295
  2065ba:	4611      	mov	r1, r2

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
  2065bc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
  2065c0:	f7fa ba90 	b.w	200ae4 <HAL_NVIC_SetPriority>

002065c4 <NMI_Handler>:
  2065c4:	4770      	bx	lr

002065c6 <HardFault_Handler>:

/**
* @brief This function handles Hard fault interrupt.
*/
void HardFault_Handler(void)
{
  2065c6:	e7fe      	b.n	2065c6 <HardFault_Handler>

002065c8 <MemManage_Handler>:

/**
* @brief This function handles Memory management fault.
*/
void MemManage_Handler(void)
{
  2065c8:	e7fe      	b.n	2065c8 <MemManage_Handler>

002065ca <BusFault_Handler>:

/**
* @brief This function handles Pre-fetch fault, memory access fault.
*/
void BusFault_Handler(void)
{
  2065ca:	e7fe      	b.n	2065ca <BusFault_Handler>

002065cc <UsageFault_Handler>:

/**
* @brief This function handles Undefined instruction or illegal state.
*/
void UsageFault_Handler(void)
{
  2065cc:	e7fe      	b.n	2065cc <UsageFault_Handler>

002065ce <SVC_Handler>:
  2065ce:	4770      	bx	lr

002065d0 <DebugMon_Handler>:
  2065d0:	4770      	bx	lr

002065d2 <PendSV_Handler>:

/**
* @brief This function handles Pendable request for system service.
*/
void PendSV_Handler(void)
{
  2065d2:	4770      	bx	lr

002065d4 <SysTick_Handler>:

/**
* @brief This function handles System tick timer.
*/
void SysTick_Handler(void)
{
  2065d4:	b508      	push	{r3, lr}
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
  2065d6:	f7fa fa57 	bl	200a88 <HAL_IncTick>
  HAL_SYSTICK_IRQHandler();
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
  2065da:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_SYSTICK_IRQHandler();
  2065de:	f7fa bae8 	b.w	200bb2 <HAL_SYSTICK_IRQHandler>
	...

002065e4 <I2C2_EV_IRQHandler>:
void I2C2_EV_IRQHandler(void)
{
  /* USER CODE BEGIN I2C2_EV_IRQn 0 */

  /* USER CODE END I2C2_EV_IRQn 0 */
  HAL_I2C_EV_IRQHandler(&hi2c2);
  2065e4:	4801      	ldr	r0, [pc, #4]	; (2065ec <I2C2_EV_IRQHandler+0x8>)
  2065e6:	f7fb b836 	b.w	201656 <HAL_I2C_EV_IRQHandler>
  2065ea:	bf00      	nop
  2065ec:	20000118 	.word	0x20000118

002065f0 <USART1_IRQHandler>:
void USART1_IRQHandler(void)
{
  /* USER CODE BEGIN USART1_IRQn 0 */

  /* USER CODE END USART1_IRQn 0 */
  HAL_UART_IRQHandler(&huart1);
  2065f0:	4801      	ldr	r0, [pc, #4]	; (2065f8 <USART1_IRQHandler+0x8>)
  2065f2:	f7fc bb35 	b.w	202c60 <HAL_UART_IRQHandler>
  2065f6:	bf00      	nop
  2065f8:	20000538 	.word	0x20000538

002065fc <TIM6_DAC_IRQHandler>:
void TIM6_DAC_IRQHandler(void)
{
  /* USER CODE BEGIN TIM6_DAC_IRQn 0 */

  /* USER CODE END TIM6_DAC_IRQn 0 */
  HAL_TIM_IRQHandler(&htim6);
  2065fc:	4801      	ldr	r0, [pc, #4]	; (206604 <TIM6_DAC_IRQHandler+0x8>)
  2065fe:	f7fb be10 	b.w	202222 <HAL_TIM_IRQHandler>
  206602:	bf00      	nop
  206604:	20000398 	.word	0x20000398

00206608 <DMA2_Stream2_IRQHandler>:
void DMA2_Stream2_IRQHandler(void)
{
  /* USER CODE BEGIN DMA2_Stream2_IRQn 0 */

  /* USER CODE END DMA2_Stream2_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_usart1_rx);
  206608:	4801      	ldr	r0, [pc, #4]	; (206610 <DMA2_Stream2_IRQHandler+0x8>)
  20660a:	f7fa bbbb 	b.w	200d84 <HAL_DMA_IRQHandler>
  20660e:	bf00      	nop
  206610:	200004d8 	.word	0x200004d8

00206614 <SystemInit>:
  */
void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
  206614:	490f      	ldr	r1, [pc, #60]	; (206654 <SystemInit+0x40>)
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
  206616:	2000      	movs	r0, #0
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
  206618:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
  20661c:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
  206620:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  RCC->CR |= (uint32_t)0x00000001;
  206624:	4b0c      	ldr	r3, [pc, #48]	; (206658 <SystemInit+0x44>)
  206626:	681a      	ldr	r2, [r3, #0]
  206628:	f042 0201 	orr.w	r2, r2, #1
  20662c:	601a      	str	r2, [r3, #0]
  RCC->CFGR = 0x00000000;
  20662e:	6098      	str	r0, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
  206630:	681a      	ldr	r2, [r3, #0]
  206632:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
  206636:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
  20663a:	601a      	str	r2, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
  20663c:	4a07      	ldr	r2, [pc, #28]	; (20665c <SystemInit+0x48>)
  20663e:	605a      	str	r2, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
  206640:	681a      	ldr	r2, [r3, #0]
  206642:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
  206646:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
  206648:	60d8      	str	r0, [r3, #12]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = RAMDTCM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
  20664a:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
  20664e:	608b      	str	r3, [r1, #8]
  206650:	4770      	bx	lr
  206652:	bf00      	nop
  206654:	e000ed00 	.word	0xe000ed00
  206658:	40023800 	.word	0x40023800
  20665c:	24003010 	.word	0x24003010

00206660 <MX_TIM5_Init>:
  HAL_TIM_MspPostInit(&htim4);

}
/* TIM5 init function */
void MX_TIM5_Init(void)
{
  206660:	b510      	push	{r4, lr}
  htim5.Instance = TIM5;
  206662:	4817      	ldr	r0, [pc, #92]	; (2066c0 <MX_TIM5_Init+0x60>)
  htim5.Init.Prescaler = 1;
  206664:	2401      	movs	r4, #1
  206666:	4b17      	ldr	r3, [pc, #92]	; (2066c4 <MX_TIM5_Init+0x64>)
  htim5.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim5.Init.Period = 60000;
  206668:	f64e 2260 	movw	r2, #60000	; 0xea60
  htim5.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim5.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  sConfig.EncoderMode = TIM_ENCODERMODE_TI1;
  20666c:	4916      	ldr	r1, [pc, #88]	; (2066c8 <MX_TIM5_Init+0x68>)
  htim5.Init.Period = 60000;
  20666e:	60c2      	str	r2, [r0, #12]
  sConfig.IC1Polarity = TIM_ICPOLARITY_FALLING;
  206670:	2202      	movs	r2, #2
  sConfig.EncoderMode = TIM_ENCODERMODE_TI1;
  206672:	600c      	str	r4, [r1, #0]
  sConfig.IC1Polarity = TIM_ICPOLARITY_FALLING;
  206674:	604a      	str	r2, [r1, #4]
  sConfig.IC1Selection = TIM_ICSELECTION_DIRECTTI;
  206676:	608c      	str	r4, [r1, #8]
  sConfig.IC1Prescaler = TIM_ICPSC_DIV1;
  sConfig.IC1Filter = 2;
  206678:	610a      	str	r2, [r1, #16]
  sConfig.IC2Polarity = TIM_ICPOLARITY_FALLING;
  20667a:	614a      	str	r2, [r1, #20]
  sConfig.IC2Selection = TIM_ICSELECTION_DIRECTTI;
  20667c:	618c      	str	r4, [r1, #24]
  sConfig.IC2Prescaler = TIM_ICPSC_DIV1;
  sConfig.IC2Filter = 2;
  20667e:	620a      	str	r2, [r1, #32]
  htim5.Init.Prescaler = 1;
  206680:	e880 0018 	stmia.w	r0, {r3, r4}
  htim5.Init.CounterMode = TIM_COUNTERMODE_UP;
  206684:	2300      	movs	r3, #0
  206686:	6083      	str	r3, [r0, #8]
  htim5.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  206688:	6103      	str	r3, [r0, #16]
  htim5.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  20668a:	6183      	str	r3, [r0, #24]
  sConfig.IC1Prescaler = TIM_ICPSC_DIV1;
  20668c:	60cb      	str	r3, [r1, #12]
  sConfig.IC2Prescaler = TIM_ICPSC_DIV1;
  20668e:	61cb      	str	r3, [r1, #28]
  if (HAL_TIM_Encoder_Init(&htim5, &sConfig) != HAL_OK)
  206690:	f7fb ff14 	bl	2024bc <HAL_TIM_Encoder_Init>
  206694:	b120      	cbz	r0, 2066a0 <MX_TIM5_Init+0x40>
  {
    _Error_Handler(__FILE__, __LINE__);
  206696:	f44f 7196 	mov.w	r1, #300	; 0x12c
  20669a:	480c      	ldr	r0, [pc, #48]	; (2066cc <MX_TIM5_Init+0x6c>)
  20669c:	f7fe fc34 	bl	204f08 <_Error_Handler>
  }

  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  2066a0:	490b      	ldr	r1, [pc, #44]	; (2066d0 <MX_TIM5_Init+0x70>)
  2066a2:	2300      	movs	r3, #0
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim5, &sMasterConfig) != HAL_OK)
  2066a4:	4806      	ldr	r0, [pc, #24]	; (2066c0 <MX_TIM5_Init+0x60>)
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  2066a6:	600b      	str	r3, [r1, #0]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  2066a8:	608b      	str	r3, [r1, #8]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim5, &sMasterConfig) != HAL_OK)
  2066aa:	f7fc f885 	bl	2027b8 <HAL_TIMEx_MasterConfigSynchronization>
  2066ae:	b130      	cbz	r0, 2066be <MX_TIM5_Init+0x5e>
  {
    _Error_Handler(__FILE__, __LINE__);
  2066b0:	f240 1133 	movw	r1, #307	; 0x133
  2066b4:	4805      	ldr	r0, [pc, #20]	; (2066cc <MX_TIM5_Init+0x6c>)
  }

}
  2066b6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    _Error_Handler(__FILE__, __LINE__);
  2066ba:	f7fe bc25 	b.w	204f08 <_Error_Handler>
  2066be:	bd10      	pop	{r4, pc}
  2066c0:	200002d8 	.word	0x200002d8
  2066c4:	40000c00 	.word	0x40000c00
  2066c8:	200000a8 	.word	0x200000a8
  2066cc:	0020788c 	.word	0x0020788c
  2066d0:	20000054 	.word	0x20000054

002066d4 <MX_TIM6_Init>:
/* TIM6 init function */
void MX_TIM6_Init(void)
{
  2066d4:	b508      	push	{r3, lr}
  htim6.Instance = TIM6;
  2066d6:	4812      	ldr	r0, [pc, #72]	; (206720 <MX_TIM6_Init+0x4c>)
  htim6.Init.Prescaler = 864;
  2066d8:	f44f 7358 	mov.w	r3, #864	; 0x360
  2066dc:	4911      	ldr	r1, [pc, #68]	; (206724 <MX_TIM6_Init+0x50>)
  htim6.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim6.Init.Period = 50000-1;
  2066de:	f24c 324f 	movw	r2, #49999	; 0xc34f
  htim6.Init.Prescaler = 864;
  2066e2:	e880 000a 	stmia.w	r0, {r1, r3}
  htim6.Init.CounterMode = TIM_COUNTERMODE_UP;
  2066e6:	2300      	movs	r3, #0
  htim6.Init.Period = 50000-1;
  2066e8:	60c2      	str	r2, [r0, #12]
  htim6.Init.CounterMode = TIM_COUNTERMODE_UP;
  2066ea:	6083      	str	r3, [r0, #8]
  htim6.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  2066ec:	6183      	str	r3, [r0, #24]
  if (HAL_TIM_Base_Init(&htim6) != HAL_OK)
  2066ee:	f7fb feb1 	bl	202454 <HAL_TIM_Base_Init>
  2066f2:	b120      	cbz	r0, 2066fe <MX_TIM6_Init+0x2a>
  {
    _Error_Handler(__FILE__, __LINE__);
  2066f4:	f240 1141 	movw	r1, #321	; 0x141
  2066f8:	480b      	ldr	r0, [pc, #44]	; (206728 <MX_TIM6_Init+0x54>)
  2066fa:	f7fe fc05 	bl	204f08 <_Error_Handler>
  }

  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  2066fe:	490b      	ldr	r1, [pc, #44]	; (20672c <MX_TIM6_Init+0x58>)
  206700:	2300      	movs	r3, #0
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim6, &sMasterConfig) != HAL_OK)
  206702:	4807      	ldr	r0, [pc, #28]	; (206720 <MX_TIM6_Init+0x4c>)
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  206704:	600b      	str	r3, [r1, #0]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  206706:	608b      	str	r3, [r1, #8]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim6, &sMasterConfig) != HAL_OK)
  206708:	f7fc f856 	bl	2027b8 <HAL_TIMEx_MasterConfigSynchronization>
  20670c:	b130      	cbz	r0, 20671c <MX_TIM6_Init+0x48>
  {
    _Error_Handler(__FILE__, __LINE__);
  20670e:	f44f 71a4 	mov.w	r1, #328	; 0x148
  206712:	4805      	ldr	r0, [pc, #20]	; (206728 <MX_TIM6_Init+0x54>)
  }

}
  206714:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    _Error_Handler(__FILE__, __LINE__);
  206718:	f7fe bbf6 	b.w	204f08 <_Error_Handler>
  20671c:	bd08      	pop	{r3, pc}
  20671e:	bf00      	nop
  206720:	20000398 	.word	0x20000398
  206724:	40001000 	.word	0x40001000
  206728:	0020788c 	.word	0x0020788c
  20672c:	20000054 	.word	0x20000054

00206730 <MX_TIM8_Init>:
/* TIM8 init function */
void MX_TIM8_Init(void)
{
  htim8.Instance = TIM8;
  206730:	4818      	ldr	r0, [pc, #96]	; (206794 <MX_TIM8_Init+0x64>)
  htim8.Init.Prescaler = 1;
  htim8.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim8.Init.Period = 60000;
  206732:	f64e 2160 	movw	r1, #60000	; 0xea60
  htim8.Instance = TIM8;
  206736:	4b18      	ldr	r3, [pc, #96]	; (206798 <MX_TIM8_Init+0x68>)
  htim8.Init.Prescaler = 1;
  206738:	2201      	movs	r2, #1
{
  20673a:	b510      	push	{r4, lr}
  htim8.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  sConfig.EncoderMode = TIM_ENCODERMODE_TI1;
  sConfig.IC1Polarity = TIM_ICPOLARITY_RISING;
  sConfig.IC1Selection = TIM_ICSELECTION_DIRECTTI;
  sConfig.IC1Prescaler = TIM_ICPSC_DIV1;
  sConfig.IC1Filter = 2;
  20673c:	2402      	movs	r4, #2
  htim8.Instance = TIM8;
  20673e:	6003      	str	r3, [r0, #0]
  htim8.Init.Period = 60000;
  206740:	60c1      	str	r1, [r0, #12]
  htim8.Init.CounterMode = TIM_COUNTERMODE_UP;
  206742:	2300      	movs	r3, #0
  sConfig.EncoderMode = TIM_ENCODERMODE_TI1;
  206744:	4915      	ldr	r1, [pc, #84]	; (20679c <MX_TIM8_Init+0x6c>)
  htim8.Init.Prescaler = 1;
  206746:	6042      	str	r2, [r0, #4]
  htim8.Init.CounterMode = TIM_COUNTERMODE_UP;
  206748:	6083      	str	r3, [r0, #8]
  htim8.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  20674a:	6103      	str	r3, [r0, #16]
  htim8.Init.RepetitionCounter = 0;
  20674c:	6143      	str	r3, [r0, #20]
  htim8.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  20674e:	6183      	str	r3, [r0, #24]
  sConfig.IC1Selection = TIM_ICSELECTION_DIRECTTI;
  206750:	608a      	str	r2, [r1, #8]
  sConfig.IC1Prescaler = TIM_ICPSC_DIV1;
  206752:	60cb      	str	r3, [r1, #12]
  sConfig.IC1Filter = 2;
  206754:	610c      	str	r4, [r1, #16]
  sConfig.IC2Polarity = TIM_ICPOLARITY_RISING;
  206756:	614b      	str	r3, [r1, #20]
  sConfig.IC2Selection = TIM_ICSELECTION_DIRECTTI;
  206758:	618a      	str	r2, [r1, #24]
  sConfig.IC2Prescaler = TIM_ICPSC_DIV1;
  20675a:	61cb      	str	r3, [r1, #28]
  sConfig.IC2Filter = 2;
  20675c:	620c      	str	r4, [r1, #32]
  sConfig.IC1Polarity = TIM_ICPOLARITY_RISING;
  20675e:	e881 000c 	stmia.w	r1, {r2, r3}
  if (HAL_TIM_Encoder_Init(&htim8, &sConfig) != HAL_OK)
  206762:	f7fb feab 	bl	2024bc <HAL_TIM_Encoder_Init>
  206766:	b120      	cbz	r0, 206772 <MX_TIM8_Init+0x42>
  {
    _Error_Handler(__FILE__, __LINE__);
  206768:	f240 1161 	movw	r1, #353	; 0x161
  20676c:	480c      	ldr	r0, [pc, #48]	; (2067a0 <MX_TIM8_Init+0x70>)
  20676e:	f7fe fbcb 	bl	204f08 <_Error_Handler>
  }

  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  206772:	490c      	ldr	r1, [pc, #48]	; (2067a4 <MX_TIM8_Init+0x74>)
  206774:	2300      	movs	r3, #0
  sMasterConfig.MasterOutputTrigger2 = TIM_TRGO2_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim8, &sMasterConfig) != HAL_OK)
  206776:	4807      	ldr	r0, [pc, #28]	; (206794 <MX_TIM8_Init+0x64>)
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  206778:	600b      	str	r3, [r1, #0]
  sMasterConfig.MasterOutputTrigger2 = TIM_TRGO2_RESET;
  20677a:	604b      	str	r3, [r1, #4]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  20677c:	608b      	str	r3, [r1, #8]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim8, &sMasterConfig) != HAL_OK)
  20677e:	f7fc f81b 	bl	2027b8 <HAL_TIMEx_MasterConfigSynchronization>
  206782:	b130      	cbz	r0, 206792 <MX_TIM8_Init+0x62>
  {
    _Error_Handler(__FILE__, __LINE__);
  206784:	f240 1169 	movw	r1, #361	; 0x169
  206788:	4805      	ldr	r0, [pc, #20]	; (2067a0 <MX_TIM8_Init+0x70>)
  }

}
  20678a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    _Error_Handler(__FILE__, __LINE__);
  20678e:	f7fe bbbb 	b.w	204f08 <_Error_Handler>
  206792:	bd10      	pop	{r4, pc}
  206794:	20000218 	.word	0x20000218
  206798:	40010400 	.word	0x40010400
  20679c:	200000a8 	.word	0x200000a8
  2067a0:	0020788c 	.word	0x0020788c
  2067a4:	20000054 	.word	0x20000054

002067a8 <HAL_TIM_PWM_MspInit>:
}

void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef* tim_pwmHandle)
{

  if(tim_pwmHandle->Instance==TIM1)
  2067a8:	6803      	ldr	r3, [r0, #0]
{
  2067aa:	b086      	sub	sp, #24
  if(tim_pwmHandle->Instance==TIM1)
  2067ac:	4a2a      	ldr	r2, [pc, #168]	; (206858 <HAL_TIM_PWM_MspInit+0xb0>)
  2067ae:	4293      	cmp	r3, r2
  2067b0:	d10b      	bne.n	2067ca <HAL_TIM_PWM_MspInit+0x22>
  {
  /* USER CODE BEGIN TIM1_MspInit 0 */

  /* USER CODE END TIM1_MspInit 0 */
    /* TIM1 clock enable */
    __HAL_RCC_TIM1_CLK_ENABLE();
  2067b2:	4b2a      	ldr	r3, [pc, #168]	; (20685c <HAL_TIM_PWM_MspInit+0xb4>)
  2067b4:	6c5a      	ldr	r2, [r3, #68]	; 0x44
  2067b6:	f042 0201 	orr.w	r2, r2, #1
  2067ba:	645a      	str	r2, [r3, #68]	; 0x44
  2067bc:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  2067be:	f003 0301 	and.w	r3, r3, #1
  2067c2:	9300      	str	r3, [sp, #0]
  2067c4:	9b00      	ldr	r3, [sp, #0]
    __HAL_RCC_TIM12_CLK_ENABLE();
  /* USER CODE BEGIN TIM12_MspInit 1 */

  /* USER CODE END TIM12_MspInit 1 */
  }
}
  2067c6:	b006      	add	sp, #24
  2067c8:	4770      	bx	lr
  else if(tim_pwmHandle->Instance==TIM2)
  2067ca:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
  2067ce:	d10b      	bne.n	2067e8 <HAL_TIM_PWM_MspInit+0x40>
    __HAL_RCC_TIM2_CLK_ENABLE();
  2067d0:	f503 330e 	add.w	r3, r3, #145408	; 0x23800
  2067d4:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  2067d6:	f042 0201 	orr.w	r2, r2, #1
  2067da:	641a      	str	r2, [r3, #64]	; 0x40
  2067dc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  2067de:	f003 0301 	and.w	r3, r3, #1
  2067e2:	9301      	str	r3, [sp, #4]
  2067e4:	9b01      	ldr	r3, [sp, #4]
  2067e6:	e7ee      	b.n	2067c6 <HAL_TIM_PWM_MspInit+0x1e>
  else if(tim_pwmHandle->Instance==TIM3)
  2067e8:	4a1d      	ldr	r2, [pc, #116]	; (206860 <HAL_TIM_PWM_MspInit+0xb8>)
  2067ea:	4293      	cmp	r3, r2
  2067ec:	d10a      	bne.n	206804 <HAL_TIM_PWM_MspInit+0x5c>
    __HAL_RCC_TIM3_CLK_ENABLE();
  2067ee:	4b1b      	ldr	r3, [pc, #108]	; (20685c <HAL_TIM_PWM_MspInit+0xb4>)
  2067f0:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  2067f2:	f042 0202 	orr.w	r2, r2, #2
  2067f6:	641a      	str	r2, [r3, #64]	; 0x40
  2067f8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  2067fa:	f003 0302 	and.w	r3, r3, #2
  2067fe:	9302      	str	r3, [sp, #8]
  206800:	9b02      	ldr	r3, [sp, #8]
  206802:	e7e0      	b.n	2067c6 <HAL_TIM_PWM_MspInit+0x1e>
  else if(tim_pwmHandle->Instance==TIM4)
  206804:	4a17      	ldr	r2, [pc, #92]	; (206864 <HAL_TIM_PWM_MspInit+0xbc>)
  206806:	4293      	cmp	r3, r2
  206808:	d10a      	bne.n	206820 <HAL_TIM_PWM_MspInit+0x78>
    __HAL_RCC_TIM4_CLK_ENABLE();
  20680a:	4b14      	ldr	r3, [pc, #80]	; (20685c <HAL_TIM_PWM_MspInit+0xb4>)
  20680c:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  20680e:	f042 0204 	orr.w	r2, r2, #4
  206812:	641a      	str	r2, [r3, #64]	; 0x40
  206814:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  206816:	f003 0304 	and.w	r3, r3, #4
  20681a:	9303      	str	r3, [sp, #12]
  20681c:	9b03      	ldr	r3, [sp, #12]
  20681e:	e7d2      	b.n	2067c6 <HAL_TIM_PWM_MspInit+0x1e>
  else if(tim_pwmHandle->Instance==TIM9)
  206820:	4a11      	ldr	r2, [pc, #68]	; (206868 <HAL_TIM_PWM_MspInit+0xc0>)
  206822:	4293      	cmp	r3, r2
  206824:	d10a      	bne.n	20683c <HAL_TIM_PWM_MspInit+0x94>
    __HAL_RCC_TIM9_CLK_ENABLE();
  206826:	4b0d      	ldr	r3, [pc, #52]	; (20685c <HAL_TIM_PWM_MspInit+0xb4>)
  206828:	6c5a      	ldr	r2, [r3, #68]	; 0x44
  20682a:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
  20682e:	645a      	str	r2, [r3, #68]	; 0x44
  206830:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  206832:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
  206836:	9304      	str	r3, [sp, #16]
  206838:	9b04      	ldr	r3, [sp, #16]
  20683a:	e7c4      	b.n	2067c6 <HAL_TIM_PWM_MspInit+0x1e>
  else if(tim_pwmHandle->Instance==TIM12)
  20683c:	4a0b      	ldr	r2, [pc, #44]	; (20686c <HAL_TIM_PWM_MspInit+0xc4>)
  20683e:	4293      	cmp	r3, r2
  206840:	d1c1      	bne.n	2067c6 <HAL_TIM_PWM_MspInit+0x1e>
    __HAL_RCC_TIM12_CLK_ENABLE();
  206842:	4b06      	ldr	r3, [pc, #24]	; (20685c <HAL_TIM_PWM_MspInit+0xb4>)
  206844:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  206846:	f042 0240 	orr.w	r2, r2, #64	; 0x40
  20684a:	641a      	str	r2, [r3, #64]	; 0x40
  20684c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  20684e:	f003 0340 	and.w	r3, r3, #64	; 0x40
  206852:	9305      	str	r3, [sp, #20]
  206854:	9b05      	ldr	r3, [sp, #20]
}
  206856:	e7b6      	b.n	2067c6 <HAL_TIM_PWM_MspInit+0x1e>
  206858:	40010000 	.word	0x40010000
  20685c:	40023800 	.word	0x40023800
  206860:	40000400 	.word	0x40000400
  206864:	40000800 	.word	0x40000800
  206868:	40014000 	.word	0x40014000
  20686c:	40001800 	.word	0x40001800

00206870 <HAL_TIM_Encoder_MspInit>:

void HAL_TIM_Encoder_MspInit(TIM_HandleTypeDef* tim_encoderHandle)
{

  GPIO_InitTypeDef GPIO_InitStruct;
  if(tim_encoderHandle->Instance==TIM5)
  206870:	6803      	ldr	r3, [r0, #0]
  206872:	4a1b      	ldr	r2, [pc, #108]	; (2068e0 <HAL_TIM_Encoder_MspInit+0x70>)
  206874:	4293      	cmp	r3, r2
{
  206876:	b500      	push	{lr}
  206878:	b089      	sub	sp, #36	; 0x24
  if(tim_encoderHandle->Instance==TIM5)
  20687a:	d118      	bne.n	2068ae <HAL_TIM_Encoder_MspInit+0x3e>
  {
  /* USER CODE BEGIN TIM5_MspInit 0 */

  /* USER CODE END TIM5_MspInit 0 */
    /* TIM5 clock enable */
    __HAL_RCC_TIM5_CLK_ENABLE();
  20687c:	4b19      	ldr	r3, [pc, #100]	; (2068e4 <HAL_TIM_Encoder_MspInit+0x74>)
    GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM5;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
  20687e:	a903      	add	r1, sp, #12
  206880:	4819      	ldr	r0, [pc, #100]	; (2068e8 <HAL_TIM_Encoder_MspInit+0x78>)
    __HAL_RCC_TIM5_CLK_ENABLE();
  206882:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  206884:	f042 0208 	orr.w	r2, r2, #8
  206888:	641a      	str	r2, [r3, #64]	; 0x40
    GPIO_InitStruct.Pull = GPIO_NOPULL;
  20688a:	2200      	movs	r2, #0
    __HAL_RCC_TIM5_CLK_ENABLE();
  20688c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    GPIO_InitStruct.Pull = GPIO_NOPULL;
  20688e:	9205      	str	r2, [sp, #20]
    __HAL_RCC_TIM5_CLK_ENABLE();
  206890:	f003 0308 	and.w	r3, r3, #8
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  206894:	9206      	str	r2, [sp, #24]
    __HAL_RCC_TIM5_CLK_ENABLE();
  206896:	9301      	str	r3, [sp, #4]
  206898:	9b01      	ldr	r3, [sp, #4]
    GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1;
  20689a:	2303      	movs	r3, #3
  20689c:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  20689e:	2302      	movs	r3, #2
  2068a0:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM5;
  2068a2:	9307      	str	r3, [sp, #28]
    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM8;
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
  2068a4:	f7fa fb2c 	bl	200f00 <HAL_GPIO_Init>

  /* USER CODE BEGIN TIM8_MspInit 1 */

  /* USER CODE END TIM8_MspInit 1 */
  }
}
  2068a8:	b009      	add	sp, #36	; 0x24
  2068aa:	f85d fb04 	ldr.w	pc, [sp], #4
  else if(tim_encoderHandle->Instance==TIM8)
  2068ae:	4a0f      	ldr	r2, [pc, #60]	; (2068ec <HAL_TIM_Encoder_MspInit+0x7c>)
  2068b0:	4293      	cmp	r3, r2
  2068b2:	d1f9      	bne.n	2068a8 <HAL_TIM_Encoder_MspInit+0x38>
    __HAL_RCC_TIM8_CLK_ENABLE();
  2068b4:	4b0b      	ldr	r3, [pc, #44]	; (2068e4 <HAL_TIM_Encoder_MspInit+0x74>)
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
  2068b6:	a903      	add	r1, sp, #12
  2068b8:	480d      	ldr	r0, [pc, #52]	; (2068f0 <HAL_TIM_Encoder_MspInit+0x80>)
    __HAL_RCC_TIM8_CLK_ENABLE();
  2068ba:	6c5a      	ldr	r2, [r3, #68]	; 0x44
  2068bc:	f042 0202 	orr.w	r2, r2, #2
  2068c0:	645a      	str	r2, [r3, #68]	; 0x44
  2068c2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  2068c4:	f003 0302 	and.w	r3, r3, #2
  2068c8:	9302      	str	r3, [sp, #8]
  2068ca:	9b02      	ldr	r3, [sp, #8]
    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7;
  2068cc:	23c0      	movs	r3, #192	; 0xc0
  2068ce:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  2068d0:	2302      	movs	r3, #2
  2068d2:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
  2068d4:	2300      	movs	r3, #0
  2068d6:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  2068d8:	9306      	str	r3, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM8;
  2068da:	2303      	movs	r3, #3
  2068dc:	9307      	str	r3, [sp, #28]
  2068de:	e7e1      	b.n	2068a4 <HAL_TIM_Encoder_MspInit+0x34>
  2068e0:	40000c00 	.word	0x40000c00
  2068e4:	40023800 	.word	0x40023800
  2068e8:	40020000 	.word	0x40020000
  2068ec:	40010400 	.word	0x40010400
  2068f0:	40020800 	.word	0x40020800

002068f4 <HAL_TIM_Base_MspInit>:

void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* tim_baseHandle)
{
  2068f4:	b51f      	push	{r0, r1, r2, r3, r4, lr}

  if(tim_baseHandle->Instance==TIM6)
  2068f6:	6803      	ldr	r3, [r0, #0]
  2068f8:	4a19      	ldr	r2, [pc, #100]	; (206960 <HAL_TIM_Base_MspInit+0x6c>)
  2068fa:	4293      	cmp	r3, r2
  2068fc:	d114      	bne.n	206928 <HAL_TIM_Base_MspInit+0x34>
  {
  /* USER CODE BEGIN TIM6_MspInit 0 */

  /* USER CODE END TIM6_MspInit 0 */
    /* TIM6 clock enable */
    __HAL_RCC_TIM6_CLK_ENABLE();
  2068fe:	4b19      	ldr	r3, [pc, #100]	; (206964 <HAL_TIM_Base_MspInit+0x70>)

    /* TIM6 interrupt Init */
    HAL_NVIC_SetPriority(TIM6_DAC_IRQn, 4, 0);
  206900:	2036      	movs	r0, #54	; 0x36
  206902:	2104      	movs	r1, #4
    __HAL_RCC_TIM6_CLK_ENABLE();
  206904:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  206906:	f042 0210 	orr.w	r2, r2, #16
  20690a:	641a      	str	r2, [r3, #64]	; 0x40
    HAL_NVIC_SetPriority(TIM6_DAC_IRQn, 4, 0);
  20690c:	2200      	movs	r2, #0
    __HAL_RCC_TIM6_CLK_ENABLE();
  20690e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  206910:	f003 0310 	and.w	r3, r3, #16
  206914:	9301      	str	r3, [sp, #4]
  206916:	9b01      	ldr	r3, [sp, #4]
    HAL_NVIC_SetPriority(TIM6_DAC_IRQn, 4, 0);
  206918:	f7fa f8e4 	bl	200ae4 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(TIM6_DAC_IRQn);
  20691c:	2036      	movs	r0, #54	; 0x36
  20691e:	f7fa f919 	bl	200b54 <HAL_NVIC_EnableIRQ>
    __HAL_RCC_TIM11_CLK_ENABLE();
  /* USER CODE BEGIN TIM11_MspInit 1 */

  /* USER CODE END TIM11_MspInit 1 */
  }
}
  206922:	b005      	add	sp, #20
  206924:	f85d fb04 	ldr.w	pc, [sp], #4
  else if(tim_baseHandle->Instance==TIM10)
  206928:	4a0f      	ldr	r2, [pc, #60]	; (206968 <HAL_TIM_Base_MspInit+0x74>)
  20692a:	4293      	cmp	r3, r2
  20692c:	d10a      	bne.n	206944 <HAL_TIM_Base_MspInit+0x50>
    __HAL_RCC_TIM10_CLK_ENABLE();
  20692e:	4b0d      	ldr	r3, [pc, #52]	; (206964 <HAL_TIM_Base_MspInit+0x70>)
  206930:	6c5a      	ldr	r2, [r3, #68]	; 0x44
  206932:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
  206936:	645a      	str	r2, [r3, #68]	; 0x44
  206938:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  20693a:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
  20693e:	9302      	str	r3, [sp, #8]
  206940:	9b02      	ldr	r3, [sp, #8]
  206942:	e7ee      	b.n	206922 <HAL_TIM_Base_MspInit+0x2e>
  else if(tim_baseHandle->Instance==TIM11)
  206944:	4a09      	ldr	r2, [pc, #36]	; (20696c <HAL_TIM_Base_MspInit+0x78>)
  206946:	4293      	cmp	r3, r2
  206948:	d1eb      	bne.n	206922 <HAL_TIM_Base_MspInit+0x2e>
    __HAL_RCC_TIM11_CLK_ENABLE();
  20694a:	4b06      	ldr	r3, [pc, #24]	; (206964 <HAL_TIM_Base_MspInit+0x70>)
  20694c:	6c5a      	ldr	r2, [r3, #68]	; 0x44
  20694e:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
  206952:	645a      	str	r2, [r3, #68]	; 0x44
  206954:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  206956:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
  20695a:	9303      	str	r3, [sp, #12]
  20695c:	9b03      	ldr	r3, [sp, #12]
}
  20695e:	e7e0      	b.n	206922 <HAL_TIM_Base_MspInit+0x2e>
  206960:	40001000 	.word	0x40001000
  206964:	40023800 	.word	0x40023800
  206968:	40014400 	.word	0x40014400
  20696c:	40014800 	.word	0x40014800

00206970 <HAL_TIM_MspPostInit>:
void HAL_TIM_MspPostInit(TIM_HandleTypeDef* timHandle)
{

  GPIO_InitTypeDef GPIO_InitStruct;
  if(timHandle->Instance==TIM1)
  206970:	6803      	ldr	r3, [r0, #0]
  206972:	4a40      	ldr	r2, [pc, #256]	; (206a74 <HAL_TIM_MspPostInit+0x104>)
  206974:	4293      	cmp	r3, r2
{
  206976:	b570      	push	{r4, r5, r6, lr}
  206978:	b086      	sub	sp, #24
  if(timHandle->Instance==TIM1)
  20697a:	d10c      	bne.n	206996 <HAL_TIM_MspPostInit+0x26>
    PE9     ------> TIM1_CH1
    PE11     ------> TIM1_CH2
    PE13     ------> TIM1_CH3
    PE14     ------> TIM1_CH4 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_11|GPIO_PIN_13|GPIO_PIN_14;
  20697c:	f44f 43d4 	mov.w	r3, #27136	; 0x6a00
  206980:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  206982:	2302      	movs	r3, #2
  206984:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
  206986:	2300      	movs	r3, #0
  206988:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  20698a:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM1;
  20698c:	2301      	movs	r3, #1
    */
    GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_6;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM9;
  20698e:	9305      	str	r3, [sp, #20]
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
  206990:	a901      	add	r1, sp, #4
  206992:	4839      	ldr	r0, [pc, #228]	; (206a78 <HAL_TIM_MspPostInit+0x108>)
  206994:	e03c      	b.n	206a10 <HAL_TIM_MspPostInit+0xa0>
  else if(timHandle->Instance==TIM2)
  206996:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
  20699a:	d115      	bne.n	2069c8 <HAL_TIM_MspPostInit+0x58>
    GPIO_InitStruct.Pull = GPIO_NOPULL;
  20699c:	2400      	movs	r4, #0
    GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_5;
  20699e:	232c      	movs	r3, #44	; 0x2c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  2069a0:	2602      	movs	r6, #2
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
  2069a2:	2501      	movs	r5, #1
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
  2069a4:	a901      	add	r1, sp, #4
  2069a6:	4835      	ldr	r0, [pc, #212]	; (206a7c <HAL_TIM_MspPostInit+0x10c>)
    GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_5;
  2069a8:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  2069aa:	9602      	str	r6, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
  2069ac:	9403      	str	r4, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  2069ae:	9404      	str	r4, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
  2069b0:	9505      	str	r5, [sp, #20]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
  2069b2:	f7fa faa5 	bl	200f00 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_3;
  2069b6:	2308      	movs	r3, #8
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  2069b8:	9602      	str	r6, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
  2069ba:	9403      	str	r4, [sp, #12]
    GPIO_InitStruct.Pin = GPIO_PIN_3;
  2069bc:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  2069be:	9404      	str	r4, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
  2069c0:	9505      	str	r5, [sp, #20]
    GPIO_InitStruct.Pin = GPIO_PIN_14|GPIO_PIN_15;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF9_TIM12;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
  2069c2:	a901      	add	r1, sp, #4
  2069c4:	482e      	ldr	r0, [pc, #184]	; (206a80 <HAL_TIM_MspPostInit+0x110>)
  2069c6:	e023      	b.n	206a10 <HAL_TIM_MspPostInit+0xa0>
  else if(timHandle->Instance==TIM3)
  2069c8:	4a2e      	ldr	r2, [pc, #184]	; (206a84 <HAL_TIM_MspPostInit+0x114>)
  2069ca:	4293      	cmp	r3, r2
  2069cc:	d112      	bne.n	2069f4 <HAL_TIM_MspPostInit+0x84>
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  2069ce:	2402      	movs	r4, #2
    GPIO_InitStruct.Pull = GPIO_NOPULL;
  2069d0:	2500      	movs	r5, #0
    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7;
  2069d2:	23c0      	movs	r3, #192	; 0xc0
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
  2069d4:	a901      	add	r1, sp, #4
  2069d6:	4829      	ldr	r0, [pc, #164]	; (206a7c <HAL_TIM_MspPostInit+0x10c>)
    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7;
  2069d8:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  2069da:	9402      	str	r4, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
  2069dc:	9503      	str	r5, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  2069de:	9504      	str	r5, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM3;
  2069e0:	9405      	str	r4, [sp, #20]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
  2069e2:	f7fa fa8d 	bl	200f00 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1;
  2069e6:	2303      	movs	r3, #3
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  2069e8:	9402      	str	r4, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
  2069ea:	9503      	str	r5, [sp, #12]
    GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1;
  2069ec:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  2069ee:	9504      	str	r5, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM3;
  2069f0:	9405      	str	r4, [sp, #20]
  2069f2:	e7e6      	b.n	2069c2 <HAL_TIM_MspPostInit+0x52>
  else if(timHandle->Instance==TIM4)
  2069f4:	4a24      	ldr	r2, [pc, #144]	; (206a88 <HAL_TIM_MspPostInit+0x118>)
  2069f6:	4293      	cmp	r3, r2
  2069f8:	d10e      	bne.n	206a18 <HAL_TIM_MspPostInit+0xa8>
    GPIO_InitStruct.Pin = GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15;
  2069fa:	f44f 4370 	mov.w	r3, #61440	; 0xf000
    GPIO_InitStruct.Pull = GPIO_NOPULL;
  2069fe:	2200      	movs	r2, #0
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
  206a00:	a901      	add	r1, sp, #4
  206a02:	4822      	ldr	r0, [pc, #136]	; (206a8c <HAL_TIM_MspPostInit+0x11c>)
    GPIO_InitStruct.Pin = GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15;
  206a04:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  206a06:	2302      	movs	r3, #2
    GPIO_InitStruct.Pull = GPIO_NOPULL;
  206a08:	9203      	str	r2, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  206a0a:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  206a0c:	9204      	str	r2, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM4;
  206a0e:	9305      	str	r3, [sp, #20]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
  206a10:	f7fa fa76 	bl	200f00 <HAL_GPIO_Init>
  /* USER CODE BEGIN TIM12_MspPostInit 1 */

  /* USER CODE END TIM12_MspPostInit 1 */
  }

}
  206a14:	b006      	add	sp, #24
  206a16:	bd70      	pop	{r4, r5, r6, pc}
  else if(timHandle->Instance==TIM9)
  206a18:	4a1d      	ldr	r2, [pc, #116]	; (206a90 <HAL_TIM_MspPostInit+0x120>)
  206a1a:	4293      	cmp	r3, r2
  206a1c:	d108      	bne.n	206a30 <HAL_TIM_MspPostInit+0xc0>
    GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_6;
  206a1e:	2360      	movs	r3, #96	; 0x60
  206a20:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  206a22:	2302      	movs	r3, #2
  206a24:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
  206a26:	2300      	movs	r3, #0
  206a28:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  206a2a:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM9;
  206a2c:	2303      	movs	r3, #3
  206a2e:	e7ae      	b.n	20698e <HAL_TIM_MspPostInit+0x1e>
  else if(timHandle->Instance==TIM10)
  206a30:	4a18      	ldr	r2, [pc, #96]	; (206a94 <HAL_TIM_MspPostInit+0x124>)
  206a32:	4293      	cmp	r3, r2
  206a34:	d10a      	bne.n	206a4c <HAL_TIM_MspPostInit+0xdc>
    GPIO_InitStruct.Pin = GPIO_PIN_8;
  206a36:	f44f 7380 	mov.w	r3, #256	; 0x100
    GPIO_InitStruct.Pin = GPIO_PIN_9;
  206a3a:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  206a3c:	2302      	movs	r3, #2
  206a3e:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
  206a40:	2300      	movs	r3, #0
  206a42:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  206a44:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM11;
  206a46:	2303      	movs	r3, #3
    GPIO_InitStruct.Alternate = GPIO_AF9_TIM12;
  206a48:	9305      	str	r3, [sp, #20]
  206a4a:	e7ba      	b.n	2069c2 <HAL_TIM_MspPostInit+0x52>
  else if(timHandle->Instance==TIM11)
  206a4c:	4a12      	ldr	r2, [pc, #72]	; (206a98 <HAL_TIM_MspPostInit+0x128>)
  206a4e:	4293      	cmp	r3, r2
  206a50:	d102      	bne.n	206a58 <HAL_TIM_MspPostInit+0xe8>
    GPIO_InitStruct.Pin = GPIO_PIN_9;
  206a52:	f44f 7300 	mov.w	r3, #512	; 0x200
  206a56:	e7f0      	b.n	206a3a <HAL_TIM_MspPostInit+0xca>
  else if(timHandle->Instance==TIM12)
  206a58:	4a10      	ldr	r2, [pc, #64]	; (206a9c <HAL_TIM_MspPostInit+0x12c>)
  206a5a:	4293      	cmp	r3, r2
  206a5c:	d1da      	bne.n	206a14 <HAL_TIM_MspPostInit+0xa4>
    GPIO_InitStruct.Pin = GPIO_PIN_14|GPIO_PIN_15;
  206a5e:	f44f 4340 	mov.w	r3, #49152	; 0xc000
  206a62:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  206a64:	2302      	movs	r3, #2
  206a66:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
  206a68:	2300      	movs	r3, #0
  206a6a:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  206a6c:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF9_TIM12;
  206a6e:	2309      	movs	r3, #9
  206a70:	e7ea      	b.n	206a48 <HAL_TIM_MspPostInit+0xd8>
  206a72:	bf00      	nop
  206a74:	40010000 	.word	0x40010000
  206a78:	40021000 	.word	0x40021000
  206a7c:	40020000 	.word	0x40020000
  206a80:	40020400 	.word	0x40020400
  206a84:	40000400 	.word	0x40000400
  206a88:	40000800 	.word	0x40000800
  206a8c:	40020c00 	.word	0x40020c00
  206a90:	40014000 	.word	0x40014000
  206a94:	40014400 	.word	0x40014400
  206a98:	40014800 	.word	0x40014800
  206a9c:	40001800 	.word	0x40001800

00206aa0 <MX_TIM1_Init>:
{
  206aa0:	b508      	push	{r3, lr}
  htim1.Instance = TIM1;
  206aa2:	4837      	ldr	r0, [pc, #220]	; (206b80 <MX_TIM1_Init+0xe0>)
  htim1.Init.Prescaler = 18;
  206aa4:	2312      	movs	r3, #18
  206aa6:	4937      	ldr	r1, [pc, #220]	; (206b84 <MX_TIM1_Init+0xe4>)
  htim1.Init.Period = 999;
  206aa8:	f240 32e7 	movw	r2, #999	; 0x3e7
  htim1.Init.Prescaler = 18;
  206aac:	e880 000a 	stmia.w	r0, {r1, r3}
  htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
  206ab0:	2300      	movs	r3, #0
  htim1.Init.Period = 999;
  206ab2:	60c2      	str	r2, [r0, #12]
  htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
  206ab4:	6083      	str	r3, [r0, #8]
  htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  206ab6:	6103      	str	r3, [r0, #16]
  htim1.Init.RepetitionCounter = 0;
  206ab8:	6143      	str	r3, [r0, #20]
  htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  206aba:	6183      	str	r3, [r0, #24]
  if (HAL_TIM_PWM_Init(&htim1) != HAL_OK)
  206abc:	f7fb fce4 	bl	202488 <HAL_TIM_PWM_Init>
  206ac0:	b118      	cbz	r0, 206aca <MX_TIM1_Init+0x2a>
    _Error_Handler(__FILE__, __LINE__);
  206ac2:	214e      	movs	r1, #78	; 0x4e
  206ac4:	4830      	ldr	r0, [pc, #192]	; (206b88 <MX_TIM1_Init+0xe8>)
  206ac6:	f7fe fa1f 	bl	204f08 <_Error_Handler>
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  206aca:	4930      	ldr	r1, [pc, #192]	; (206b8c <MX_TIM1_Init+0xec>)
  206acc:	2300      	movs	r3, #0
  if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK)
  206ace:	482c      	ldr	r0, [pc, #176]	; (206b80 <MX_TIM1_Init+0xe0>)
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  206ad0:	600b      	str	r3, [r1, #0]
  sMasterConfig.MasterOutputTrigger2 = TIM_TRGO2_RESET;
  206ad2:	604b      	str	r3, [r1, #4]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  206ad4:	608b      	str	r3, [r1, #8]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK)
  206ad6:	f7fb fe6f 	bl	2027b8 <HAL_TIMEx_MasterConfigSynchronization>
  206ada:	b118      	cbz	r0, 206ae4 <MX_TIM1_Init+0x44>
    _Error_Handler(__FILE__, __LINE__);
  206adc:	2156      	movs	r1, #86	; 0x56
  206ade:	482a      	ldr	r0, [pc, #168]	; (206b88 <MX_TIM1_Init+0xe8>)
  206ae0:	f7fe fa12 	bl	204f08 <_Error_Handler>
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  206ae4:	492a      	ldr	r1, [pc, #168]	; (206b90 <MX_TIM1_Init+0xf0>)
  sConfigOC.Pulse = 0;
  206ae6:	2200      	movs	r2, #0
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  206ae8:	2360      	movs	r3, #96	; 0x60
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
  206aea:	4825      	ldr	r0, [pc, #148]	; (206b80 <MX_TIM1_Init+0xe0>)
  sConfigOC.Pulse = 0;
  206aec:	604a      	str	r2, [r1, #4]
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  206aee:	600b      	str	r3, [r1, #0]
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  206af0:	608a      	str	r2, [r1, #8]
  sConfigOC.OCNPolarity = TIM_OCNPOLARITY_HIGH;
  206af2:	60ca      	str	r2, [r1, #12]
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
  206af4:	610a      	str	r2, [r1, #16]
  sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET;
  206af6:	614a      	str	r2, [r1, #20]
  sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;
  206af8:	618a      	str	r2, [r1, #24]
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
  206afa:	f7fb fec9 	bl	202890 <HAL_TIM_PWM_ConfigChannel>
  206afe:	b118      	cbz	r0, 206b08 <MX_TIM1_Init+0x68>
    _Error_Handler(__FILE__, __LINE__);
  206b00:	2162      	movs	r1, #98	; 0x62
  206b02:	4821      	ldr	r0, [pc, #132]	; (206b88 <MX_TIM1_Init+0xe8>)
  206b04:	f7fe fa00 	bl	204f08 <_Error_Handler>
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
  206b08:	2204      	movs	r2, #4
  206b0a:	4921      	ldr	r1, [pc, #132]	; (206b90 <MX_TIM1_Init+0xf0>)
  206b0c:	481c      	ldr	r0, [pc, #112]	; (206b80 <MX_TIM1_Init+0xe0>)
  206b0e:	f7fb febf 	bl	202890 <HAL_TIM_PWM_ConfigChannel>
  206b12:	b118      	cbz	r0, 206b1c <MX_TIM1_Init+0x7c>
    _Error_Handler(__FILE__, __LINE__);
  206b14:	2167      	movs	r1, #103	; 0x67
  206b16:	481c      	ldr	r0, [pc, #112]	; (206b88 <MX_TIM1_Init+0xe8>)
  206b18:	f7fe f9f6 	bl	204f08 <_Error_Handler>
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_3) != HAL_OK)
  206b1c:	2208      	movs	r2, #8
  206b1e:	491c      	ldr	r1, [pc, #112]	; (206b90 <MX_TIM1_Init+0xf0>)
  206b20:	4817      	ldr	r0, [pc, #92]	; (206b80 <MX_TIM1_Init+0xe0>)
  206b22:	f7fb feb5 	bl	202890 <HAL_TIM_PWM_ConfigChannel>
  206b26:	b118      	cbz	r0, 206b30 <MX_TIM1_Init+0x90>
    _Error_Handler(__FILE__, __LINE__);
  206b28:	216c      	movs	r1, #108	; 0x6c
  206b2a:	4817      	ldr	r0, [pc, #92]	; (206b88 <MX_TIM1_Init+0xe8>)
  206b2c:	f7fe f9ec 	bl	204f08 <_Error_Handler>
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_4) != HAL_OK)
  206b30:	220c      	movs	r2, #12
  206b32:	4917      	ldr	r1, [pc, #92]	; (206b90 <MX_TIM1_Init+0xf0>)
  206b34:	4812      	ldr	r0, [pc, #72]	; (206b80 <MX_TIM1_Init+0xe0>)
  206b36:	f7fb feab 	bl	202890 <HAL_TIM_PWM_ConfigChannel>
  206b3a:	b118      	cbz	r0, 206b44 <MX_TIM1_Init+0xa4>
    _Error_Handler(__FILE__, __LINE__);
  206b3c:	2171      	movs	r1, #113	; 0x71
  206b3e:	4812      	ldr	r0, [pc, #72]	; (206b88 <MX_TIM1_Init+0xe8>)
  206b40:	f7fe f9e2 	bl	204f08 <_Error_Handler>
  sBreakDeadTimeConfig.OffStateRunMode = TIM_OSSR_DISABLE;
  206b44:	4913      	ldr	r1, [pc, #76]	; (206b94 <MX_TIM1_Init+0xf4>)
  sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;
  206b46:	f44f 5200 	mov.w	r2, #8192	; 0x2000
  sBreakDeadTimeConfig.OffStateRunMode = TIM_OSSR_DISABLE;
  206b4a:	2300      	movs	r3, #0
  if (HAL_TIMEx_ConfigBreakDeadTime(&htim1, &sBreakDeadTimeConfig) != HAL_OK)
  206b4c:	480c      	ldr	r0, [pc, #48]	; (206b80 <MX_TIM1_Init+0xe0>)
  sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;
  206b4e:	614a      	str	r2, [r1, #20]
  sBreakDeadTimeConfig.Break2Polarity = TIM_BREAK2POLARITY_HIGH;
  206b50:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
  sBreakDeadTimeConfig.OffStateRunMode = TIM_OSSR_DISABLE;
  206b54:	600b      	str	r3, [r1, #0]
  sBreakDeadTimeConfig.OffStateIDLEMode = TIM_OSSI_DISABLE;
  206b56:	604b      	str	r3, [r1, #4]
  sBreakDeadTimeConfig.LockLevel = TIM_LOCKLEVEL_OFF;
  206b58:	608b      	str	r3, [r1, #8]
  sBreakDeadTimeConfig.DeadTime = 0;
  206b5a:	60cb      	str	r3, [r1, #12]
  sBreakDeadTimeConfig.BreakState = TIM_BREAK_DISABLE;
  206b5c:	610b      	str	r3, [r1, #16]
  sBreakDeadTimeConfig.BreakFilter = 0;
  206b5e:	618b      	str	r3, [r1, #24]
  sBreakDeadTimeConfig.Break2State = TIM_BREAK2_DISABLE;
  206b60:	61cb      	str	r3, [r1, #28]
  sBreakDeadTimeConfig.Break2Polarity = TIM_BREAK2POLARITY_HIGH;
  206b62:	620a      	str	r2, [r1, #32]
  sBreakDeadTimeConfig.Break2Filter = 0;
  206b64:	624b      	str	r3, [r1, #36]	; 0x24
  sBreakDeadTimeConfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_DISABLE;
  206b66:	628b      	str	r3, [r1, #40]	; 0x28
  if (HAL_TIMEx_ConfigBreakDeadTime(&htim1, &sBreakDeadTimeConfig) != HAL_OK)
  206b68:	f7fb fe4c 	bl	202804 <HAL_TIMEx_ConfigBreakDeadTime>
  206b6c:	b118      	cbz	r0, 206b76 <MX_TIM1_Init+0xd6>
    _Error_Handler(__FILE__, __LINE__);
  206b6e:	2181      	movs	r1, #129	; 0x81
  206b70:	4805      	ldr	r0, [pc, #20]	; (206b88 <MX_TIM1_Init+0xe8>)
  206b72:	f7fe f9c9 	bl	204f08 <_Error_Handler>
  HAL_TIM_MspPostInit(&htim1);
  206b76:	4802      	ldr	r0, [pc, #8]	; (206b80 <MX_TIM1_Init+0xe0>)
}
  206b78:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_TIM_MspPostInit(&htim1);
  206b7c:	f7ff bef8 	b.w	206970 <HAL_TIM_MspPostInit>
  206b80:	200003d8 	.word	0x200003d8
  206b84:	40010000 	.word	0x40010000
  206b88:	0020788c 	.word	0x0020788c
  206b8c:	20000054 	.word	0x20000054
  206b90:	20000060 	.word	0x20000060
  206b94:	2000007c 	.word	0x2000007c

00206b98 <MX_TIM2_Init>:
{
  206b98:	b508      	push	{r3, lr}
  htim2.Instance = TIM2;
  206b9a:	4829      	ldr	r0, [pc, #164]	; (206c40 <MX_TIM2_Init+0xa8>)
  htim2.Init.Prescaler = 9;
  206b9c:	2309      	movs	r3, #9
  206b9e:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
  htim2.Init.Period = 999;
  206ba2:	f240 32e7 	movw	r2, #999	; 0x3e7
  htim2.Init.Prescaler = 9;
  206ba6:	e880 000a 	stmia.w	r0, {r1, r3}
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
  206baa:	2300      	movs	r3, #0
  htim2.Init.Period = 999;
  206bac:	60c2      	str	r2, [r0, #12]
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
  206bae:	6083      	str	r3, [r0, #8]
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  206bb0:	6103      	str	r3, [r0, #16]
  htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  206bb2:	6183      	str	r3, [r0, #24]
  if (HAL_TIM_PWM_Init(&htim2) != HAL_OK)
  206bb4:	f7fb fc68 	bl	202488 <HAL_TIM_PWM_Init>
  206bb8:	b118      	cbz	r0, 206bc2 <MX_TIM2_Init+0x2a>
    _Error_Handler(__FILE__, __LINE__);
  206bba:	2193      	movs	r1, #147	; 0x93
  206bbc:	4821      	ldr	r0, [pc, #132]	; (206c44 <MX_TIM2_Init+0xac>)
  206bbe:	f7fe f9a3 	bl	204f08 <_Error_Handler>
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  206bc2:	4921      	ldr	r1, [pc, #132]	; (206c48 <MX_TIM2_Init+0xb0>)
  206bc4:	2300      	movs	r3, #0
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
  206bc6:	481e      	ldr	r0, [pc, #120]	; (206c40 <MX_TIM2_Init+0xa8>)
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  206bc8:	600b      	str	r3, [r1, #0]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  206bca:	608b      	str	r3, [r1, #8]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
  206bcc:	f7fb fdf4 	bl	2027b8 <HAL_TIMEx_MasterConfigSynchronization>
  206bd0:	b118      	cbz	r0, 206bda <MX_TIM2_Init+0x42>
    _Error_Handler(__FILE__, __LINE__);
  206bd2:	219a      	movs	r1, #154	; 0x9a
  206bd4:	481b      	ldr	r0, [pc, #108]	; (206c44 <MX_TIM2_Init+0xac>)
  206bd6:	f7fe f997 	bl	204f08 <_Error_Handler>
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  206bda:	491c      	ldr	r1, [pc, #112]	; (206c4c <MX_TIM2_Init+0xb4>)
  sConfigOC.Pulse = 0;
  206bdc:	2200      	movs	r2, #0
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  206bde:	2360      	movs	r3, #96	; 0x60
  if (HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
  206be0:	4817      	ldr	r0, [pc, #92]	; (206c40 <MX_TIM2_Init+0xa8>)
  sConfigOC.Pulse = 0;
  206be2:	604a      	str	r2, [r1, #4]
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  206be4:	600b      	str	r3, [r1, #0]
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  206be6:	608a      	str	r2, [r1, #8]
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
  206be8:	610a      	str	r2, [r1, #16]
  if (HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
  206bea:	f7fb fe51 	bl	202890 <HAL_TIM_PWM_ConfigChannel>
  206bee:	b118      	cbz	r0, 206bf8 <MX_TIM2_Init+0x60>
    _Error_Handler(__FILE__, __LINE__);
  206bf0:	21a3      	movs	r1, #163	; 0xa3
  206bf2:	4814      	ldr	r0, [pc, #80]	; (206c44 <MX_TIM2_Init+0xac>)
  206bf4:	f7fe f988 	bl	204f08 <_Error_Handler>
  if (HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
  206bf8:	2204      	movs	r2, #4
  206bfa:	4914      	ldr	r1, [pc, #80]	; (206c4c <MX_TIM2_Init+0xb4>)
  206bfc:	4810      	ldr	r0, [pc, #64]	; (206c40 <MX_TIM2_Init+0xa8>)
  206bfe:	f7fb fe47 	bl	202890 <HAL_TIM_PWM_ConfigChannel>
  206c02:	b118      	cbz	r0, 206c0c <MX_TIM2_Init+0x74>
    _Error_Handler(__FILE__, __LINE__);
  206c04:	21a8      	movs	r1, #168	; 0xa8
  206c06:	480f      	ldr	r0, [pc, #60]	; (206c44 <MX_TIM2_Init+0xac>)
  206c08:	f7fe f97e 	bl	204f08 <_Error_Handler>
  if (HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_3) != HAL_OK)
  206c0c:	2208      	movs	r2, #8
  206c0e:	490f      	ldr	r1, [pc, #60]	; (206c4c <MX_TIM2_Init+0xb4>)
  206c10:	480b      	ldr	r0, [pc, #44]	; (206c40 <MX_TIM2_Init+0xa8>)
  206c12:	f7fb fe3d 	bl	202890 <HAL_TIM_PWM_ConfigChannel>
  206c16:	b118      	cbz	r0, 206c20 <MX_TIM2_Init+0x88>
    _Error_Handler(__FILE__, __LINE__);
  206c18:	21ad      	movs	r1, #173	; 0xad
  206c1a:	480a      	ldr	r0, [pc, #40]	; (206c44 <MX_TIM2_Init+0xac>)
  206c1c:	f7fe f974 	bl	204f08 <_Error_Handler>
  if (HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_4) != HAL_OK)
  206c20:	220c      	movs	r2, #12
  206c22:	490a      	ldr	r1, [pc, #40]	; (206c4c <MX_TIM2_Init+0xb4>)
  206c24:	4806      	ldr	r0, [pc, #24]	; (206c40 <MX_TIM2_Init+0xa8>)
  206c26:	f7fb fe33 	bl	202890 <HAL_TIM_PWM_ConfigChannel>
  206c2a:	b118      	cbz	r0, 206c34 <MX_TIM2_Init+0x9c>
    _Error_Handler(__FILE__, __LINE__);
  206c2c:	21b2      	movs	r1, #178	; 0xb2
  206c2e:	4805      	ldr	r0, [pc, #20]	; (206c44 <MX_TIM2_Init+0xac>)
  206c30:	f7fe f96a 	bl	204f08 <_Error_Handler>
  HAL_TIM_MspPostInit(&htim2);
  206c34:	4802      	ldr	r0, [pc, #8]	; (206c40 <MX_TIM2_Init+0xa8>)
}
  206c36:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_TIM_MspPostInit(&htim2);
  206c3a:	f7ff be99 	b.w	206970 <HAL_TIM_MspPostInit>
  206c3e:	bf00      	nop
  206c40:	20000458 	.word	0x20000458
  206c44:	0020788c 	.word	0x0020788c
  206c48:	20000054 	.word	0x20000054
  206c4c:	20000060 	.word	0x20000060

00206c50 <MX_TIM3_Init>:
{
  206c50:	b508      	push	{r3, lr}
  htim3.Instance = TIM3;
  206c52:	4828      	ldr	r0, [pc, #160]	; (206cf4 <MX_TIM3_Init+0xa4>)
  htim3.Init.Prescaler = 216;
  206c54:	23d8      	movs	r3, #216	; 0xd8
  206c56:	4928      	ldr	r1, [pc, #160]	; (206cf8 <MX_TIM3_Init+0xa8>)
  htim3.Init.Period = 9999;
  206c58:	f242 720f 	movw	r2, #9999	; 0x270f
  htim3.Init.Prescaler = 216;
  206c5c:	e880 000a 	stmia.w	r0, {r1, r3}
  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
  206c60:	2300      	movs	r3, #0
  htim3.Init.Period = 9999;
  206c62:	60c2      	str	r2, [r0, #12]
  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
  206c64:	6083      	str	r3, [r0, #8]
  htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  206c66:	6103      	str	r3, [r0, #16]
  htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  206c68:	6183      	str	r3, [r0, #24]
  if (HAL_TIM_PWM_Init(&htim3) != HAL_OK)
  206c6a:	f7fb fc0d 	bl	202488 <HAL_TIM_PWM_Init>
  206c6e:	b118      	cbz	r0, 206c78 <MX_TIM3_Init+0x28>
    _Error_Handler(__FILE__, __LINE__);
  206c70:	21c3      	movs	r1, #195	; 0xc3
  206c72:	4822      	ldr	r0, [pc, #136]	; (206cfc <MX_TIM3_Init+0xac>)
  206c74:	f7fe f948 	bl	204f08 <_Error_Handler>
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  206c78:	4921      	ldr	r1, [pc, #132]	; (206d00 <MX_TIM3_Init+0xb0>)
  206c7a:	2300      	movs	r3, #0
  if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
  206c7c:	481d      	ldr	r0, [pc, #116]	; (206cf4 <MX_TIM3_Init+0xa4>)
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  206c7e:	600b      	str	r3, [r1, #0]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  206c80:	608b      	str	r3, [r1, #8]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
  206c82:	f7fb fd99 	bl	2027b8 <HAL_TIMEx_MasterConfigSynchronization>
  206c86:	b118      	cbz	r0, 206c90 <MX_TIM3_Init+0x40>
    _Error_Handler(__FILE__, __LINE__);
  206c88:	21ca      	movs	r1, #202	; 0xca
  206c8a:	481c      	ldr	r0, [pc, #112]	; (206cfc <MX_TIM3_Init+0xac>)
  206c8c:	f7fe f93c 	bl	204f08 <_Error_Handler>
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  206c90:	491c      	ldr	r1, [pc, #112]	; (206d04 <MX_TIM3_Init+0xb4>)
  sConfigOC.Pulse = 0;
  206c92:	2200      	movs	r2, #0
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  206c94:	2360      	movs	r3, #96	; 0x60
  if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
  206c96:	4817      	ldr	r0, [pc, #92]	; (206cf4 <MX_TIM3_Init+0xa4>)
  sConfigOC.Pulse = 0;
  206c98:	604a      	str	r2, [r1, #4]
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  206c9a:	600b      	str	r3, [r1, #0]
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  206c9c:	608a      	str	r2, [r1, #8]
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
  206c9e:	610a      	str	r2, [r1, #16]
  if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
  206ca0:	f7fb fdf6 	bl	202890 <HAL_TIM_PWM_ConfigChannel>
  206ca4:	b118      	cbz	r0, 206cae <MX_TIM3_Init+0x5e>
    _Error_Handler(__FILE__, __LINE__);
  206ca6:	21d3      	movs	r1, #211	; 0xd3
  206ca8:	4814      	ldr	r0, [pc, #80]	; (206cfc <MX_TIM3_Init+0xac>)
  206caa:	f7fe f92d 	bl	204f08 <_Error_Handler>
  if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
  206cae:	2204      	movs	r2, #4
  206cb0:	4914      	ldr	r1, [pc, #80]	; (206d04 <MX_TIM3_Init+0xb4>)
  206cb2:	4810      	ldr	r0, [pc, #64]	; (206cf4 <MX_TIM3_Init+0xa4>)
  206cb4:	f7fb fdec 	bl	202890 <HAL_TIM_PWM_ConfigChannel>
  206cb8:	b118      	cbz	r0, 206cc2 <MX_TIM3_Init+0x72>
    _Error_Handler(__FILE__, __LINE__);
  206cba:	21d8      	movs	r1, #216	; 0xd8
  206cbc:	480f      	ldr	r0, [pc, #60]	; (206cfc <MX_TIM3_Init+0xac>)
  206cbe:	f7fe f923 	bl	204f08 <_Error_Handler>
  if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_3) != HAL_OK)
  206cc2:	2208      	movs	r2, #8
  206cc4:	490f      	ldr	r1, [pc, #60]	; (206d04 <MX_TIM3_Init+0xb4>)
  206cc6:	480b      	ldr	r0, [pc, #44]	; (206cf4 <MX_TIM3_Init+0xa4>)
  206cc8:	f7fb fde2 	bl	202890 <HAL_TIM_PWM_ConfigChannel>
  206ccc:	b118      	cbz	r0, 206cd6 <MX_TIM3_Init+0x86>
    _Error_Handler(__FILE__, __LINE__);
  206cce:	21dd      	movs	r1, #221	; 0xdd
  206cd0:	480a      	ldr	r0, [pc, #40]	; (206cfc <MX_TIM3_Init+0xac>)
  206cd2:	f7fe f919 	bl	204f08 <_Error_Handler>
  if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_4) != HAL_OK)
  206cd6:	220c      	movs	r2, #12
  206cd8:	490a      	ldr	r1, [pc, #40]	; (206d04 <MX_TIM3_Init+0xb4>)
  206cda:	4806      	ldr	r0, [pc, #24]	; (206cf4 <MX_TIM3_Init+0xa4>)
  206cdc:	f7fb fdd8 	bl	202890 <HAL_TIM_PWM_ConfigChannel>
  206ce0:	b118      	cbz	r0, 206cea <MX_TIM3_Init+0x9a>
    _Error_Handler(__FILE__, __LINE__);
  206ce2:	21e2      	movs	r1, #226	; 0xe2
  206ce4:	4805      	ldr	r0, [pc, #20]	; (206cfc <MX_TIM3_Init+0xac>)
  206ce6:	f7fe f90f 	bl	204f08 <_Error_Handler>
  HAL_TIM_MspPostInit(&htim3);
  206cea:	4802      	ldr	r0, [pc, #8]	; (206cf4 <MX_TIM3_Init+0xa4>)
}
  206cec:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_TIM_MspPostInit(&htim3);
  206cf0:	f7ff be3e 	b.w	206970 <HAL_TIM_MspPostInit>
  206cf4:	20000318 	.word	0x20000318
  206cf8:	40000400 	.word	0x40000400
  206cfc:	0020788c 	.word	0x0020788c
  206d00:	20000054 	.word	0x20000054
  206d04:	20000060 	.word	0x20000060

00206d08 <MX_TIM4_Init>:
{
  206d08:	b508      	push	{r3, lr}
  htim4.Instance = TIM4;
  206d0a:	482a      	ldr	r0, [pc, #168]	; (206db4 <MX_TIM4_Init+0xac>)
  htim4.Init.Prescaler = 216;
  206d0c:	23d8      	movs	r3, #216	; 0xd8
  206d0e:	492a      	ldr	r1, [pc, #168]	; (206db8 <MX_TIM4_Init+0xb0>)
  htim4.Init.Period = 9999;
  206d10:	f242 720f 	movw	r2, #9999	; 0x270f
  htim4.Init.Prescaler = 216;
  206d14:	e880 000a 	stmia.w	r0, {r1, r3}
  htim4.Init.CounterMode = TIM_COUNTERMODE_UP;
  206d18:	2300      	movs	r3, #0
  htim4.Init.Period = 9999;
  206d1a:	60c2      	str	r2, [r0, #12]
  htim4.Init.CounterMode = TIM_COUNTERMODE_UP;
  206d1c:	6083      	str	r3, [r0, #8]
  htim4.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  206d1e:	6103      	str	r3, [r0, #16]
  htim4.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  206d20:	6183      	str	r3, [r0, #24]
  if (HAL_TIM_PWM_Init(&htim4) != HAL_OK)
  206d22:	f7fb fbb1 	bl	202488 <HAL_TIM_PWM_Init>
  206d26:	b118      	cbz	r0, 206d30 <MX_TIM4_Init+0x28>
    _Error_Handler(__FILE__, __LINE__);
  206d28:	21f3      	movs	r1, #243	; 0xf3
  206d2a:	4824      	ldr	r0, [pc, #144]	; (206dbc <MX_TIM4_Init+0xb4>)
  206d2c:	f7fe f8ec 	bl	204f08 <_Error_Handler>
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  206d30:	4923      	ldr	r1, [pc, #140]	; (206dc0 <MX_TIM4_Init+0xb8>)
  206d32:	2300      	movs	r3, #0
  if (HAL_TIMEx_MasterConfigSynchronization(&htim4, &sMasterConfig) != HAL_OK)
  206d34:	481f      	ldr	r0, [pc, #124]	; (206db4 <MX_TIM4_Init+0xac>)
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  206d36:	600b      	str	r3, [r1, #0]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  206d38:	608b      	str	r3, [r1, #8]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim4, &sMasterConfig) != HAL_OK)
  206d3a:	f7fb fd3d 	bl	2027b8 <HAL_TIMEx_MasterConfigSynchronization>
  206d3e:	b118      	cbz	r0, 206d48 <MX_TIM4_Init+0x40>
    _Error_Handler(__FILE__, __LINE__);
  206d40:	21fa      	movs	r1, #250	; 0xfa
  206d42:	481e      	ldr	r0, [pc, #120]	; (206dbc <MX_TIM4_Init+0xb4>)
  206d44:	f7fe f8e0 	bl	204f08 <_Error_Handler>
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  206d48:	491e      	ldr	r1, [pc, #120]	; (206dc4 <MX_TIM4_Init+0xbc>)
  sConfigOC.Pulse = 0;
  206d4a:	2200      	movs	r2, #0
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  206d4c:	2360      	movs	r3, #96	; 0x60
  if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
  206d4e:	4819      	ldr	r0, [pc, #100]	; (206db4 <MX_TIM4_Init+0xac>)
  sConfigOC.Pulse = 0;
  206d50:	604a      	str	r2, [r1, #4]
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  206d52:	600b      	str	r3, [r1, #0]
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  206d54:	608a      	str	r2, [r1, #8]
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
  206d56:	610a      	str	r2, [r1, #16]
  if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
  206d58:	f7fb fd9a 	bl	202890 <HAL_TIM_PWM_ConfigChannel>
  206d5c:	b120      	cbz	r0, 206d68 <MX_TIM4_Init+0x60>
    _Error_Handler(__FILE__, __LINE__);
  206d5e:	f240 1103 	movw	r1, #259	; 0x103
  206d62:	4816      	ldr	r0, [pc, #88]	; (206dbc <MX_TIM4_Init+0xb4>)
  206d64:	f7fe f8d0 	bl	204f08 <_Error_Handler>
  if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
  206d68:	2204      	movs	r2, #4
  206d6a:	4916      	ldr	r1, [pc, #88]	; (206dc4 <MX_TIM4_Init+0xbc>)
  206d6c:	4811      	ldr	r0, [pc, #68]	; (206db4 <MX_TIM4_Init+0xac>)
  206d6e:	f7fb fd8f 	bl	202890 <HAL_TIM_PWM_ConfigChannel>
  206d72:	b120      	cbz	r0, 206d7e <MX_TIM4_Init+0x76>
    _Error_Handler(__FILE__, __LINE__);
  206d74:	f44f 7184 	mov.w	r1, #264	; 0x108
  206d78:	4810      	ldr	r0, [pc, #64]	; (206dbc <MX_TIM4_Init+0xb4>)
  206d7a:	f7fe f8c5 	bl	204f08 <_Error_Handler>
  if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_3) != HAL_OK)
  206d7e:	2208      	movs	r2, #8
  206d80:	4910      	ldr	r1, [pc, #64]	; (206dc4 <MX_TIM4_Init+0xbc>)
  206d82:	480c      	ldr	r0, [pc, #48]	; (206db4 <MX_TIM4_Init+0xac>)
  206d84:	f7fb fd84 	bl	202890 <HAL_TIM_PWM_ConfigChannel>
  206d88:	b120      	cbz	r0, 206d94 <MX_TIM4_Init+0x8c>
    _Error_Handler(__FILE__, __LINE__);
  206d8a:	f240 110d 	movw	r1, #269	; 0x10d
  206d8e:	480b      	ldr	r0, [pc, #44]	; (206dbc <MX_TIM4_Init+0xb4>)
  206d90:	f7fe f8ba 	bl	204f08 <_Error_Handler>
  if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_4) != HAL_OK)
  206d94:	220c      	movs	r2, #12
  206d96:	490b      	ldr	r1, [pc, #44]	; (206dc4 <MX_TIM4_Init+0xbc>)
  206d98:	4806      	ldr	r0, [pc, #24]	; (206db4 <MX_TIM4_Init+0xac>)
  206d9a:	f7fb fd79 	bl	202890 <HAL_TIM_PWM_ConfigChannel>
  206d9e:	b120      	cbz	r0, 206daa <MX_TIM4_Init+0xa2>
    _Error_Handler(__FILE__, __LINE__);
  206da0:	f44f 7189 	mov.w	r1, #274	; 0x112
  206da4:	4805      	ldr	r0, [pc, #20]	; (206dbc <MX_TIM4_Init+0xb4>)
  206da6:	f7fe f8af 	bl	204f08 <_Error_Handler>
  HAL_TIM_MspPostInit(&htim4);
  206daa:	4802      	ldr	r0, [pc, #8]	; (206db4 <MX_TIM4_Init+0xac>)
}
  206dac:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_TIM_MspPostInit(&htim4);
  206db0:	f7ff bdde 	b.w	206970 <HAL_TIM_MspPostInit>
  206db4:	20000258 	.word	0x20000258
  206db8:	40000800 	.word	0x40000800
  206dbc:	0020788c 	.word	0x0020788c
  206dc0:	20000054 	.word	0x20000054
  206dc4:	20000060 	.word	0x20000060

00206dc8 <MX_TIM9_Init>:
{
  206dc8:	b508      	push	{r3, lr}
  htim9.Instance = TIM9;
  206dca:	481a      	ldr	r0, [pc, #104]	; (206e34 <MX_TIM9_Init+0x6c>)
  htim9.Init.Prescaler = 18;
  206dcc:	2312      	movs	r3, #18
  206dce:	491a      	ldr	r1, [pc, #104]	; (206e38 <MX_TIM9_Init+0x70>)
  htim9.Init.Period = 999;
  206dd0:	f240 32e7 	movw	r2, #999	; 0x3e7
  htim9.Init.Prescaler = 18;
  206dd4:	e880 000a 	stmia.w	r0, {r1, r3}
  htim9.Init.CounterMode = TIM_COUNTERMODE_UP;
  206dd8:	2300      	movs	r3, #0
  htim9.Init.Period = 999;
  206dda:	60c2      	str	r2, [r0, #12]
  htim9.Init.CounterMode = TIM_COUNTERMODE_UP;
  206ddc:	6083      	str	r3, [r0, #8]
  htim9.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  206dde:	6103      	str	r3, [r0, #16]
  htim9.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  206de0:	6183      	str	r3, [r0, #24]
  if (HAL_TIM_PWM_Init(&htim9) != HAL_OK)
  206de2:	f7fb fb51 	bl	202488 <HAL_TIM_PWM_Init>
  206de6:	b120      	cbz	r0, 206df2 <MX_TIM9_Init+0x2a>
    _Error_Handler(__FILE__, __LINE__);
  206de8:	f44f 71bc 	mov.w	r1, #376	; 0x178
  206dec:	4813      	ldr	r0, [pc, #76]	; (206e3c <MX_TIM9_Init+0x74>)
  206dee:	f7fe f88b 	bl	204f08 <_Error_Handler>
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  206df2:	4913      	ldr	r1, [pc, #76]	; (206e40 <MX_TIM9_Init+0x78>)
  sConfigOC.Pulse = 0;
  206df4:	2200      	movs	r2, #0
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  206df6:	2360      	movs	r3, #96	; 0x60
  if (HAL_TIM_PWM_ConfigChannel(&htim9, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
  206df8:	480e      	ldr	r0, [pc, #56]	; (206e34 <MX_TIM9_Init+0x6c>)
  sConfigOC.Pulse = 0;
  206dfa:	604a      	str	r2, [r1, #4]
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  206dfc:	600b      	str	r3, [r1, #0]
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  206dfe:	608a      	str	r2, [r1, #8]
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
  206e00:	610a      	str	r2, [r1, #16]
  if (HAL_TIM_PWM_ConfigChannel(&htim9, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
  206e02:	f7fb fd45 	bl	202890 <HAL_TIM_PWM_ConfigChannel>
  206e06:	b120      	cbz	r0, 206e12 <MX_TIM9_Init+0x4a>
    _Error_Handler(__FILE__, __LINE__);
  206e08:	f240 1181 	movw	r1, #385	; 0x181
  206e0c:	480b      	ldr	r0, [pc, #44]	; (206e3c <MX_TIM9_Init+0x74>)
  206e0e:	f7fe f87b 	bl	204f08 <_Error_Handler>
  if (HAL_TIM_PWM_ConfigChannel(&htim9, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
  206e12:	2204      	movs	r2, #4
  206e14:	490a      	ldr	r1, [pc, #40]	; (206e40 <MX_TIM9_Init+0x78>)
  206e16:	4807      	ldr	r0, [pc, #28]	; (206e34 <MX_TIM9_Init+0x6c>)
  206e18:	f7fb fd3a 	bl	202890 <HAL_TIM_PWM_ConfigChannel>
  206e1c:	b120      	cbz	r0, 206e28 <MX_TIM9_Init+0x60>
    _Error_Handler(__FILE__, __LINE__);
  206e1e:	f44f 71c3 	mov.w	r1, #390	; 0x186
  206e22:	4806      	ldr	r0, [pc, #24]	; (206e3c <MX_TIM9_Init+0x74>)
  206e24:	f7fe f870 	bl	204f08 <_Error_Handler>
  HAL_TIM_MspPostInit(&htim9);
  206e28:	4802      	ldr	r0, [pc, #8]	; (206e34 <MX_TIM9_Init+0x6c>)
}
  206e2a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_TIM_MspPostInit(&htim9);
  206e2e:	f7ff bd9f 	b.w	206970 <HAL_TIM_MspPostInit>
  206e32:	bf00      	nop
  206e34:	20000418 	.word	0x20000418
  206e38:	40014000 	.word	0x40014000
  206e3c:	0020788c 	.word	0x0020788c
  206e40:	20000060 	.word	0x20000060

00206e44 <MX_TIM10_Init>:
{
  206e44:	b508      	push	{r3, lr}
  htim10.Instance = TIM10;
  206e46:	4819      	ldr	r0, [pc, #100]	; (206eac <MX_TIM10_Init+0x68>)
  htim10.Init.Prescaler = 432;
  206e48:	f44f 73d8 	mov.w	r3, #432	; 0x1b0
  206e4c:	4918      	ldr	r1, [pc, #96]	; (206eb0 <MX_TIM10_Init+0x6c>)
  htim10.Init.Period = 9999;
  206e4e:	f242 720f 	movw	r2, #9999	; 0x270f
  htim10.Init.Prescaler = 432;
  206e52:	e880 000a 	stmia.w	r0, {r1, r3}
  htim10.Init.CounterMode = TIM_COUNTERMODE_UP;
  206e56:	2300      	movs	r3, #0
  htim10.Init.Period = 9999;
  206e58:	60c2      	str	r2, [r0, #12]
  htim10.Init.CounterMode = TIM_COUNTERMODE_UP;
  206e5a:	6083      	str	r3, [r0, #8]
  htim10.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  206e5c:	6103      	str	r3, [r0, #16]
  htim10.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  206e5e:	6183      	str	r3, [r0, #24]
  if (HAL_TIM_Base_Init(&htim10) != HAL_OK)
  206e60:	f7fb faf8 	bl	202454 <HAL_TIM_Base_Init>
  206e64:	b120      	cbz	r0, 206e70 <MX_TIM10_Init+0x2c>
    _Error_Handler(__FILE__, __LINE__);
  206e66:	f240 1197 	movw	r1, #407	; 0x197
  206e6a:	4812      	ldr	r0, [pc, #72]	; (206eb4 <MX_TIM10_Init+0x70>)
  206e6c:	f7fe f84c 	bl	204f08 <_Error_Handler>
  if (HAL_TIM_PWM_Init(&htim10) != HAL_OK)
  206e70:	480e      	ldr	r0, [pc, #56]	; (206eac <MX_TIM10_Init+0x68>)
  206e72:	f7fb fb09 	bl	202488 <HAL_TIM_PWM_Init>
  206e76:	b120      	cbz	r0, 206e82 <MX_TIM10_Init+0x3e>
    _Error_Handler(__FILE__, __LINE__);
  206e78:	f44f 71ce 	mov.w	r1, #412	; 0x19c
  206e7c:	480d      	ldr	r0, [pc, #52]	; (206eb4 <MX_TIM10_Init+0x70>)
  206e7e:	f7fe f843 	bl	204f08 <_Error_Handler>
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  206e82:	490d      	ldr	r1, [pc, #52]	; (206eb8 <MX_TIM10_Init+0x74>)
  sConfigOC.Pulse = 0;
  206e84:	2200      	movs	r2, #0
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  206e86:	2360      	movs	r3, #96	; 0x60
  if (HAL_TIM_PWM_ConfigChannel(&htim10, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
  206e88:	4808      	ldr	r0, [pc, #32]	; (206eac <MX_TIM10_Init+0x68>)
  sConfigOC.Pulse = 0;
  206e8a:	604a      	str	r2, [r1, #4]
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  206e8c:	600b      	str	r3, [r1, #0]
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  206e8e:	608a      	str	r2, [r1, #8]
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
  206e90:	610a      	str	r2, [r1, #16]
  if (HAL_TIM_PWM_ConfigChannel(&htim10, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
  206e92:	f7fb fcfd 	bl	202890 <HAL_TIM_PWM_ConfigChannel>
  206e96:	b120      	cbz	r0, 206ea2 <MX_TIM10_Init+0x5e>
    _Error_Handler(__FILE__, __LINE__);
  206e98:	f240 11a5 	movw	r1, #421	; 0x1a5
  206e9c:	4805      	ldr	r0, [pc, #20]	; (206eb4 <MX_TIM10_Init+0x70>)
  206e9e:	f7fe f833 	bl	204f08 <_Error_Handler>
  HAL_TIM_MspPostInit(&htim10);
  206ea2:	4802      	ldr	r0, [pc, #8]	; (206eac <MX_TIM10_Init+0x68>)
}
  206ea4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_TIM_MspPostInit(&htim10);
  206ea8:	f7ff bd62 	b.w	206970 <HAL_TIM_MspPostInit>
  206eac:	20000298 	.word	0x20000298
  206eb0:	40014400 	.word	0x40014400
  206eb4:	0020788c 	.word	0x0020788c
  206eb8:	20000060 	.word	0x20000060

00206ebc <MX_TIM11_Init>:
{
  206ebc:	b508      	push	{r3, lr}
  htim11.Instance = TIM11;
  206ebe:	4819      	ldr	r0, [pc, #100]	; (206f24 <MX_TIM11_Init+0x68>)
  htim11.Init.Prescaler = 432;
  206ec0:	f44f 73d8 	mov.w	r3, #432	; 0x1b0
  206ec4:	4918      	ldr	r1, [pc, #96]	; (206f28 <MX_TIM11_Init+0x6c>)
  htim11.Init.Period = 9999;
  206ec6:	f242 720f 	movw	r2, #9999	; 0x270f
  htim11.Init.Prescaler = 432;
  206eca:	e880 000a 	stmia.w	r0, {r1, r3}
  htim11.Init.CounterMode = TIM_COUNTERMODE_UP;
  206ece:	2300      	movs	r3, #0
  htim11.Init.Period = 9999;
  206ed0:	60c2      	str	r2, [r0, #12]
  htim11.Init.CounterMode = TIM_COUNTERMODE_UP;
  206ed2:	6083      	str	r3, [r0, #8]
  htim11.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  206ed4:	6103      	str	r3, [r0, #16]
  htim11.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  206ed6:	6183      	str	r3, [r0, #24]
  if (HAL_TIM_Base_Init(&htim11) != HAL_OK)
  206ed8:	f7fb fabc 	bl	202454 <HAL_TIM_Base_Init>
  206edc:	b120      	cbz	r0, 206ee8 <MX_TIM11_Init+0x2c>
    _Error_Handler(__FILE__, __LINE__);
  206ede:	f44f 71db 	mov.w	r1, #438	; 0x1b6
  206ee2:	4812      	ldr	r0, [pc, #72]	; (206f2c <MX_TIM11_Init+0x70>)
  206ee4:	f7fe f810 	bl	204f08 <_Error_Handler>
  if (HAL_TIM_PWM_Init(&htim11) != HAL_OK)
  206ee8:	480e      	ldr	r0, [pc, #56]	; (206f24 <MX_TIM11_Init+0x68>)
  206eea:	f7fb facd 	bl	202488 <HAL_TIM_PWM_Init>
  206eee:	b120      	cbz	r0, 206efa <MX_TIM11_Init+0x3e>
    _Error_Handler(__FILE__, __LINE__);
  206ef0:	f240 11bb 	movw	r1, #443	; 0x1bb
  206ef4:	480d      	ldr	r0, [pc, #52]	; (206f2c <MX_TIM11_Init+0x70>)
  206ef6:	f7fe f807 	bl	204f08 <_Error_Handler>
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  206efa:	490d      	ldr	r1, [pc, #52]	; (206f30 <MX_TIM11_Init+0x74>)
  sConfigOC.Pulse = 0;
  206efc:	2200      	movs	r2, #0
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  206efe:	2360      	movs	r3, #96	; 0x60
  if (HAL_TIM_PWM_ConfigChannel(&htim11, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
  206f00:	4808      	ldr	r0, [pc, #32]	; (206f24 <MX_TIM11_Init+0x68>)
  sConfigOC.Pulse = 0;
  206f02:	604a      	str	r2, [r1, #4]
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  206f04:	600b      	str	r3, [r1, #0]
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  206f06:	608a      	str	r2, [r1, #8]
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
  206f08:	610a      	str	r2, [r1, #16]
  if (HAL_TIM_PWM_ConfigChannel(&htim11, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
  206f0a:	f7fb fcc1 	bl	202890 <HAL_TIM_PWM_ConfigChannel>
  206f0e:	b120      	cbz	r0, 206f1a <MX_TIM11_Init+0x5e>
    _Error_Handler(__FILE__, __LINE__);
  206f10:	f44f 71e2 	mov.w	r1, #452	; 0x1c4
  206f14:	4805      	ldr	r0, [pc, #20]	; (206f2c <MX_TIM11_Init+0x70>)
  206f16:	f7fd fff7 	bl	204f08 <_Error_Handler>
  HAL_TIM_MspPostInit(&htim11);
  206f1a:	4802      	ldr	r0, [pc, #8]	; (206f24 <MX_TIM11_Init+0x68>)
}
  206f1c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_TIM_MspPostInit(&htim11);
  206f20:	f7ff bd26 	b.w	206970 <HAL_TIM_MspPostInit>
  206f24:	20000358 	.word	0x20000358
  206f28:	40014800 	.word	0x40014800
  206f2c:	0020788c 	.word	0x0020788c
  206f30:	20000060 	.word	0x20000060

00206f34 <MX_TIM12_Init>:
{
  206f34:	b508      	push	{r3, lr}
  htim12.Instance = TIM12;
  206f36:	481a      	ldr	r0, [pc, #104]	; (206fa0 <MX_TIM12_Init+0x6c>)
  htim12.Init.Prescaler = 9;
  206f38:	2309      	movs	r3, #9
  206f3a:	491a      	ldr	r1, [pc, #104]	; (206fa4 <MX_TIM12_Init+0x70>)
  htim12.Init.Period = 999;
  206f3c:	f240 32e7 	movw	r2, #999	; 0x3e7
  htim12.Init.Prescaler = 9;
  206f40:	e880 000a 	stmia.w	r0, {r1, r3}
  htim12.Init.CounterMode = TIM_COUNTERMODE_UP;
  206f44:	2300      	movs	r3, #0
  htim12.Init.Period = 999;
  206f46:	60c2      	str	r2, [r0, #12]
  htim12.Init.CounterMode = TIM_COUNTERMODE_UP;
  206f48:	6083      	str	r3, [r0, #8]
  htim12.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  206f4a:	6103      	str	r3, [r0, #16]
  htim12.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  206f4c:	6183      	str	r3, [r0, #24]
  if (HAL_TIM_PWM_Init(&htim12) != HAL_OK)
  206f4e:	f7fb fa9b 	bl	202488 <HAL_TIM_PWM_Init>
  206f52:	b120      	cbz	r0, 206f5e <MX_TIM12_Init+0x2a>
    _Error_Handler(__FILE__, __LINE__);
  206f54:	f240 11d5 	movw	r1, #469	; 0x1d5
  206f58:	4813      	ldr	r0, [pc, #76]	; (206fa8 <MX_TIM12_Init+0x74>)
  206f5a:	f7fd ffd5 	bl	204f08 <_Error_Handler>
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  206f5e:	4913      	ldr	r1, [pc, #76]	; (206fac <MX_TIM12_Init+0x78>)
  sConfigOC.Pulse = 0;
  206f60:	2200      	movs	r2, #0
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  206f62:	2360      	movs	r3, #96	; 0x60
  if (HAL_TIM_PWM_ConfigChannel(&htim12, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
  206f64:	480e      	ldr	r0, [pc, #56]	; (206fa0 <MX_TIM12_Init+0x6c>)
  sConfigOC.Pulse = 0;
  206f66:	604a      	str	r2, [r1, #4]
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  206f68:	600b      	str	r3, [r1, #0]
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  206f6a:	608a      	str	r2, [r1, #8]
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
  206f6c:	610a      	str	r2, [r1, #16]
  if (HAL_TIM_PWM_ConfigChannel(&htim12, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
  206f6e:	f7fb fc8f 	bl	202890 <HAL_TIM_PWM_ConfigChannel>
  206f72:	b120      	cbz	r0, 206f7e <MX_TIM12_Init+0x4a>
    _Error_Handler(__FILE__, __LINE__);
  206f74:	f44f 71ef 	mov.w	r1, #478	; 0x1de
  206f78:	480b      	ldr	r0, [pc, #44]	; (206fa8 <MX_TIM12_Init+0x74>)
  206f7a:	f7fd ffc5 	bl	204f08 <_Error_Handler>
  if (HAL_TIM_PWM_ConfigChannel(&htim12, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
  206f7e:	2204      	movs	r2, #4
  206f80:	490a      	ldr	r1, [pc, #40]	; (206fac <MX_TIM12_Init+0x78>)
  206f82:	4807      	ldr	r0, [pc, #28]	; (206fa0 <MX_TIM12_Init+0x6c>)
  206f84:	f7fb fc84 	bl	202890 <HAL_TIM_PWM_ConfigChannel>
  206f88:	b120      	cbz	r0, 206f94 <MX_TIM12_Init+0x60>
    _Error_Handler(__FILE__, __LINE__);
  206f8a:	f240 11e3 	movw	r1, #483	; 0x1e3
  206f8e:	4806      	ldr	r0, [pc, #24]	; (206fa8 <MX_TIM12_Init+0x74>)
  206f90:	f7fd ffba 	bl	204f08 <_Error_Handler>
  HAL_TIM_MspPostInit(&htim12);
  206f94:	4802      	ldr	r0, [pc, #8]	; (206fa0 <MX_TIM12_Init+0x6c>)
}
  206f96:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_TIM_MspPostInit(&htim12);
  206f9a:	f7ff bce9 	b.w	206970 <HAL_TIM_MspPostInit>
  206f9e:	bf00      	nop
  206fa0:	20000498 	.word	0x20000498
  206fa4:	40001800 	.word	0x40001800
  206fa8:	0020788c 	.word	0x0020788c
  206fac:	20000060 	.word	0x20000060

00206fb0 <MX_USART1_UART_Init>:
DMA_HandleTypeDef hdma_usart1_rx;

/* USART1 init function */

void MX_USART1_UART_Init(void)
{
  206fb0:	b508      	push	{r3, lr}

  huart1.Instance = USART1;
  206fb2:	480d      	ldr	r0, [pc, #52]	; (206fe8 <MX_USART1_UART_Init+0x38>)
  huart1.Init.BaudRate = 115200;
  206fb4:	f44f 3ee1 	mov.w	lr, #115200	; 0x1c200
  206fb8:	4b0c      	ldr	r3, [pc, #48]	; (206fec <MX_USART1_UART_Init+0x3c>)
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
  huart1.Init.StopBits = UART_STOPBITS_1;
  huart1.Init.Parity = UART_PARITY_NONE;
  huart1.Init.Mode = UART_MODE_TX_RX;
  206fba:	220c      	movs	r2, #12
  huart1.Init.BaudRate = 115200;
  206fbc:	e880 4008 	stmia.w	r0, {r3, lr}
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
  206fc0:	2300      	movs	r3, #0
  huart1.Init.Mode = UART_MODE_TX_RX;
  206fc2:	6142      	str	r2, [r0, #20]
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
  206fc4:	6083      	str	r3, [r0, #8]
  huart1.Init.StopBits = UART_STOPBITS_1;
  206fc6:	60c3      	str	r3, [r0, #12]
  huart1.Init.Parity = UART_PARITY_NONE;
  206fc8:	6103      	str	r3, [r0, #16]
  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  206fca:	6183      	str	r3, [r0, #24]
  huart1.Init.OverSampling = UART_OVERSAMPLING_16;
  206fcc:	61c3      	str	r3, [r0, #28]
  huart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
  206fce:	6203      	str	r3, [r0, #32]
  huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
  206fd0:	6243      	str	r3, [r0, #36]	; 0x24
  if (HAL_UART_Init(&huart1) != HAL_OK)
  206fd2:	f7fc f8bc 	bl	20314e <HAL_UART_Init>
  206fd6:	b128      	cbz	r0, 206fe4 <MX_USART1_UART_Init+0x34>
  {
    _Error_Handler(__FILE__, __LINE__);
  206fd8:	2147      	movs	r1, #71	; 0x47
  206fda:	4805      	ldr	r0, [pc, #20]	; (206ff0 <MX_USART1_UART_Init+0x40>)
  }

}
  206fdc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    _Error_Handler(__FILE__, __LINE__);
  206fe0:	f7fd bf92 	b.w	204f08 <_Error_Handler>
  206fe4:	bd08      	pop	{r3, pc}
  206fe6:	bf00      	nop
  206fe8:	20000538 	.word	0x20000538
  206fec:	40011000 	.word	0x40011000
  206ff0:	00207899 	.word	0x00207899

00206ff4 <MX_USART2_UART_Init>:
/* USART2 init function */

void MX_USART2_UART_Init(void)
{
  206ff4:	b508      	push	{r3, lr}

  huart2.Instance = USART2;
  206ff6:	480d      	ldr	r0, [pc, #52]	; (20702c <MX_USART2_UART_Init+0x38>)
  huart2.Init.BaudRate = 115200;
  206ff8:	f44f 3ee1 	mov.w	lr, #115200	; 0x1c200
  206ffc:	4b0c      	ldr	r3, [pc, #48]	; (207030 <MX_USART2_UART_Init+0x3c>)
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
  huart2.Init.StopBits = UART_STOPBITS_1;
  huart2.Init.Parity = UART_PARITY_NONE;
  huart2.Init.Mode = UART_MODE_TX_RX;
  206ffe:	220c      	movs	r2, #12
  huart2.Init.BaudRate = 115200;
  207000:	e880 4008 	stmia.w	r0, {r3, lr}
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
  207004:	2300      	movs	r3, #0
  huart2.Init.Mode = UART_MODE_TX_RX;
  207006:	6142      	str	r2, [r0, #20]
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
  207008:	6083      	str	r3, [r0, #8]
  huart2.Init.StopBits = UART_STOPBITS_1;
  20700a:	60c3      	str	r3, [r0, #12]
  huart2.Init.Parity = UART_PARITY_NONE;
  20700c:	6103      	str	r3, [r0, #16]
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  20700e:	6183      	str	r3, [r0, #24]
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
  207010:	61c3      	str	r3, [r0, #28]
  huart2.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
  207012:	6203      	str	r3, [r0, #32]
  huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
  207014:	6243      	str	r3, [r0, #36]	; 0x24
  if (HAL_UART_Init(&huart2) != HAL_OK)
  207016:	f7fc f89a 	bl	20314e <HAL_UART_Init>
  20701a:	b128      	cbz	r0, 207028 <MX_USART2_UART_Init+0x34>
  {
    _Error_Handler(__FILE__, __LINE__);
  20701c:	215c      	movs	r1, #92	; 0x5c
  20701e:	4805      	ldr	r0, [pc, #20]	; (207034 <MX_USART2_UART_Init+0x40>)
  }

}
  207020:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    _Error_Handler(__FILE__, __LINE__);
  207024:	f7fd bf70 	b.w	204f08 <_Error_Handler>
  207028:	bd08      	pop	{r3, pc}
  20702a:	bf00      	nop
  20702c:	200005a8 	.word	0x200005a8
  207030:	40004400 	.word	0x40004400
  207034:	00207899 	.word	0x00207899

00207038 <HAL_UART_MspInit>:

void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle)
{

  GPIO_InitTypeDef GPIO_InitStruct;
  if(uartHandle->Instance==USART1)
  207038:	6803      	ldr	r3, [r0, #0]
  20703a:	4a32      	ldr	r2, [pc, #200]	; (207104 <HAL_UART_MspInit+0xcc>)
  20703c:	4293      	cmp	r3, r2
{
  20703e:	b530      	push	{r4, r5, lr}
  207040:	4605      	mov	r5, r0
  207042:	b089      	sub	sp, #36	; 0x24
  if(uartHandle->Instance==USART1)
  207044:	d141      	bne.n	2070ca <HAL_UART_MspInit+0x92>
  {
  /* USER CODE BEGIN USART1_MspInit 0 */

  /* USER CODE END USART1_MspInit 0 */
    /* USART1 clock enable */
    __HAL_RCC_USART1_CLK_ENABLE();
  207046:	4b30      	ldr	r3, [pc, #192]	; (207108 <HAL_UART_MspInit+0xd0>)
    GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
  207048:	a903      	add	r1, sp, #12
  20704a:	4830      	ldr	r0, [pc, #192]	; (20710c <HAL_UART_MspInit+0xd4>)
    __HAL_RCC_USART1_CLK_ENABLE();
  20704c:	6c5a      	ldr	r2, [r3, #68]	; 0x44

    /* USART1 DMA Init */
    /* USART1_RX Init */
    hdma_usart1_rx.Instance = DMA2_Stream2;
  20704e:	4c30      	ldr	r4, [pc, #192]	; (207110 <HAL_UART_MspInit+0xd8>)
    __HAL_RCC_USART1_CLK_ENABLE();
  207050:	f042 0210 	orr.w	r2, r2, #16
  207054:	645a      	str	r2, [r3, #68]	; 0x44
  207056:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  207058:	f003 0310 	and.w	r3, r3, #16
  20705c:	9301      	str	r3, [sp, #4]
  20705e:	9b01      	ldr	r3, [sp, #4]
    GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10;
  207060:	f44f 63c0 	mov.w	r3, #1536	; 0x600
  207064:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  207066:	2302      	movs	r3, #2
  207068:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
  20706a:	2301      	movs	r3, #1
  20706c:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  20706e:	2303      	movs	r3, #3
  207070:	9306      	str	r3, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
  207072:	2307      	movs	r3, #7
  207074:	9307      	str	r3, [sp, #28]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
  207076:	f7f9 ff43 	bl	200f00 <HAL_GPIO_Init>
    hdma_usart1_rx.Init.Channel = DMA_CHANNEL_4;
    hdma_usart1_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
    hdma_usart1_rx.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_usart1_rx.Init.MemInc = DMA_MINC_ENABLE;
  20707a:	f44f 6280 	mov.w	r2, #1024	; 0x400
    hdma_usart1_rx.Init.Channel = DMA_CHANNEL_4;
  20707e:	4825      	ldr	r0, [pc, #148]	; (207114 <HAL_UART_MspInit+0xdc>)
  207080:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
    hdma_usart1_rx.Init.MemInc = DMA_MINC_ENABLE;
  207084:	6122      	str	r2, [r4, #16]
    hdma_usart1_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    hdma_usart1_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_usart1_rx.Init.Mode = DMA_CIRCULAR;
  207086:	f44f 7280 	mov.w	r2, #256	; 0x100
    hdma_usart1_rx.Init.Channel = DMA_CHANNEL_4;
  20708a:	e884 0009 	stmia.w	r4, {r0, r3}
    hdma_usart1_rx.Init.Mode = DMA_CIRCULAR;
  20708e:	61e2      	str	r2, [r4, #28]
    hdma_usart1_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
  207090:	2300      	movs	r3, #0
    hdma_usart1_rx.Init.Priority = DMA_PRIORITY_MEDIUM;
  207092:	f44f 3280 	mov.w	r2, #65536	; 0x10000
    hdma_usart1_rx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
    if (HAL_DMA_Init(&hdma_usart1_rx) != HAL_OK)
  207096:	4620      	mov	r0, r4
    hdma_usart1_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
  207098:	60a3      	str	r3, [r4, #8]
    hdma_usart1_rx.Init.PeriphInc = DMA_PINC_DISABLE;
  20709a:	60e3      	str	r3, [r4, #12]
    hdma_usart1_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
  20709c:	6163      	str	r3, [r4, #20]
    hdma_usart1_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
  20709e:	61a3      	str	r3, [r4, #24]
    hdma_usart1_rx.Init.Priority = DMA_PRIORITY_MEDIUM;
  2070a0:	6222      	str	r2, [r4, #32]
    hdma_usart1_rx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
  2070a2:	6263      	str	r3, [r4, #36]	; 0x24
    if (HAL_DMA_Init(&hdma_usart1_rx) != HAL_OK)
  2070a4:	f7f9 fda0 	bl	200be8 <HAL_DMA_Init>
  2070a8:	b118      	cbz	r0, 2070b2 <HAL_UART_MspInit+0x7a>
    {
      _Error_Handler(__FILE__, __LINE__);
  2070aa:	2186      	movs	r1, #134	; 0x86
  2070ac:	481a      	ldr	r0, [pc, #104]	; (207118 <HAL_UART_MspInit+0xe0>)
  2070ae:	f7fd ff2b 	bl	204f08 <_Error_Handler>
    }

    __HAL_LINKDMA(uartHandle,hdmarx,hdma_usart1_rx);

    /* USART1 interrupt Init */
    HAL_NVIC_SetPriority(USART1_IRQn, 2, 0);
  2070b2:	2025      	movs	r0, #37	; 0x25
    __HAL_LINKDMA(uartHandle,hdmarx,hdma_usart1_rx);
  2070b4:	666c      	str	r4, [r5, #100]	; 0x64
    HAL_NVIC_SetPriority(USART1_IRQn, 2, 0);
  2070b6:	2200      	movs	r2, #0
  2070b8:	2102      	movs	r1, #2
    __HAL_LINKDMA(uartHandle,hdmarx,hdma_usart1_rx);
  2070ba:	63a5      	str	r5, [r4, #56]	; 0x38
    HAL_NVIC_SetPriority(USART1_IRQn, 2, 0);
  2070bc:	f7f9 fd12 	bl	200ae4 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USART1_IRQn);
  2070c0:	2025      	movs	r0, #37	; 0x25
  2070c2:	f7f9 fd47 	bl	200b54 <HAL_NVIC_EnableIRQ>

  /* USER CODE BEGIN USART2_MspInit 1 */

  /* USER CODE END USART2_MspInit 1 */
  }
}
  2070c6:	b009      	add	sp, #36	; 0x24
  2070c8:	bd30      	pop	{r4, r5, pc}
  else if(uartHandle->Instance==USART2)
  2070ca:	4a14      	ldr	r2, [pc, #80]	; (20711c <HAL_UART_MspInit+0xe4>)
  2070cc:	4293      	cmp	r3, r2
  2070ce:	d1fa      	bne.n	2070c6 <HAL_UART_MspInit+0x8e>
    __HAL_RCC_USART2_CLK_ENABLE();
  2070d0:	4b0d      	ldr	r3, [pc, #52]	; (207108 <HAL_UART_MspInit+0xd0>)
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
  2070d2:	a903      	add	r1, sp, #12
  2070d4:	4812      	ldr	r0, [pc, #72]	; (207120 <HAL_UART_MspInit+0xe8>)
    __HAL_RCC_USART2_CLK_ENABLE();
  2070d6:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  2070d8:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
  2070dc:	641a      	str	r2, [r3, #64]	; 0x40
  2070de:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  2070e0:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
  2070e4:	9302      	str	r3, [sp, #8]
  2070e6:	9b02      	ldr	r3, [sp, #8]
    GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_6;
  2070e8:	2360      	movs	r3, #96	; 0x60
  2070ea:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  2070ec:	2302      	movs	r3, #2
  2070ee:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
  2070f0:	2301      	movs	r3, #1
  2070f2:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  2070f4:	2303      	movs	r3, #3
  2070f6:	9306      	str	r3, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
  2070f8:	2307      	movs	r3, #7
  2070fa:	9307      	str	r3, [sp, #28]
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
  2070fc:	f7f9 ff00 	bl	200f00 <HAL_GPIO_Init>
}
  207100:	e7e1      	b.n	2070c6 <HAL_UART_MspInit+0x8e>
  207102:	bf00      	nop
  207104:	40011000 	.word	0x40011000
  207108:	40023800 	.word	0x40023800
  20710c:	40020000 	.word	0x40020000
  207110:	200004d8 	.word	0x200004d8
  207114:	40026440 	.word	0x40026440
  207118:	00207899 	.word	0x00207899
  20711c:	40004400 	.word	0x40004400
  207120:	40020c00 	.word	0x40020c00

00207124 <init_xprintf>:
/* Put a character                              */
/*----------------------------------------------*/


void init_xprintf(UART_HandleTypeDef *handler){
	huart_xprintf = handler;
  207124:	4b01      	ldr	r3, [pc, #4]	; (20712c <init_xprintf+0x8>)
  207126:	6018      	str	r0, [r3, #0]
  207128:	4770      	bx	lr
  20712a:	bf00      	nop
  20712c:	200001ac 	.word	0x200001ac

00207130 <uart_putc>:
	    HAL_UART_Receive(huart_xprintf, (uint8_t *)buf, sizeof(buf), 0xFFFF);
	    c = buf[0];
	    return c;
	}
void uart_putc(uint8_t c)
	{
  207130:	b507      	push	{r0, r1, r2, lr}
	 char buf[1];
	 buf[0] = c;
  207132:	a902      	add	r1, sp, #8
	 HAL_UART_Transmit(huart_xprintf, (uint8_t *)buf, sizeof(buf), 0xFFFF);
  207134:	f64f 73ff 	movw	r3, #65535	; 0xffff
  207138:	2201      	movs	r2, #1
	 buf[0] = c;
  20713a:	f801 0d04 	strb.w	r0, [r1, #-4]!
	 HAL_UART_Transmit(huart_xprintf, (uint8_t *)buf, sizeof(buf), 0xFFFF);
  20713e:	4803      	ldr	r0, [pc, #12]	; (20714c <uart_putc+0x1c>)
  207140:	6800      	ldr	r0, [r0, #0]
  207142:	f7fb fcae 	bl	202aa2 <HAL_UART_Transmit>
	}
  207146:	b003      	add	sp, #12
  207148:	f85d fb04 	ldr.w	pc, [sp], #4
  20714c:	200001ac 	.word	0x200001ac

00207150 <xputc>:
	    }
	}

void xputc (char c)
{
	if (_CR_CRLF && c == '\n') xputc('\r');		/* CR -> CRLF */
  207150:	280a      	cmp	r0, #10
{
  207152:	b510      	push	{r4, lr}
  207154:	4604      	mov	r4, r0
	if (_CR_CRLF && c == '\n') xputc('\r');		/* CR -> CRLF */
  207156:	d102      	bne.n	20715e <xputc+0xe>
  207158:	200d      	movs	r0, #13
  20715a:	f7ff fff9 	bl	207150 <xputc>

	if (outptr) {
  20715e:	4a07      	ldr	r2, [pc, #28]	; (20717c <xputc+0x2c>)
  207160:	6813      	ldr	r3, [r2, #0]
  207162:	b11b      	cbz	r3, 20716c <xputc+0x1c>
		*outptr++ = (unsigned char)c;
  207164:	1c59      	adds	r1, r3, #1
  207166:	701c      	strb	r4, [r3, #0]
  207168:	6011      	str	r1, [r2, #0]
		return;
  20716a:	bd10      	pop	{r4, pc}
	}

	if (xfunc_out) xfunc_out((unsigned char)c);
  20716c:	4b04      	ldr	r3, [pc, #16]	; (207180 <xputc+0x30>)
  20716e:	681b      	ldr	r3, [r3, #0]
  207170:	b11b      	cbz	r3, 20717a <xputc+0x2a>
  207172:	4620      	mov	r0, r4
}
  207174:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	if (xfunc_out) xfunc_out((unsigned char)c);
  207178:	4718      	bx	r3
  20717a:	bd10      	pop	{r4, pc}
  20717c:	20000048 	.word	0x20000048
  207180:	2000061c 	.word	0x2000061c

00207184 <xputs>:
/*----------------------------------------------*/

void xputs (					/* Put a string to the default device */
	const char* str				/* Pointer to the string */
)
{
  207184:	b510      	push	{r4, lr}
  207186:	1e44      	subs	r4, r0, #1
	while (*str)
  207188:	f814 0f01 	ldrb.w	r0, [r4, #1]!
  20718c:	b900      	cbnz	r0, 207190 <xputs+0xc>
		xputc(*str++);
}
  20718e:	bd10      	pop	{r4, pc}
		xputc(*str++);
  207190:	f7ff ffde 	bl	207150 <xputc>
  207194:	e7f8      	b.n	207188 <xputs+0x4>

00207196 <xvprintf>:
static
void xvprintf (
	const char*	fmt,	/* Pointer to the format string */
	va_list arp			/* Pointer to arguments */
)
{
  207196:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
  20719a:	4602      	mov	r2, r0
  20719c:	460d      	mov	r5, r1
	unsigned long v;
	char s[16], c, d, *p;


	for (;;) {
		c = *fmt++;					/* Get a char */
  20719e:	7810      	ldrb	r0, [r2, #0]
		if (!c) break;				/* End of format? */
  2071a0:	2800      	cmp	r0, #0
  2071a2:	f000 80cc 	beq.w	20733e <xvprintf+0x1a8>
		if (c != '%') {				/* Pass through it if not a % sequense */
  2071a6:	2825      	cmp	r0, #37	; 0x25
  2071a8:	d004      	beq.n	2071b4 <xvprintf+0x1e>
		c = *fmt++;					/* Get a char */
  2071aa:	1c57      	adds	r7, r2, #1
		case 'U' :					/* Unsigned decimal */
			r = 10; break;
		case 'X' :					/* Hexdecimal */
			r = 16; break;
		default:					/* Unknown type (passthrough) */
			xputc(c); continue;
  2071ac:	f7ff ffd0 	bl	207150 <xputc>
  2071b0:	462c      	mov	r4, r5
  2071b2:	e052      	b.n	20725a <xvprintf+0xc4>
		c = *fmt++;					/* Get first char of the sequense */
  2071b4:	7853      	ldrb	r3, [r2, #1]
		if (c == '0') {				/* Flag: '0' padded */
  2071b6:	2b30      	cmp	r3, #48	; 0x30
  2071b8:	d128      	bne.n	20720c <xvprintf+0x76>
			f = 1; c = *fmt++;
  2071ba:	1cd7      	adds	r7, r2, #3
  2071bc:	7893      	ldrb	r3, [r2, #2]
  2071be:	2601      	movs	r6, #1
		for (w = 0; c >= '0' && c <= '9'; c = *fmt++)	/* Minimum width */
  2071c0:	f04f 0800 	mov.w	r8, #0
			w = w * 10 + c - '0';
  2071c4:	210a      	movs	r1, #10
		for (w = 0; c >= '0' && c <= '9'; c = *fmt++)	/* Minimum width */
  2071c6:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
  2071ca:	2a09      	cmp	r2, #9
  2071cc:	d927      	bls.n	20721e <xvprintf+0x88>
		if (c == 'l' || c == 'L') {	/* Prefix: Size is long int */
  2071ce:	f003 02df 	and.w	r2, r3, #223	; 0xdf
  2071d2:	2a4c      	cmp	r2, #76	; 0x4c
			f |= 4; c = *fmt++;
  2071d4:	bf02      	ittt	eq
  2071d6:	783b      	ldrbeq	r3, [r7, #0]
  2071d8:	f046 0604 	orreq.w	r6, r6, #4
  2071dc:	3701      	addeq	r7, #1
		if (!c) break;				/* End of format? */
  2071de:	2b00      	cmp	r3, #0
  2071e0:	f000 80ad 	beq.w	20733e <xvprintf+0x1a8>
		if (d >= 'a') d -= 0x20;
  2071e4:	2b60      	cmp	r3, #96	; 0x60
  2071e6:	bf8a      	itet	hi
  2071e8:	f1a3 0220 	subhi.w	r2, r3, #32
  2071ec:	461a      	movls	r2, r3
  2071ee:	b2d2      	uxtbhi	r2, r2
		switch (d) {				/* Type is... */
  2071f0:	2a4f      	cmp	r2, #79	; 0x4f
  2071f2:	d035      	beq.n	207260 <xvprintf+0xca>
  2071f4:	d81a      	bhi.n	20722c <xvprintf+0x96>
  2071f6:	2a43      	cmp	r2, #67	; 0x43
  2071f8:	f000 808a 	beq.w	207310 <xvprintf+0x17a>
  2071fc:	2a44      	cmp	r2, #68	; 0x44
  2071fe:	f000 8090 	beq.w	207322 <xvprintf+0x18c>
  207202:	2a42      	cmp	r2, #66	; 0x42
  207204:	f000 808b 	beq.w	20731e <xvprintf+0x188>
			xputc(c); continue;
  207208:	4618      	mov	r0, r3
  20720a:	e7cf      	b.n	2071ac <xvprintf+0x16>
			if (c == '-') {			/* Flag: left justified */
  20720c:	2b2d      	cmp	r3, #45	; 0x2d
		c = *fmt++;					/* Get first char of the sequense */
  20720e:	bf19      	ittee	ne
  207210:	1c97      	addne	r7, r2, #2
		f = 0;
  207212:	2600      	movne	r6, #0
				f = 2; c = *fmt++;
  207214:	1cd7      	addeq	r7, r2, #3
  207216:	7893      	ldrbeq	r3, [r2, #2]
  207218:	bf08      	it	eq
  20721a:	2602      	moveq	r6, #2
  20721c:	e7d0      	b.n	2071c0 <xvprintf+0x2a>
			w = w * 10 + c - '0';
  20721e:	fb01 3808 	mla	r8, r1, r8, r3
		for (w = 0; c >= '0' && c <= '9'; c = *fmt++)	/* Minimum width */
  207222:	f817 3b01 	ldrb.w	r3, [r7], #1
			w = w * 10 + c - '0';
  207226:	f1a8 0830 	sub.w	r8, r8, #48	; 0x30
  20722a:	e7cc      	b.n	2071c6 <xvprintf+0x30>
		switch (d) {				/* Type is... */
  20722c:	2a55      	cmp	r2, #85	; 0x55
  20722e:	d078      	beq.n	207322 <xvprintf+0x18c>
  207230:	2a58      	cmp	r2, #88	; 0x58
  207232:	d072      	beq.n	20731a <xvprintf+0x184>
  207234:	2a53      	cmp	r2, #83	; 0x53
  207236:	d1e7      	bne.n	207208 <xvprintf+0x72>
			p = va_arg(arp, char*);
  207238:	f8d5 9000 	ldr.w	r9, [r5]
  20723c:	1d2c      	adds	r4, r5, #4
			for (j = 0; p[j]; j++) ;
  20723e:	464b      	mov	r3, r9
  207240:	eba3 0509 	sub.w	r5, r3, r9
  207244:	f813 2b01 	ldrb.w	r2, [r3], #1
  207248:	2a00      	cmp	r2, #0
  20724a:	d1f9      	bne.n	207240 <xvprintf+0xaa>
			while (!(f & 2) && j++ < w) xputc(' ');
  20724c:	07b0      	lsls	r0, r6, #30
  20724e:	d554      	bpl.n	2072fa <xvprintf+0x164>
			xputs(p);
  207250:	4648      	mov	r0, r9
  207252:	f7ff ff97 	bl	207184 <xputs>
			while (j++ < w) xputc(' ');
  207256:	45a8      	cmp	r8, r5
  207258:	d855      	bhi.n	207306 <xvprintf+0x170>
			xputc(c); continue;
  20725a:	4625      	mov	r5, r4
  20725c:	463a      	mov	r2, r7
  20725e:	e79e      	b.n	20719e <xvprintf+0x8>
			r = 8; break;
  207260:	2008      	movs	r0, #8
		}

		/* Get an argument and put it in numeral */
		v = (f & 4) ? va_arg(arp, long) : ((d == 'D') ? (long)va_arg(arp, int) : (long)va_arg(arp, unsigned int));
  207262:	2a44      	cmp	r2, #68	; 0x44
  207264:	6829      	ldr	r1, [r5, #0]
  207266:	f105 0404 	add.w	r4, r5, #4
  20726a:	d104      	bne.n	207276 <xvprintf+0xe0>
		if (d == 'D' && (v & 0x80000000)) {
  20726c:	2900      	cmp	r1, #0
			v = 0 - v;
  20726e:	bfbc      	itt	lt
  207270:	4249      	neglt	r1, r1
			f |= 8;
  207272:	f046 0608 	orrlt.w	r6, r6, #8
  207276:	2b78      	cmp	r3, #120	; 0x78
		}
		i = 0;
  207278:	f04f 0200 	mov.w	r2, #0
  20727c:	bf0c      	ite	eq
  20727e:	f04f 0c27 	moveq.w	ip, #39	; 0x27
  207282:	f04f 0c07 	movne.w	ip, #7
		do {
			d = (char)(v % r); v /= r;
  207286:	fbb1 fef0 	udiv	lr, r1, r0
  20728a:	fb00 151e 	mls	r5, r0, lr, r1
  20728e:	4671      	mov	r1, lr
  207290:	b2eb      	uxtb	r3, r5
			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
  207292:	2d09      	cmp	r5, #9
			s[i++] = d + '0';
  207294:	f102 0501 	add.w	r5, r2, #1
			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
  207298:	bf84      	itt	hi
  20729a:	4463      	addhi	r3, ip
  20729c:	b2db      	uxtbhi	r3, r3
			s[i++] = d + '0';
  20729e:	3330      	adds	r3, #48	; 0x30
  2072a0:	f80d 3002 	strb.w	r3, [sp, r2]
		} while (v && i < sizeof(s));
  2072a4:	f1be 0f00 	cmp.w	lr, #0
  2072a8:	d002      	beq.n	2072b0 <xvprintf+0x11a>
  2072aa:	2d10      	cmp	r5, #16
  2072ac:	d13b      	bne.n	207326 <xvprintf+0x190>
  2072ae:	220f      	movs	r2, #15
		if (f & 8) s[i++] = '-';
  2072b0:	0731      	lsls	r1, r6, #28
  2072b2:	d505      	bpl.n	2072c0 <xvprintf+0x12a>
  2072b4:	ab04      	add	r3, sp, #16
  2072b6:	441d      	add	r5, r3
  2072b8:	232d      	movs	r3, #45	; 0x2d
  2072ba:	f805 3c10 	strb.w	r3, [r5, #-16]
  2072be:	1c95      	adds	r5, r2, #2
		j = i; d = (f & 1) ? '0' : ' ';
  2072c0:	f016 0f01 	tst.w	r6, #1
  2072c4:	46a9      	mov	r9, r5
  2072c6:	bf14      	ite	ne
  2072c8:	f04f 0a30 	movne.w	sl, #48	; 0x30
  2072cc:	f04f 0a20 	moveq.w	sl, #32
		while (!(f & 2) && j++ < w) xputc(d);
  2072d0:	07b3      	lsls	r3, r6, #30
  2072d2:	d52e      	bpl.n	207332 <xvprintf+0x19c>
		do xputc(s[--i]); while(i);
  2072d4:	3d01      	subs	r5, #1
  2072d6:	f81d 0005 	ldrb.w	r0, [sp, r5]
  2072da:	f7ff ff39 	bl	207150 <xputc>
  2072de:	2d00      	cmp	r5, #0
  2072e0:	d1f8      	bne.n	2072d4 <xvprintf+0x13e>
		while (j++ < w) xputc(' ');
  2072e2:	45c8      	cmp	r8, r9
  2072e4:	d9b9      	bls.n	20725a <xvprintf+0xc4>
  2072e6:	2020      	movs	r0, #32
  2072e8:	f109 0901 	add.w	r9, r9, #1
  2072ec:	f7ff ff30 	bl	207150 <xputc>
  2072f0:	e7f7      	b.n	2072e2 <xvprintf+0x14c>
			while (!(f & 2) && j++ < w) xputc(' ');
  2072f2:	4635      	mov	r5, r6
  2072f4:	2020      	movs	r0, #32
  2072f6:	f7ff ff2b 	bl	207150 <xputc>
  2072fa:	4545      	cmp	r5, r8
  2072fc:	f105 0601 	add.w	r6, r5, #1
  207300:	d3f7      	bcc.n	2072f2 <xvprintf+0x15c>
  207302:	4635      	mov	r5, r6
  207304:	e7a4      	b.n	207250 <xvprintf+0xba>
			while (j++ < w) xputc(' ');
  207306:	2020      	movs	r0, #32
  207308:	3501      	adds	r5, #1
  20730a:	f7ff ff21 	bl	207150 <xputc>
  20730e:	e7a2      	b.n	207256 <xvprintf+0xc0>
			xputc((char)va_arg(arp, int)); continue;
  207310:	7828      	ldrb	r0, [r5, #0]
  207312:	1d2c      	adds	r4, r5, #4
  207314:	f7ff ff1c 	bl	207150 <xputc>
  207318:	e79f      	b.n	20725a <xvprintf+0xc4>
			r = 16; break;
  20731a:	2010      	movs	r0, #16
  20731c:	e7a1      	b.n	207262 <xvprintf+0xcc>
			r = 2; break;
  20731e:	2002      	movs	r0, #2
  207320:	e79f      	b.n	207262 <xvprintf+0xcc>
			r = 10; break;
  207322:	200a      	movs	r0, #10
  207324:	e79d      	b.n	207262 <xvprintf+0xcc>
  207326:	462a      	mov	r2, r5
  207328:	e7ad      	b.n	207286 <xvprintf+0xf0>
		while (!(f & 2) && j++ < w) xputc(d);
  20732a:	46b1      	mov	r9, r6
  20732c:	4650      	mov	r0, sl
  20732e:	f7ff ff0f 	bl	207150 <xputc>
  207332:	45c1      	cmp	r9, r8
  207334:	f109 0601 	add.w	r6, r9, #1
  207338:	d3f7      	bcc.n	20732a <xvprintf+0x194>
  20733a:	46b1      	mov	r9, r6
  20733c:	e7ca      	b.n	2072d4 <xvprintf+0x13e>
	}
}
  20733e:	b004      	add	sp, #16
  207340:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

00207344 <xprintf>:

void xprintf (			/* Put a formatted string to the default device */
	const char*	fmt,	/* Pointer to the format string */
	...					/* Optional arguments */
)
{
  207344:	b40f      	push	{r0, r1, r2, r3}
  207346:	b507      	push	{r0, r1, r2, lr}
  207348:	a904      	add	r1, sp, #16
  20734a:	f851 0b04 	ldr.w	r0, [r1], #4
	va_list arp;


	va_start(arp, fmt);
  20734e:	9101      	str	r1, [sp, #4]
	xvprintf(fmt, arp);
  207350:	f7ff ff21 	bl	207196 <xvprintf>
	va_end(arp);
}
  207354:	b003      	add	sp, #12
  207356:	f85d eb04 	ldr.w	lr, [sp], #4
  20735a:	b004      	add	sp, #16
  20735c:	4770      	bx	lr
	...

00207360 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack      /* set stack pointer */
  207360:	f8df d034 	ldr.w	sp, [pc, #52]	; 207398 <LoopFillZerobss+0x14>

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
  207364:	2100      	movs	r1, #0
  b  LoopCopyDataInit
  207366:	e003      	b.n	207370 <LoopCopyDataInit>

00207368 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
  207368:	4b0c      	ldr	r3, [pc, #48]	; (20739c <LoopFillZerobss+0x18>)
  ldr  r3, [r3, r1]
  20736a:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
  20736c:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
  20736e:	3104      	adds	r1, #4

00207370 <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
  207370:	480b      	ldr	r0, [pc, #44]	; (2073a0 <LoopFillZerobss+0x1c>)
  ldr  r3, =_edata
  207372:	4b0c      	ldr	r3, [pc, #48]	; (2073a4 <LoopFillZerobss+0x20>)
  adds  r2, r0, r1
  207374:	1842      	adds	r2, r0, r1
  cmp  r2, r3
  207376:	429a      	cmp	r2, r3
  bcc  CopyDataInit
  207378:	d3f6      	bcc.n	207368 <CopyDataInit>
  ldr  r2, =_sbss
  20737a:	4a0b      	ldr	r2, [pc, #44]	; (2073a8 <LoopFillZerobss+0x24>)
  b  LoopFillZerobss
  20737c:	e002      	b.n	207384 <LoopFillZerobss>

0020737e <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
  20737e:	2300      	movs	r3, #0
  str  r3, [r2], #4
  207380:	f842 3b04 	str.w	r3, [r2], #4

00207384 <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
  207384:	4b09      	ldr	r3, [pc, #36]	; (2073ac <LoopFillZerobss+0x28>)
  cmp  r2, r3
  207386:	429a      	cmp	r2, r3
  bcc  FillZerobss
  207388:	d3f9      	bcc.n	20737e <FillZerobss>

/* Call the clock system initialization function.*/
  bl  SystemInit   
  20738a:	f7ff f943 	bl	206614 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
  20738e:	f000 f855 	bl	20743c <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
  207392:	f7fd f8d7 	bl	204544 <main>
  bx  lr    
  207396:	4770      	bx	lr
  ldr   sp, =_estack      /* set stack pointer */
  207398:	20050000 	.word	0x20050000
  ldr  r3, =_sidata
  20739c:	002080b4 	.word	0x002080b4
  ldr  r0, =_sdata
  2073a0:	20000000 	.word	0x20000000
  ldr  r3, =_edata
  2073a4:	20000018 	.word	0x20000018
  ldr  r2, =_sbss
  2073a8:	20000018 	.word	0x20000018
  ldr  r3, = _ebss
  2073ac:	20000620 	.word	0x20000620

002073b0 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
  2073b0:	e7fe      	b.n	2073b0 <ADC_IRQHandler>
	...

002073b4 <arm_sin_f32>:
  2073b4:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
  2073b8:	ed9f 7a1d 	vldr	s14, [pc, #116]	; 207430 <arm_sin_f32+0x7c>
  2073bc:	ee20 7a07 	vmul.f32	s14, s0, s14
  2073c0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  2073c4:	eefd 7ac7 	vcvt.s32.f32	s15, s14
  2073c8:	d42c      	bmi.n	207424 <arm_sin_f32+0x70>
  2073ca:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  2073ce:	eddf 6a19 	vldr	s13, [pc, #100]	; 207434 <arm_sin_f32+0x80>
  2073d2:	ee77 7a67 	vsub.f32	s15, s14, s15
  2073d6:	ee67 7aa6 	vmul.f32	s15, s15, s13
  2073da:	eef4 7ae6 	vcmpe.f32	s15, s13
  2073de:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  2073e2:	db01      	blt.n	2073e8 <arm_sin_f32+0x34>
  2073e4:	ee77 7ae6 	vsub.f32	s15, s15, s13
  2073e8:	eebc 7ae7 	vcvt.u32.f32	s14, s15
  2073ec:	4a12      	ldr	r2, [pc, #72]	; (207438 <arm_sin_f32+0x84>)
  2073ee:	ee17 3a10 	vmov	r3, s14
  2073f2:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
  2073f6:	f3c3 0308 	ubfx	r3, r3, #0, #9
  2073fa:	ee06 3a90 	vmov	s13, r3
  2073fe:	eb02 0183 	add.w	r1, r2, r3, lsl #2
  207402:	eef8 6a66 	vcvt.f32.u32	s13, s13
  207406:	ed91 0a00 	vldr	s0, [r1]
  20740a:	ee77 7ae6 	vsub.f32	s15, s15, s13
  20740e:	edd1 6a01 	vldr	s13, [r1, #4]
  207412:	ee37 7a67 	vsub.f32	s14, s14, s15
  207416:	ee67 7aa6 	vmul.f32	s15, s15, s13
  20741a:	ee27 0a00 	vmul.f32	s0, s14, s0
  20741e:	ee30 0a27 	vadd.f32	s0, s0, s15
  207422:	4770      	bx	lr
  207424:	ee17 3a90 	vmov	r3, s15
  207428:	3b01      	subs	r3, #1
  20742a:	ee07 3a90 	vmov	s15, r3
  20742e:	e7cc      	b.n	2073ca <arm_sin_f32+0x16>
  207430:	3e22f983 	.word	0x3e22f983
  207434:	44000000 	.word	0x44000000
  207438:	002078a8 	.word	0x002078a8

0020743c <__libc_init_array>:
  20743c:	b570      	push	{r4, r5, r6, lr}
  20743e:	4e0d      	ldr	r6, [pc, #52]	; (207474 <__libc_init_array+0x38>)
  207440:	4c0d      	ldr	r4, [pc, #52]	; (207478 <__libc_init_array+0x3c>)
  207442:	1ba4      	subs	r4, r4, r6
  207444:	10a4      	asrs	r4, r4, #2
  207446:	2500      	movs	r5, #0
  207448:	42a5      	cmp	r5, r4
  20744a:	d109      	bne.n	207460 <__libc_init_array+0x24>
  20744c:	4e0b      	ldr	r6, [pc, #44]	; (20747c <__libc_init_array+0x40>)
  20744e:	4c0c      	ldr	r4, [pc, #48]	; (207480 <__libc_init_array+0x44>)
  207450:	f000 f820 	bl	207494 <_init>
  207454:	1ba4      	subs	r4, r4, r6
  207456:	10a4      	asrs	r4, r4, #2
  207458:	2500      	movs	r5, #0
  20745a:	42a5      	cmp	r5, r4
  20745c:	d105      	bne.n	20746a <__libc_init_array+0x2e>
  20745e:	bd70      	pop	{r4, r5, r6, pc}
  207460:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
  207464:	4798      	blx	r3
  207466:	3501      	adds	r5, #1
  207468:	e7ee      	b.n	207448 <__libc_init_array+0xc>
  20746a:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
  20746e:	4798      	blx	r3
  207470:	3501      	adds	r5, #1
  207472:	e7f2      	b.n	20745a <__libc_init_array+0x1e>
  207474:	002080ac 	.word	0x002080ac
  207478:	002080ac 	.word	0x002080ac
  20747c:	002080ac 	.word	0x002080ac
  207480:	002080b0 	.word	0x002080b0

00207484 <memset>:
  207484:	4402      	add	r2, r0
  207486:	4603      	mov	r3, r0
  207488:	4293      	cmp	r3, r2
  20748a:	d100      	bne.n	20748e <memset+0xa>
  20748c:	4770      	bx	lr
  20748e:	f803 1b01 	strb.w	r1, [r3], #1
  207492:	e7f9      	b.n	207488 <memset+0x4>

00207494 <_init>:
  207494:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  207496:	bf00      	nop
  207498:	bcf8      	pop	{r3, r4, r5, r6, r7}
  20749a:	bc08      	pop	{r3}
  20749c:	469e      	mov	lr, r3
  20749e:	4770      	bx	lr

002074a0 <_fini>:
  2074a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  2074a2:	bf00      	nop
  2074a4:	bcf8      	pop	{r3, r4, r5, r6, r7}
  2074a6:	bc08      	pop	{r3}
  2074a8:	469e      	mov	lr, r3
  2074aa:	4770      	bx	lr
